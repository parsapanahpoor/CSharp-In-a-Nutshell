<div dir="ltr" style="text-align: left;">

## â“ Q9:

## Why do Virtual Methods have Performance Overhead?

### âœ… Answer:

Because they must check the **actual type** of the object at **runtime** and call the correct method.

<div dir="ltr" style="text-align: left;">

```csharp
class Animal {
    public virtual void Speak() { }  // Virtual
    public void Eat() { }             // Non-virtual
}

Animal animal = new Dog();

// Virtual Call:
animal.Speak();  // âš ï¸ Must check VMT (~2-3 CPU cycles)

// Direct Call:
animal.Eat();     // âœ… Goes directly to Animal.Eat (~1 CPU cycle)
```

<div dir="ltr" style="text-align: left;">

### ğŸ“Š Performance Comparison:

| Type | CPU Cycles | Explanation |
|-----|-----------|-------|
| **Non-virtual** | ~1 | Direct call |
| **Virtual** | ~2-3 | VMT lookup |

### ğŸ¯ Note:

This overhead is **very negligible** and doesn't matter in 99% of cases. The benefits of Polymorphism are much greater!

### âš ï¸ Only in Hot Paths:

If you're in a very repetitive loop, it might matter. In that case, use `sealed override`.
