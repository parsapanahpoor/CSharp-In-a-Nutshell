<div dir="ltr" style="text-align: left;">

## ‚ùì Q20:

## How do Virtual Method Calls work with Reflection and Dynamic Dispatch?

### ‚úÖ Deep Answer:

Reflection and Dynamic Dispatch are other methods for method invocation that differ from Virtual Methods.

### üîç Reflection Method Invocation:

<div dir="ltr" style="text-align: left;">

```csharp
class Animal {
    public virtual void Speak() => Console.WriteLine("Animal");
}

class Dog : Animal {
    public override void Speak() => Console.WriteLine("Dog");
}

Animal animal = new Dog();

// With Reflection:
Type type = animal.GetType();
MethodInfo method = type.GetMethod("Speak");
method.Invoke(animal, null);  // ‚úÖ "Dog" (Virtual dispatch works!)
```

<div dir="ltr" style="text-align: left;">

### üî¨ Difference with Direct Call:

<div dir="ltr" style="text-align: left;">

```csharp
// Direct Call:
animal.Speak();  // ~2-3 CPU cycles (Virtual Call)

// Reflection:
MethodInfo method = typeof(Animal).GetMethod("Speak");
method.Invoke(animal, null);  // ~1000-10000 CPU cycles ‚ö†Ô∏è
// Must:
// 1. Metadata lookup
// 2. Method resolution
// 3. Virtual dispatch
// 4. Invocation
```

<div dir="ltr" style="text-align: left;">

### üîç Dynamic Dispatch:

<div dir="ltr" style="text-align: left;">

```csharp
dynamic animal = new Dog();

// Dynamic Call:
animal.Speak();  // ~100-1000 CPU cycles ‚ö†Ô∏è
// DLR (Dynamic Language Runtime) does these:
// 1. Type resolution
// 2. Method lookup
// 3. Virtual dispatch (if virtual)
// 4. Call site caching
```

<div dir="ltr" style="text-align: left;">

### üìä Performance Comparison:

| Method | CPU Cycles | Type Safety | Virtual Dispatch |
|-----|-----------|-------------|------------------|
| **Direct Call** | ~1 | ‚úÖ Compile-time | ‚ùå |
| **Virtual Call** | ~2-3 | ‚úÖ Runtime | ‚úÖ |
| **Dynamic Call** | ~100-1000 | ‚ö†Ô∏è Runtime | ‚úÖ (if virtual) |
| **Reflection** | ~1000-10000 | ‚ö†Ô∏è Runtime | ‚úÖ (if virtual) |

### üî¨ Virtual Dispatch in Reflection:

<div dir="ltr" style="text-align: left;">

```csharp
// Reflection also respects Virtual Dispatch:
Animal animal = new Dog();
MethodInfo method = typeof(Animal).GetMethod("Speak");

// This makes Virtual Call (not Direct Call):
method.Invoke(animal, null);  // ‚úÖ "Dog" (Virtual dispatch)
```

<div dir="ltr" style="text-align: left;">

### üéØ Advanced Note:

**Reflection** and **Dynamic** both **respect** Virtual Dispatch! Meaning if method is virtual, Derived method executes.

### ‚ö†Ô∏è Performance Warning:

Use Reflection and Dynamic only when **really necessary**! Performance overhead is very high.

### üí° Correct Usage:

- **Direct/Virtual Call**: For normal code (best performance)
- **Dynamic**: For interop with dynamic languages or COM
- **Reflection**: For metadata inspection or plugin systems
