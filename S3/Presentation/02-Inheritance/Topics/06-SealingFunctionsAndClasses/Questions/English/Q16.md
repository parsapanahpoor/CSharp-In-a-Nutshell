<div dir="ltr" style="text-align: left;">

## â“ Q16:

## How do Devirtualization and JIT Optimization work with Sealed?

### âœ… Deep Answer:

JIT Compiler can perform **Devirtualization** with Sealed Classes and Methods and convert Virtual Call to Direct Call.

### ğŸ” Devirtualization Process:

<div dir="ltr" style="text-align: left;">

```csharp
class Base {
    public virtual void Method() { }
}

sealed class Derived : Base {
    public override void Method() { }
}

Base obj = new Derived();
obj.Method();  // What happens?
```

<div dir="ltr" style="text-align: left;">

### âš™ï¸ JIT Optimization:

**Without Sealed:**
- Virtual Call â†’ VMT Lookup â†’ ~2-3 CPU cycles

**With Sealed:**
- JIT sees that Derived is sealed
- Knows that Method won't be overridden anymore
- Performs **Devirtualization**
- Direct Call â†’ ~1 CPU cycle âœ…

<div dir="ltr" style="text-align: left;">

```csharp
// JIT can convert this code:
Base obj = new Derived();
obj.Method();  // Virtual Call

// To this:
Derived obj = new Derived();
obj.Method();  // Direct Call (Optimized!)
```

<div dir="ltr" style="text-align: left;">

### ğŸ¯ Advanced Note:

Devirtualization only happens in **Release mode** and with **Tiered JIT** enabled. In Debug mode it may always make Virtual Call.

### ğŸ“Š Performance Impact:

| State | Call Type | CPU Cycles | Optimization |
|------|-----------|------------|--------------|
| Virtual (without sealed) | Virtual Call | 2-3 | âŒ |
| Sealed Override | Direct Call | 1 | âœ… |
| Sealed Class | Direct Call | 1 | âœ… |
