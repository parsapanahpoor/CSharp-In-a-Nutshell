<div dir="ltr" style="text-align: left;">

## â“ Q18:

## How do Covariance and Contravariance work in Casting?

### âœ… Deep Answer:

**Covariance** and **Contravariance** are rules that determine which types of casts are allowed.

### ğŸ” Covariance (with Arrays - Legacy):

<div dir="ltr" style="text-align: left;">

```csharp
class Animal { }
class Dog : Animal { }

// Arrays in C# are Covariant (but dangerous!):
Animal[] animals = new Dog[10];  // âœ… Covariance
// But:
animals[0] = new Cat();  // âŒ ArrayTypeMismatchException at runtime!
// Because animals is actually Dog[], not Animal[]
```

<div dir="ltr" style="text-align: left;">

### âš ï¸ Covariance Problem in Arrays:

This is a **design mistake** in C#! It causes runtime exception.

### âœ… Covariance in Interfaces (Modern):

<div dir="ltr" style="text-align: left;">

```csharp
// IEnumerable<T> is Covariant (out keyword):
IEnumerable<Animal> animals = new List<Dog>();  // âœ…
// Because IEnumerable<out T>

// But List<T> is not Covariant:
// List<Animal> animals = new List<Dog>();  // âŒ Error
```

<div dir="ltr" style="text-align: left;">

### ğŸ” Contravariance:

<div dir="ltr" style="text-align: left;">

```csharp
// IComparer<T> is Contravariant (in keyword):
IComparer<Animal> animalComparer = new DogComparer();  // âœ…
// Because IComparer<in T>

// Meaning we can convert Animal comparer to Dog comparer
```

<div dir="ltr" style="text-align: left;">

### ğŸ“Š Summary:

| Type | Keyword | Example |
|-----|---------|------|
| **Covariant** | `out` | `IEnumerable<out T>` |
| **Contravariant** | `in` | `IComparer<in T>` |
| **Invariant** | - | `List<T>` |

### ğŸ¯ Advanced Note:

- **Covariance**: Derived â†’ Base (for return types)
- **Contravariance**: Base â†’ Derived (for parameter types)
- **Invariant**: No conversion allowed

### âš ï¸ Limitation:

Covariance/Contravariance only works in **Interfaces** and **Delegates**, not in Classes!
