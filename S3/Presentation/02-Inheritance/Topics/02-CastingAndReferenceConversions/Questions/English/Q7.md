<div dir="ltr" style="text-align: left;">

## â“ Q7:

## Why can't we access Derived methods after Upcast?

### âœ… Answer:

Because the reference type is **Animal**, it only sees **Animal** methods, not **Dog** methods.

<div dir="ltr" style="text-align: left;">

```csharp
class Animal {
    public void Eat() => Console.WriteLine("Eating");
}

class Dog : Animal {
    public void Bark() => Console.WriteLine("Woof!");
}

Dog dog = new Dog();
Animal animal = dog;  // Upcast

animal.Eat();   // âœ… OK - Eat is in Animal
// animal.Bark();  // âŒ Error! Animal doesn't know what Bark is
```

<div dir="ltr" style="text-align: left;">

### ğŸ” Why?

The compiler only decides based on the **reference type**, not the actual type of the object!

### âœ… Solution:

<div dir="ltr" style="text-align: left;">

```csharp
// Downcast:
Dog dog2 = (Dog)animal;
dog2.Bark();  // âœ… OK
```

<div dir="ltr" style="text-align: left;">

### ğŸ¯ Note:

Upcasting **limits access**, but the object remains the same object.
