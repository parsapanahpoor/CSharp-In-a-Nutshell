<div dir="ltr" style="text-align: left;">

## â“ Q18:

## How does Overload Resolution work with Covariance and Contravariance?

### âœ… Deep Answer:

Covariance and Contravariance affect Overload Resolution, but only in **Interfaces** and **Delegates**.

### ğŸ” Covariance in Interfaces:

<div dir="ltr" style="text-align: left;">

```csharp
class Animal { }
class Dog : Animal { }

interface IProcessor<out T> {
    void Process(T item);
}

class Processor<T> : IProcessor<T> {
    public void Process(T item) { }
}

// Covariance:
IProcessor<Animal> processor = new Processor<Dog>();  // âœ…
processor.Process(new Dog());  // âœ…
```

<div dir="ltr" style="text-align: left;">

### âš ï¸ But in Classes:

<div dir="ltr" style="text-align: left;">

```csharp
class Processor<T> {
    public void Process(T item) { }
}

// âŒ Cannot do this:
// Processor<Animal> p = new Processor<Dog>();  // Error: Generic types invariant
```

<div dir="ltr" style="text-align: left;">

### ğŸ”¬ Overload Resolution:

<div dir="ltr" style="text-align: left;">

```csharp
class Test {
    public void Method(Animal a) { }
    public void Method(Dog d) { }
}

var test = new Test();
Animal animal = new Dog();
test.Method(animal);  // Method(Animal) âœ… (reference type matters)
test.Method(new Dog());  // Method(Dog) âœ… (actual type matters)
```

<div dir="ltr" style="text-align: left;">

### ğŸ¯ Advanced Note:

Overload Resolution is based on **compile-time type**, not runtime type. Covariance only works in Interfaces.

### âš ï¸ Limitation:

Generic Classes are **Invariant**. Covariance/Contravariance only in Interfaces and Delegates.
