<div dir="ltr" style="text-align: left;">

## â“ Q20:

## How does Overload Resolution work with Design Patterns and Best Practices?

### âœ… Deep Answer:

Overload Resolution plays an important role in Design Patterns and Best Practices.

### ğŸ” Factory Pattern with Overloading:

<div dir="ltr" style="text-align: left;">

```csharp
class AnimalFactory {
    public static Animal Create(string type) {
        return type switch {
            "Dog" => new Dog(),
            "Cat" => new Cat(),
            _ => throw new ArgumentException()
        };
    }
    
    // Overload for convenience:
    public static Animal CreateDog() => new Dog();
    public static Animal CreateCat() => new Cat();
}
```

<div dir="ltr" style="text-align: left;">

### ğŸ”¬ Builder Pattern:

<div dir="ltr" style="text-align: left;">

```csharp
class PersonBuilder {
    private string name;
    private int age;
    
    public PersonBuilder WithName(string name) {
        this.name = name;
        return this;
    }
    
    // Overload for convenience:
    public PersonBuilder WithName(string firstName, string lastName) {
        this.name = $"{firstName} {lastName}";
        return this;
    }
    
    public PersonBuilder WithAge(int age) {
        this.age = age;
        return this;
    }
    
    public Person Build() {
        return new Person(name, age);
    }
}
```

<div dir="ltr" style="text-align: left;">

### ğŸ¯ Best Practices:

**1. Use Overloading for same operation:**

<div dir="ltr" style="text-align: left;">

```csharp
// âœ… Good: Same operation
class Math {
    public int Add(int a, int b) => a + b;
    public double Add(double a, double b) => a + b;
}

// âŒ Bad: Different operation
class Processor {
    // public void Process(int x) { }
    // public void Process(string s) { }  // Different operation! Use different names
}
```

<div dir="ltr" style="text-align: left;">

**2. Use Optional Parameters instead of Overloading:**

<div dir="ltr" style="text-align: left;">

```csharp
// âœ… Good: Optional Parameters
class Test {
    public void Method(int a, int b = 0, int c = 0) { }
}

// âš ï¸ Bad: Too much Overloading
class Test {
    public void Method(int a) { }
    public void Method(int a, int b) { }
    public void Method(int a, int b, int c) { }
}
```

<div dir="ltr" style="text-align: left;">

### âš ï¸ Anti-Patterns:

**1. Overloading with Return Type:**

<div dir="ltr" style="text-align: left;">

```csharp
// âŒ Cannot do:
// public int Method() { return 1; }
// public string Method() { return "1"; }
```

<div dir="ltr" style="text-align: left;">

**2. Ambiguous Overloading:**

<div dir="ltr" style="text-align: left;">

```csharp
// âŒ Ambiguous:
class Test {
    public void Method(int x, double y) { }
    public void Method(double x, int y) { }
}
```

<div dir="ltr" style="text-align: left;">

### ğŸ’¡ Recommendation:

1. **Use Overloading for same operation**
2. **Use Optional Parameters instead of too much Overloading**
3. **Use clear names** (if operation is different)
4. **Avoid Ambiguous Overloading**

### ğŸ¯ Conclusion:

Overload Resolution is a **power**, but must be used **correctly**. Use Overloading for **same operation with different types**, not for **different operations**.
