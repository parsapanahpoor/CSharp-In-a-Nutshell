<div dir="ltr" style="text-align: left;">

## ‚ùì Q19:

## How does Overload Resolution work with Reflection and Runtime Type Information?

### ‚úÖ Deep Answer:

Reflection can perform Overload Resolution at runtime, but it's **very slow**.

### üîç Reflection for Overload Resolution:

<div dir="ltr" style="text-align: left;">

```csharp
class Test {
    public void Method(int x) { }
    public void Method(double x) { }
    public void Method(string x) { }
}

var test = new Test();

// With Reflection:
Type type = typeof(Test);
MethodInfo[] methods = type.GetMethods()
    .Where(m => m.Name == "Method")
    .ToArray();

// Find best match:
object arg = 5;
MethodInfo bestMatch = null;
int minCost = int.MaxValue;

foreach (var method in methods) {
    ParameterInfo[] parameters = method.GetParameters();
    if (parameters.Length == 1) {
        Type paramType = parameters[0].ParameterType;
        int cost = CalculateConversionCost(arg.GetType(), paramType);
        if (cost < minCost) {
            minCost = cost;
            bestMatch = method;
        }
    }
}

bestMatch.Invoke(test, new object[] { arg });  // ‚úÖ
```

<div dir="ltr" style="text-align: left;">

### üî¨ Type.GetMethod() with BindingFlags:

<div dir="ltr" style="text-align: left;">

```csharp
// Find method with Type:
Type type = typeof(Test);
MethodInfo method = type.GetMethod("Method", new Type[] { typeof(int) });
method.Invoke(test, new object[] { 5 });  // ‚úÖ
```

<div dir="ltr" style="text-align: left;">

### üéØ Advanced Note:

Reflection can perform **Overload Resolution** at runtime, but you must implement the algorithm yourself.

### ‚ö†Ô∏è Performance:

Reflection for Overload Resolution is **very slow** (~1000-10000 CPU cycles). Only use for **Dynamic Scenarios**.

### üí° Usage:

- **Plugin Systems**: Dynamic method invocation
- **Scripting**: Runtime method resolution
- **Testing**: Dynamic test execution
