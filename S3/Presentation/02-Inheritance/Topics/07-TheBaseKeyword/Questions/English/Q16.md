<div dir="ltr" style="text-align: left;">

## ‚ùì Q16:

## How do base Resolution and Method Lookup work at Runtime?

### ‚úÖ Deep Answer:

`base` keyword is resolved at compile-time and refers to **direct Base Class**.

### üîç Resolution Process:

<div dir="ltr" style="text-align: left;">

```csharp
class Base {
    public virtual void Method() {
        Console.WriteLine("Base");
    }
}

class Derived : Base {
    public override void Method() {
        base.Method();  // What happens?
    }
}
```

<div dir="ltr" style="text-align: left;">

### ‚öôÔ∏è Compile-time Resolution:

**Step 1: Type Resolution**
- Compiler sees that `base` is used in `Derived`
- Goes to Base Class: `Base`

**Step 2: Member Lookup**
- Searches for `Method()` in Base Class
- Finds: `Base.Method()`

**Step 3: Code Generation**
- Code is generated that calls `Base.Method()`
- **Direct Call** to Base Method (not Virtual Call!)

<div dir="ltr" style="text-align: left;">

```csharp
// Compiler converts this code:
base.Method();

// To this:
Base.Method(this);  // Direct call (not virtual!)
```

<div dir="ltr" style="text-align: left;">

### üéØ Advanced Note:

`base` makes **Direct Call**, not Virtual Call! This means Base Method is always called, even if it's overridden.

### ‚ö° Performance:

- **base.Method()**: Direct Call (~1 CPU cycle) ‚úÖ
- **this.Method()**: Virtual Call (~2-3 CPU cycles) ‚ö†Ô∏è
