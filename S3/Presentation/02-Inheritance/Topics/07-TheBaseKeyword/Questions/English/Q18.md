<div dir="ltr" style="text-align: left;">

## ‚ùì Q18:

## How does base work with Reflection and Runtime Type Information?

### ‚úÖ Deep Answer:

Reflection can find Base Members and work with `base`.

### üîç Reflection for Base Members:

<div dir="ltr" style="text-align: left;">

```csharp
class Base {
    public virtual void Method() {
        Console.WriteLine("Base");
    }
}

class Derived : Base {
    public override void Method() {
        base.Method();
    }
}

// Reflection:
Type derivedType = typeof(Derived);
Type baseType = derivedType.BaseType;  // Base ‚úÖ

MethodInfo baseMethod = baseType.GetMethod("Method");
MethodInfo derivedMethod = derivedType.GetMethod("Method");

// Check Base Definition:
MethodInfo baseDefinition = derivedMethod.GetBaseDefinition();
Console.WriteLine(baseDefinition.DeclaringType);  // Base ‚úÖ
```

<div dir="ltr" style="text-align: left;">

### üî¨ Invoking Base Methods:

<div dir="ltr" style="text-align: left;">

```csharp
Derived obj = new Derived();

// With Reflection we can call Base Method:
MethodInfo baseMethod = typeof(Base).GetMethod("Method");
baseMethod.Invoke(obj, null);  // ‚úÖ Base.Method() is called

// Or from GetBaseDefinition:
MethodInfo derivedMethod = typeof(Derived).GetMethod("Method");
MethodInfo baseDef = derivedMethod.GetBaseDefinition();
baseDef.Invoke(obj, null);  // ‚úÖ Base.Method()
```

<div dir="ltr" style="text-align: left;">

### üéØ Advanced Note:

Reflection can find **Base Members** and access Base Method with `GetBaseDefinition()`.

### ‚ö†Ô∏è Performance:

Reflection for Base Methods is **very slow** (~1000-10000 CPU cycles). Only use for **Inspection**.
