<div dir="rtl" style="text-align: right;">

## â“ Q20:

## Inheritance Ø¨Ø§ Generics Ùˆ Type Constraints Ú†Ø·ÙˆØ± Ú©Ø§Ø± Ù…ÛŒâ€ŒÚ©Ù†Ù‡ØŸ

### âœ… Ø¬ÙˆØ§Ø¨ Ø¹Ù…ÛŒÙ‚:

Ø§ÛŒÙ† ÛŒÚ©ÛŒ Ø§Ø² Ù¾ÛŒÚ†ÛŒØ¯Ù‡â€ŒØªØ±ÛŒÙ† Ù…ÙˆØ§Ø±Ø¯ Inheritance Ø§Ø³Øª Ú©Ù‡ Generic Types Ø±Ùˆ Ø¨Ø§ Inheritance ØªØ±Ú©ÛŒØ¨ Ù…ÛŒâ€ŒÚ©Ù†Ù‡.

### ğŸ” Generic Inheritance:

<div dir="ltr" style="text-align: left;">

```csharp
class Base<T> {
    public T Value { get; set; }
    public virtual void Process(T item) {
        Console.WriteLine($"Base processing: {item}");
    }
}

class Derived<T> : Base<T> {
    public override void Process(T item) {
        base.Process(item);
        Console.WriteLine($"Derived processing: {item}");
    }
}

// Ø§Ø³ØªÙØ§Ø¯Ù‡:
Derived<int> d = new Derived<int>();
d.Value = 42;
d.Process(42);
```

<div dir="rtl" style="text-align: right;">

### ğŸ”¬ Type Constraints Ùˆ Inheritance:

<div dir="ltr" style="text-align: left;">

```csharp
class Animal { }
class Dog : Animal { }
class Cat : Animal { }

// Base Ø¨Ø§ constraint:
class Base<T> where T : Animal {
    public virtual void Process(T animal) {
        animal.Eat();  // Ù…ÛŒâ€ŒØ¯ÙˆÙ†Ù‡ T : Animal Ø§Ø³Øª
    }
}

// Derived Ø¨Ø§ constraint Ù…Ø´Ø§Ø¨Ù‡:
class Derived<T> : Base<T> where T : Animal {
    public override void Process(T animal) {
        base.Process(animal);
        // Ù…ÛŒâ€ŒØªÙˆÙ†ÛŒÙ… Ù…ØªØ¯Ù‡Ø§ÛŒ Animal Ø±Ùˆ ØµØ¯Ø§ Ø¨Ø²Ù†ÛŒÙ…
    }
}

// Ø§Ø³ØªÙØ§Ø¯Ù‡:
Derived<Dog> dogProcessor = new Derived<Dog>();
dogProcessor.Process(new Dog());
```

<div dir="rtl" style="text-align: right;">

### âš ï¸ Ù…Ø´Ú©Ù„ Covariance Ø¯Ø± Generics:

<div dir="ltr" style="text-align: left;">

```csharp
// âŒ Ø§ÛŒÙ† Ú©Ø§Ø± Ù†Ù…ÛŒâ€ŒÚ©Ù†Ù‡:
Base<Animal> baseRef = new Derived<Dog>();  
// Error: Cannot convert Derived<Dog> to Base<Animal>

// Ú†Ø±Ø§ØŸ Ú†ÙˆÙ† Generic Types invariant Ù‡Ø³ØªÙ†Ø¯ (Ø¨Ù‡ Ø·ÙˆØ± Ù¾ÛŒØ´â€ŒÙØ±Ø¶)
```

<div dir="rtl" style="text-align: right;">

### âœ… Ø±Ø§Ù‡ Ø­Ù„: Covariant Interfaces

<div dir="ltr" style="text-align: left;">

```csharp
// Interface Ø¨Ø§ Covariance:
interface IProcessor<out T> where T : Animal {
    T GetAnimal();
    void Process();
}

class AnimalProcessor<T> : IProcessor<T> where T : Animal, new() {
    private T animal = new T();
    
    public T GetAnimal() => animal;
    
    public void Process() {
        animal.Eat();
    }
}

// Ø­Ø§Ù„Ø§ Covariance Ú©Ø§Ø± Ù…ÛŒâ€ŒÚ©Ù†Ù‡:
IProcessor<Animal> processor = new AnimalProcessor<Dog>();
// âœ… 'out' keyword Ø§Ø¬Ø§Ø²Ù‡ Covariance Ù…ÛŒâ€ŒØ¯Ù‡
```

<div dir="rtl" style="text-align: right;">

### ğŸ”¬ Ù…Ø«Ø§Ù„ Ù¾ÛŒÚ†ÛŒØ¯Ù‡: Multiple Constraints

<div dir="ltr" style="text-align: left;">

```csharp
interface IFlyable {
    void Fly();
}

interface ISwimmable {
    void Swim();
}

class Duck : Animal, IFlyable, ISwimmable {
    public void Fly() { }
    public void Swim() { }
}

// Generic Ø¨Ø§ Multiple Constraints:
class Processor<T> : Base<T> 
    where T : Animal, IFlyable, ISwimmable, new() {
    
    public void ProcessAll(T item) {
        item.Eat();    // Ø§Ø² Animal
        item.Fly();    // Ø§Ø² IFlyable
        item.Swim();   // Ø§Ø² ISwimmable
    }
}

Processor<Duck> processor = new Processor<Duck>();
processor.ProcessAll(new Duck());
```

<div dir="rtl" style="text-align: right;">

### ğŸ¯ Ù†Ú©Ø§Øª Ù¾ÛŒØ´Ø±ÙØªÙ‡:

1. **Generic Inheritance** Ù…ÛŒâ€ŒØªÙˆÙ†Ù‡ Ø®ÛŒÙ„ÛŒ Ù¾ÛŒÚ†ÛŒØ¯Ù‡ Ø¨Ø´Ù‡
2. **Type Constraints** Ø¨Ø§ÛŒØ¯ Ø¯Ø± Derived class Ù‡Ù… ØªÚ©Ø±Ø§Ø± Ø¨Ø´Ù†
3. **Covariance/Contravariance** ÙÙ‚Ø· Ø¯Ø± Interfaces Ùˆ Delegates
4. **new() constraint** Ø¨Ø±Ø§ÛŒ instantiation
5. **struct/class constraints** Ø¨Ø±Ø§ÛŒ value/reference types

### âš ï¸ Ù…Ø­Ø¯ÙˆØ¯ÛŒØªâ€ŒÙ‡Ø§:

- Ù†Ù…ÛŒâ€ŒØªÙˆÙ†ÛŒÙ… constraint Ø±Ùˆ Ø¯Ø± Derived class ØªØºÛŒÛŒØ± Ø¨Ø¯ÛŒÙ…
- Ù†Ù…ÛŒâ€ŒØªÙˆÙ†ÛŒÙ… Generic class Ø±Ùˆ Ø¨Ù‡ Non-generic base ØªØ¨Ø¯ÛŒÙ„ Ú©Ù†ÛŒÙ…
- Type Erasure ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ù‡ (Ø¨Ø±Ø®Ù„Ø§Ù Java)

### ğŸ’¡ Ù†ØªÛŒØ¬Ù‡:

Inheritance Ø¨Ø§ Generics ØªØ±Ú©ÛŒØ¨ Ù‚Ø¯Ø±ØªÙ…Ù†Ø¯ÛŒ Ø§Ø³Øª Ø§Ù…Ø§ Ø¨Ø§ÛŒØ¯ Ø¯Ù‚Øª Ú©Ù†ÛŒÙ… Ú©Ù‡ **Type Safety** Ø­ÙØ¸ Ø¨Ø´Ù‡ Ùˆ **Constraints** Ø¯Ø±Ø³Øª ØªØ¹Ø±ÛŒÙ Ø¨Ø´Ù†.

