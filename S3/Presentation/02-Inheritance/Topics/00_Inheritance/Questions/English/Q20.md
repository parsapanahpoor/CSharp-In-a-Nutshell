<div dir="ltr" style="text-align: left;">

## ‚ùì Q20:

## How does Inheritance work with Generics and Type Constraints?

### ‚úÖ Deep Answer:

This is one of the most complex cases of Inheritance that combines Generic Types with Inheritance.

### üîç Generic Inheritance:

<div dir="ltr" style="text-align: left;">

```csharp
class Base<T> {
    public T Value { get; set; }
    public virtual void Process(T item) {
        Console.WriteLine($"Base processing: {item}");
    }
}

class Derived<T> : Base<T> {
    public override void Process(T item) {
        base.Process(item);
        Console.WriteLine($"Derived processing: {item}");
    }
}

// Usage:
Derived<int> d = new Derived<int>();
d.Value = 42;
d.Process(42);
```

<div dir="ltr" style="text-align: left;">

### üî¨ Type Constraints and Inheritance:

<div dir="ltr" style="text-align: left;">

```csharp
class Animal { }
class Dog : Animal { }
class Cat : Animal { }

// Base with constraint:
class Base<T> where T : Animal {
    public virtual void Process(T animal) {
        animal.Eat();  // Knows T : Animal
    }
}

// Derived with similar constraint:
class Derived<T> : Base<T> where T : Animal {
    public override void Process(T animal) {
        base.Process(animal);
        // Can call Animal methods
    }
}

// Usage:
Derived<Dog> dogProcessor = new Derived<Dog>();
dogProcessor.Process(new Dog());
```

<div dir="ltr" style="text-align: left;">

### ‚ö†Ô∏è Covariance Problem in Generics:

<div dir="ltr" style="text-align: left;">

```csharp
// ‚ùå This doesn't work:
Base<Animal> baseRef = new Derived<Dog>();  
// Error: Cannot convert Derived<Dog> to Base<Animal>

// Why? Because Generic Types are invariant (by default)
```

<div dir="ltr" style="text-align: left;">

### ‚úÖ Solution: Covariant Interfaces

<div dir="ltr" style="text-align: left;">

```csharp
// Interface with Covariance:
interface IProcessor<out T> where T : Animal {
    T GetAnimal();
    void Process();
}

class AnimalProcessor<T> : IProcessor<T> where T : Animal, new() {
    private T animal = new T();
    
    public T GetAnimal() => animal;
    
    public void Process() {
        animal.Eat();
    }
}

// Now Covariance works:
IProcessor<Animal> processor = new AnimalProcessor<Dog>();
// ‚úÖ 'out' keyword allows Covariance
```

<div dir="ltr" style="text-align: left;">

### üî¨ Complex Example: Multiple Constraints

<div dir="ltr" style="text-align: left;">

```csharp
interface IFlyable {
    void Fly();
}

interface ISwimmable {
    void Swim();
}

class Duck : Animal, IFlyable, ISwimmable {
    public void Fly() { }
    public void Swim() { }
}

// Generic with Multiple Constraints:
class Processor<T> : Base<T> 
    where T : Animal, IFlyable, ISwimmable, new() {
    
    public void ProcessAll(T item) {
        item.Eat();    // from Animal
        item.Fly();    // from IFlyable
        item.Swim();   // from ISwimmable
    }
}

Processor<Duck> processor = new Processor<Duck>();
processor.ProcessAll(new Duck());
```

<div dir="ltr" style="text-align: left;">

### üéØ Advanced Points:

1. **Generic Inheritance** can get very complex
2. **Type Constraints** must be repeated in Derived class
3. **Covariance/Contravariance** only in Interfaces and Delegates
4. **new() constraint** for instantiation
5. **struct/class constraints** for value/reference types

### ‚ö†Ô∏è Limitations:

- Cannot change constraint in Derived class
- Cannot convert Generic class to Non-generic base
- No Type Erasure (unlike Java)

### üí° Conclusion:

Inheritance with Generics is a powerful combination but we must be careful that **Type Safety** is maintained and **Constraints** are correctly defined.
