<div dir="ltr" style="text-align: left;">

## ‚ùì Q19:

## What is Field Initialization Order in Inheritance?

### ‚úÖ Deep Answer:

Initialization order in Inheritance is very important and can cause bugs!

### üîç Exact Initialization Order:

<div dir="ltr" style="text-align: left;">

```csharp
class Base {
    private int baseField1 = Initialize("Base Field 1");
    private static int baseStatic = InitializeStatic("Base Static");
    
    static Base() {
        Console.WriteLine("Base Static Constructor");
    }
    
    public Base() {
        Console.WriteLine("Base Instance Constructor");
    }
    
    private int baseField2 = Initialize("Base Field 2");
    
    private static int InitializeStatic(string name) {
        Console.WriteLine($"Initializing: {name}");
        return 0;
    }
    
    private int Initialize(string name) {
        Console.WriteLine($"Initializing: {name}");
        return 0;
    }
}

class Derived : Base {
    private int derivedField1 = Initialize("Derived Field 1");
    
    static Derived() {
        Console.WriteLine("Derived Static Constructor");
    }
    
    public Derived() {
        Console.WriteLine("Derived Instance Constructor");
    }
    
    private int derivedField2 = Initialize("Derived Field 2");
    
    private int Initialize(string name) {
        Console.WriteLine($"Initializing: {name}");
        return 0;
    }
}

new Derived();
```

<div dir="ltr" style="text-align: left;">

### üìä Output (Exact Order):

```
1. Base Static Field Initialization
2. Base Static Constructor
3. Derived Static Field Initialization
4. Derived Static Constructor
5. Base Instance Field 1
6. Base Instance Field 2
7. Base Instance Constructor
8. Derived Instance Field 1
9. Derived Instance Field 2
10. Derived Instance Constructor
```

### ‚ö†Ô∏è Common Problem:

<div dir="ltr" style="text-align: left;">

```csharp
class Base {
    protected int value = 10;
    
    public Base() {
        PrintValue();  // ‚ö†Ô∏è Derived field not yet initialized!
    }
    
    protected virtual void PrintValue() {
        Console.WriteLine($"Base: {value}");
    }
}

class Derived : Base {
    private int derivedValue = 20;  // Still 0!
    
    public Derived() : base() {
        // base() is called first
        // so derivedValue is not yet initialized
    }
    
    protected override void PrintValue() {
        Console.WriteLine($"Derived: {value}, {derivedValue}");
        // derivedValue = 0! ‚ùå (not yet initialized)
    }
}

new Derived();  // Output: "Derived: 10, 0" ‚ùå
```

<div dir="ltr" style="text-align: left;">

### ‚úÖ Solution:

<div dir="ltr" style="text-align: left;">

```csharp
class Base {
    protected int value = 10;
    
    public Base() {
        // Don't use virtual method in constructor!
        // Or if necessary, use Initialize() pattern
    }
    
    public void Initialize() {
        PrintValue();  // ‚úÖ After initialization
    }
    
    protected virtual void PrintValue() {
        Console.WriteLine($"Base: {value}");
    }
}

class Derived : Base {
    private int derivedValue = 20;
    
    protected override void PrintValue() {
        Console.WriteLine($"Derived: {value}, {derivedValue}");
        // ‚úÖ Now derivedValue = 20
    }
}

var d = new Derived();
d.Initialize();  // ‚úÖ "Derived: 10, 20"
```

<div dir="ltr" style="text-align: left;">

### üéØ General Rule:

1. **Static fields** first (from Base to Derived)
2. **Static constructors** next
3. **Instance fields** (from Base to Derived)
4. **Instance constructors** (from Base to Derived)

### ‚ö†Ô∏è Important Note:

**Never call virtual method in constructor** unless you're sure all fields are initialized!
