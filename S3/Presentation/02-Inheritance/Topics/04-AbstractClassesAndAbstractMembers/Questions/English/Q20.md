<div dir="ltr" style="text-align: left;">

## ‚ùì Q20:

## How do Abstract Class work with Design Patterns and SOLID Principles?

### ‚úÖ Deep Answer:

Abstract Classes play an important role in Design Patterns and SOLID Principles.

### üîç Template Method Pattern:

<div dir="ltr" style="text-align: left;">

```csharp
// Template Method Pattern with Abstract Class:
abstract class DataProcessor {
    // Template Method (Concrete):
    public void Process() {
        LoadData();      // Abstract
        ValidateData();  // Virtual
        TransformData(); // Abstract
        SaveData();      // Concrete
    }
    
    protected abstract void LoadData();
    protected virtual void ValidateData() {
        Console.WriteLine("Default validation");
    }
    protected abstract void TransformData();
    protected void SaveData() {
        Console.WriteLine("Saving...");
    }
}
```

<div dir="ltr" style="text-align: left;">

### üî¨ SOLID Principles:

**1. Single Responsibility Principle (SRP):**

<div dir="ltr" style="text-align: left;">

```csharp
// ‚ùå Bad: One Abstract Class with many responsibilities
abstract class Animal {
    public abstract void MakeSound();
    public abstract void Move();
    public abstract void Eat();
    public abstract void Reproduce();
    // Too many responsibilities!
}

// ‚úÖ Good: Interface Segregation
interface IAnimal {
    void MakeSound();
}
interface IMovable {
    void Move();
}
interface IFeedable {
    void Eat();
}
```

<div dir="ltr" style="text-align: left;">

**2. Open/Closed Principle (OCP):**

<div dir="ltr" style="text-align: left;">

```csharp
// ‚úÖ Abstract Class for Extension:
abstract class Shape {
    public abstract double Area { get; }
    public virtual void Draw() {
        Console.WriteLine("Drawing shape");
    }
}

// Can add new types without changing Shape:
class Circle : Shape {
    public override double Area => Math.PI * radius * radius;
}
```

<div dir="ltr" style="text-align: left;">

**3. Liskov Substitution Principle (LSP):**

<div dir="ltr" style="text-align: left;">

```csharp
// ‚úÖ Abstract Class must follow LSP:
abstract class Animal {
    public abstract void Move();
}

class Dog : Animal {
    public override void Move() {
        Console.WriteLine("Running");  // ‚úÖ Logical behavior
    }
}

// ‚ùå Violating LSP:
class Fish : Animal {
    public override void Move() {
        throw new NotSupportedException("Fish can't move on land!");
        // ‚ùå This violates LSP!
    }
}
```

<div dir="ltr" style="text-align: left;">

### üî¨ Dependency Inversion Principle (DIP):

<div dir="ltr" style="text-align: left;">

```csharp
// ‚úÖ Abstract Class for Dependency Inversion:
abstract class DataRepository {
    public abstract void Save(object data);
    public abstract object Load(int id);
}

class SqlRepository : DataRepository {
    public override void Save(object data) { }
    public override object Load(int id) { }
}

// Client code depends on Abstract Class, not Concrete:
class DataService {
    private DataRepository repository;  // ‚úÖ Abstract dependency
    
    public DataService(DataRepository repo) {
        repository = repo;
    }
}
```

<div dir="ltr" style="text-align: left;">

### üéØ Advanced Note:

Abstract Classes are excellent for **Template Method Pattern** and **Dependency Inversion**, but must follow **LSP** and **SRP**.

### ‚ö†Ô∏è Trade-offs:

- **Abstract Classes**: Partial Implementation, but Single Inheritance
- **Interfaces**: Multiple Inheritance, but without Implementation

### üí° Recommendation:

Use **Abstract Classes** for **Internal Hierarchies** and **Template Methods**.
Use **Interfaces** for **Public Contracts** and **Multiple Inheritance**.
