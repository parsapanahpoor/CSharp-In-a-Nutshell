<div dir="ltr" style="text-align: left;">

## ‚ùì Q18:

## How are Abstract Class Versioning and Breaking Changes managed?

### ‚úÖ Deep Answer:

Abstract Classes have **problems** in Versioning that we must be careful about.

### ‚ö†Ô∏è Versioning Problem:

<div dir="ltr" style="text-align: left;">

```csharp
// Version 1:
abstract class Animal {
    public abstract void MakeSound();
}

class Dog : Animal {
    public override void MakeSound() { }
}

// Version 2: Add a new abstract method
abstract class Animal {
    public abstract void MakeSound();
    public abstract void Move();  // ‚ö†Ô∏è Breaking Change!
}

// Now all derived classes must implement Move():
class Dog : Animal {
    public override void MakeSound() { }
    public override void Move() { }  // ‚úÖ Must add
}
```

<div dir="ltr" style="text-align: left;">

### ‚úÖ Solutions:

**1. Virtual Methods instead of Abstract:**

<div dir="ltr" style="text-align: left;">

```csharp
abstract class Animal {
    public abstract void MakeSound();
    
    // Instead of abstract, virtual with default implementation:
    public virtual void Move() {
        Console.WriteLine("Default movement");  // ‚úÖ Default behavior
    }
}
```

<div dir="ltr" style="text-align: left;">

**2. Extension Methods:**

<div dir="ltr" style="text-align: left;">

```csharp
abstract class Animal {
    public abstract void MakeSound();
}

// Extension method (without breaking change):
static class AnimalExtensions {
    public static void Move(this Animal animal) {
        Console.WriteLine("Default movement");
    }
}
```

<div dir="ltr" style="text-align: left;">

### üî¨ Interface Segregation:

<div dir="ltr" style="text-align: left;">

```csharp
// Instead of one large Abstract Class:
interface IAnimal {
    void MakeSound();
    void Move();
    void Eat();
}

// Use Interface Segregation:
interface IAnimal {
    void MakeSound();
}

interface IMovable {
    void Move();
}

interface IFeedable {
    void Eat();
}

// Classes only implement needed interfaces
```

<div dir="ltr" style="text-align: left;">

### üéØ Advanced Note:

**Abstract Classes** are **harder** for Versioning than Interfaces because:
- Adding abstract method = Breaking Change
- Cannot have Multiple Inheritance
- Derived classes must implement all abstract methods

### üí° Recommendation:

For **Public APIs**, use **Interfaces**. Abstract Classes are better for **Internal/Private** hierarchies.
