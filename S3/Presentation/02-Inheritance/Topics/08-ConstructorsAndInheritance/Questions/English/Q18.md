<div dir="ltr" style="text-align: left;">

## ‚ùì Q18:

## How do Constructors work with Reflection and Runtime Type Information?

### ‚úÖ Deep Answer:

Reflection can find Constructors at runtime and invoke them.

### üîç Reflection for Constructors:

<div dir="ltr" style="text-align: left;">

```csharp
class Base {
    public Base() { }
    public Base(string name) { }
}

class Derived : Base {
    public Derived() : base() { }
    public Derived(string name) : base(name) { }
}

// Reflection:
Type type = typeof(Derived);
ConstructorInfo[] constructors = type.GetConstructors();

foreach (var ctor in constructors) {
    Console.WriteLine($"Constructor: {ctor}");
    // Can see Base Constructor
}

// Invoking:
ConstructorInfo ctor = type.GetConstructor(new Type[] { typeof(string) });
object obj = ctor.Invoke(new object[] { "Test" });  // ‚úÖ
```

<div dir="ltr" style="text-align: left;">

### üî¨ Base Constructor Resolution:

<div dir="ltr" style="text-align: left;">

```csharp
Type derivedType = typeof(Derived);
Type baseType = derivedType.BaseType;

ConstructorInfo[] baseConstructors = baseType.GetConstructors();
// Can see Base Constructors
```

<div dir="ltr" style="text-align: left;">

### üéØ Advanced Note:

Reflection can inspect **Constructor Chain** and find Base Constructors.

### ‚ö†Ô∏è Performance:

Reflection for Constructors is **very slow** (~1000-10000 CPU cycles). Only use for **Inspection** or **Dynamic Instantiation**.
