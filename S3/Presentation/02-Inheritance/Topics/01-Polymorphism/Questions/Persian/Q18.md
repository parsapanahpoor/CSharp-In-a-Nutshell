<div dir="rtl" style="text-align: right;">

## â“ Q18:

## Method Resolution Ø¯Ø± Overloading Ø¨Ø§ Inheritance Ú†Ø·ÙˆØ± Ú©Ø§Ø± Ù…ÛŒâ€ŒÚ©Ù†Ù‡ØŸ

### âœ… Ø¬ÙˆØ§Ø¨ Ø¹Ù…ÛŒÙ‚:

Ú©Ø§Ù…Ù¾Ø§ÛŒÙ„Ø± C# ÛŒÚ© **Ø§Ù„Ú¯ÙˆØ±ÛŒØªÙ… Ù¾ÛŒÚ†ÛŒØ¯Ù‡** Ø¨Ø±Ø§ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ø¨Ù‡ØªØ±ÛŒÙ† Overload Ø¯Ø§Ø±Ù‡.

### ğŸ” Ø§Ù„Ú¯ÙˆØ±ÛŒØªÙ… Resolution:

<div dir="ltr" style="text-align: left;">

```csharp
class Base {
    public void Process(int x) => Console.WriteLine("Base: int");
    public void Process(object x) => Console.WriteLine("Base: object");
}

class Derived : Base {
    public void Process(double x) => Console.WriteLine("Derived: double");
    public void Process(string x) => Console.WriteLine("Derived: string");
}

Derived d = new Derived();
d.Process(5);  // Ú©Ø¯ÙˆÙ… Ù…ØªØ¯ ØµØ¯Ø§ Ø²Ø¯Ù‡ Ù…ÛŒâ€ŒØ´Ù‡ØŸ
```

<div dir="rtl" style="text-align: right;">

### ğŸ“Š Ù…Ø±Ø§Ø­Ù„ Resolution:

**Ù…Ø±Ø­Ù„Ù‡ 1: Candidate Methods**
- Ù‡Ù…Ù‡ Ù…ØªØ¯Ù‡Ø§ÛŒ Ù‚Ø§Ø¨Ù„ Ø¯Ø³ØªØ±Ø³ (Ø§Ø² Derived Ùˆ Base)
- `Process(int)`, `Process(object)`, `Process(double)`, `Process(string)`

**Ù…Ø±Ø­Ù„Ù‡ 2: Applicable Methods**
- Ù…ØªØ¯Ù‡Ø§ÛŒÛŒ Ú©Ù‡ Ø¨Ø§ argument type Ø³Ø§Ø²Ú¯Ø§Ø± Ù‡Ø³ØªÙ†Ø¯
- `Process(5)` â†’ `int` Ø§Ø³Øª
- âœ… `Process(int)` - Exact match
- âœ… `Process(object)` - Implicit conversion
- âœ… `Process(double)` - Implicit conversion
- âŒ `Process(string)` - Not applicable

**Ù…Ø±Ø­Ù„Ù‡ 3: Best Match (Type Conversion Cost)**
- Exact match: `Process(int)` â†’ Cost = 0 â­
- Implicit conversion: `Process(object)` â†’ Cost = 1
- Implicit conversion: `Process(double)` â†’ Cost = 1

**Ù†ØªÛŒØ¬Ù‡**: `Process(int)` Ø§Ø² Base ØµØ¯Ø§ Ø²Ø¯Ù‡ Ù…ÛŒâ€ŒØ´Ù‡!

<div dir="ltr" style="text-align: left;">

```csharp
d.Process(5);     // Base.Process(int) âœ…
d.Process(5.0);   // Derived.Process(double) âœ…
d.Process("Hi");  // Derived.Process(string) âœ…
d.Process((object)5);  // Base.Process(object) âœ…
```

<div dir="rtl" style="text-align: right;">

### âš ï¸ Ambiguity:

<div dir="ltr" style="text-align: left;">

```csharp
class Test {
    public void Method(int x, double y) { }
    public void Method(double x, int y) { }
}

var t = new Test();
t.Method(5, 5);  // âŒ Error: Ambiguous call!
// Ú©Ø§Ù…Ù¾Ø§ÛŒÙ„Ø± Ù†Ù…ÛŒâ€ŒØ¯ÙˆÙ†Ù‡ Ú©Ø¯ÙˆÙ… Ø±Ùˆ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†Ù‡
```

<div dir="rtl" style="text-align: right;">

### ğŸ¯ Ù†Ú©Ø§Øª Ù¾ÛŒØ´Ø±ÙØªÙ‡:

1. **Derived methods** Ø§ÙˆÙ„ÙˆÛŒØª Ø¯Ø§Ø±Ù†Ø¯ (Ø§Ú¯Ø± exact match Ø¨Ø§Ø´Ù†Ø¯)
2. **Type conversion cost** ØªØ¹ÛŒÛŒÙ†â€ŒÚ©Ù†Ù†Ø¯Ù‡ Ø§Ø³Øª
3. **Inheritance hierarchy** Ø¯Ø± resolution ØªØ§Ø«ÛŒØ± Ø¯Ø§Ø±Ù‡
4. **Generic type inference** Ù…ÛŒâ€ŒØªÙˆÙ†Ù‡ Ù¾ÛŒÚ†ÛŒØ¯Ù‡â€ŒØªØ±Ø´ Ú©Ù†Ù‡

