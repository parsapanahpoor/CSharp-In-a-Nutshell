<div dir="ltr" style="text-align: left;">

## ‚ùì Q20:

## How does Hiding work with Design Patterns and Best Practices?

### ‚úÖ Deep Answer:

Hiding is usually an **Anti-pattern** and we should avoid it. But in some special cases it's necessary.

### ‚ö†Ô∏è Anti-Pattern: Hiding

<div dir="ltr" style="text-align: left;">

```csharp
// ‚ùå Bad: Hiding for Polymorphism
class Base {
    public void Process() {
        Console.WriteLine("Base");
    }
}

class Derived : Base {
    public new void Process() {  // ‚ùå Hiding
        Console.WriteLine("Derived");
    }
}

Base obj = new Derived();
obj.Process();  // "Base" ‚ùå (not "Derived"!)
```

<div dir="ltr" style="text-align: left;">

### ‚úÖ Best Practice: Virtual/Override

<div dir="ltr" style="text-align: left;">

```csharp
// ‚úÖ Good: Virtual/Override for Polymorphism
class Base {
    public virtual void Process() {
        Console.WriteLine("Base");
    }
}

class Derived : Base {
    public override void Process() {  // ‚úÖ Override
        Console.WriteLine("Derived");
    }
}

Base obj = new Derived();
obj.Process();  // "Derived" ‚úÖ
```

<div dir="ltr" style="text-align: left;">

### üî¨ Correct Use Cases for Hiding:

**1. Third-party Library Integration:**

<div dir="ltr" style="text-align: left;">

```csharp
// Base is from Library and not virtual:
class ThirdPartyBase {  // From Library
    public void Method() { }  // Not virtual!
}

// We cannot change it:
class MyDerived : ThirdPartyBase {
    public new void Method() {  // ‚úÖ Hiding necessary
        // Custom implementation
    }
}
```

<div dir="ltr" style="text-align: left;">

**2. Backward Compatibility:**

<div dir="ltr" style="text-align: left;">

```csharp
// Version 1:
class Base {
    public void OldMethod() { }
}

// Version 2: Want to deprecate OldMethod:
class Base {
    [Obsolete("Use NewMethod instead")]
    public void OldMethod() { }
    
    public void NewMethod() { }
}

// But for Backward Compatibility:
class Derived : Base {
    public new void OldMethod() {  // ‚úÖ Hiding for compatibility
        NewMethod();  // Delegates to NewMethod
    }
}
```

<div dir="ltr" style="text-align: left;">

### üî¨ Design Patterns:

**Adapter Pattern with Hiding:**

<div dir="ltr" style="text-align: left;">

```csharp
// When we want to adapt an Interface:
interface ILegacyInterface {
    void OldMethod();
}

class LegacyImplementation : ILegacyInterface {
    public void OldMethod() { }
}

class ModernAdapter : LegacyImplementation {
    public new void OldMethod() {  // ‚úÖ Hiding for Adapter
        // Modern implementation
    }
}
```

<div dir="ltr" style="text-align: left;">

### üéØ Best Practices:

1. **Use virtual/override as much as possible**
2. **Hiding only for Third-party Libraries or Backward Compatibility**
3. **Never do Field Hiding** - Use Properties
4. **Documentation**: Always explain why you used Hiding
5. **Testing**: Test Hidden Members

### ‚ö†Ô∏è Trade-offs:

- **Hiding**: Compile-time (faster), but no Polymorphism
- **Override**: Runtime (slightly slower), but has Polymorphism

### üí° Recommendation:

**99% of the time use virtual/override**! Hiding is only needed in special cases.
