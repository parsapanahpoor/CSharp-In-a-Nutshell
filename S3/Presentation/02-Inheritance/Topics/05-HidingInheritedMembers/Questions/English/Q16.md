<div dir="ltr" style="text-align: left;">

## â“ Q16:

## How do Member Resolution and Method Lookup work in Hiding?

### âœ… Deep Answer:

C# compiler has a **complex algorithm** for Member Resolution that is used in Hiding.

### ğŸ” Member Lookup Algorithm:

<div dir="ltr" style="text-align: left;">

```csharp
class Base {
    public void Method() { }
}

class Derived : Base {
    public new void Method() { }
}

Base obj = new Derived();
obj.Method();  // What happens?
```

<div dir="ltr" style="text-align: left;">

### ğŸ“Š Resolution Process:

**Step 1: Type Resolution**
- Compiler sees reference type: `Base`
- Goes to Base Class

**Step 2: Member Lookup**
- Searches for `Method()` in Base Class
- Finds: `Base.Method()`

**Step 3: Hiding Check**
- Checks if Derived has a member with same name
- Yes it does, but since reference is `Base`, `Base.Method()` is used

**Result**: `Base.Method()` is called âœ…

<div dir="ltr" style="text-align: left;">

```csharp
// But:
Derived obj2 = new Derived();
obj2.Method();  // Derived.Method() is called âœ…
```

<div dir="ltr" style="text-align: left;">

### ğŸ”¬ Difference with Override:

<div dir="ltr" style="text-align: left;">

```csharp
// With Override (Runtime Resolution):
class Base {
    public virtual void Method() { }
}

class Derived : Base {
    public override void Method() { }
}

Base obj = new Derived();
obj.Method();  // Runtime checks actual type: Derived
               // So calls Derived.Method() âœ…
```

<div dir="ltr" style="text-align: left;">

### ğŸ¯ Advanced Note:

**Hiding** = Compile-time Member Lookup (based on reference type)
**Override** = Runtime Method Dispatch (based on actual type)

### âš™ï¸ Performance:

- **Hiding**: ~0 overhead (Compile-time resolution)
- **Override**: ~2-3 CPU cycles (Runtime VMT lookup)
