
Definite Assignment
 C# enforces a definite assignment policy. In practice, this means that outside of
 an unsafe or interop context, you can’t accidentally access uninitialized memory.
 Definite assignment has three implications:
 •
 • Local variables must be assigned a value before they can be read.
 •
 • Function arguments must be supplied when a method is called (unless marked
 as optional; see “Optional parameters” on page 74).
 •
 • All other variables (such as fields and array elements) are automatically initial
ized by the runtime.
 For example, the following code results in a compile-time error:
 int x;
 Console.WriteLine (x);        // Compile-time error
 Fields and array elements are automatically initialized with the default values for
 their type. The following code outputs 0 because array elements are implicitly
 assigned to their default values

 int[] ints = new int[2];
 Console.WriteLine (ints[0]);    // 0
 The following code outputs 0, because fields are implicitly assigned a default value
 (whether instance or static):
 Console.WriteLine (Test.X);   // 0
 class Test { public static int X; }   // field

  Default Values
 All type instances have a default value. The default value for the predefined types is
 the result of a bitwise zeroing of memory:
 Type
 Default value
 Reference types (and nullable value types) null
 Numeric and enum types
 0
 char type
 bool type
 '\0'
 false
 You can obtain the default value for any type via the default keyword:
 Console.WriteLine (default (decimal));   // 0
 You can optionally omit the type when it can be inferred:
 decimal d = default;
 The default value in a custom value type (i.e., struct) is the same as the default
 value for each field defined by the custom type.

 Parameters
 A method may have a sequence of parameters. Parameters define the set of argu
ments that must be provided for that method. In the following example, the method
 Foo has a single parameter named p, of type int:
 Foo (8);                        // 8 is an argument
 static void Foo (int p) {...}   // p is a parameter
 You can control how parameters are passed with the ref, in, and out modifiers:
 Parameter modifier Passed by
 Variable must be definitely assigned
 (None)
 ref
 in
 out
 Value
 Reference
 Going in
 Going in
 Reference (read-only) Going in
 Reference
 Going out



## انتساب قطعی (Definite Assignment)

سی‌شارپ یک سیاست انتساب قطعی را اعمال می‌کند. در عمل، این بدان معنی است که در خارج از یک زمینه unsafe یا interop، نمی‌توانید به طور تصادفی به حافظه مقداردهی اولیه نشده دسترسی پیدا کنید.

انتساب قطعی سه مفهوم دارد:

- **متغیرهای محلی** باید قبل از خواندن، یک مقدار به آن‌ها اختصاص داده شود.
- **آرگومان‌های تابع** باید هنگام فراخوانی یک متد ارائه شوند (مگر اینکه به عنوان اختیاری علامت‌گذاری شده باشند).
- **سایر متغیرها** (مانند فیلدها و عناصر آرایه) به طور خودکار توسط runtime مقداردهی اولیه می‌شوند.

برای مثال، کد زیر منجر به خطای زمان کامپایل می‌شود:
```csharp
int x;
Console.WriteLine (x);        // خطای زمان کامپایل
```
فیلدها و عناصر آرایه به طور خودکار با مقادیر پیش‌فرض برای نوع خود مقداردهی اولیه می‌شوند. کد زیر عدد $0$ را چاپ می‌کند زیرا عناصر آرایه به طور ضمنی به مقادیر پیش‌فرض خود اختصاص داده می‌شوند:

```csharp
int[] ints = new int[2];
Console.WriteLine (ints[0]);    // 0
```
کد زیر عدد $0$ را چاپ می‌کند، زیرا فیلدها به طور ضمنی یک مقدار پیش‌فرض اختصاص داده می‌شوند (چه instance باشند چه static):

```csharp
Console.WriteLine (Test.X);   // 0
class Test { public static int X; }   // field
```
## مقادیر پیش‌فرض (Default Values)

تمام نمونه‌های type دارای یک مقدار پیش‌فرض هستند. مقدار پیش‌فرض برای انواع از پیش تعریف شده، نتیجه صفر کردن بیتی حافظه است:

| نوع | مقدار پیش‌فرض |
|-----|---------------|
| Reference types (و nullable value types) | `null` |
| Numeric و enum types | $0$ |
| char type | `'\0'` |
| bool type | `false` |

می‌توانید مقدار پیش‌فرض برای هر نوعی را از طریق کلمه کلیدی `default` به دست آورید:

```csharp
Console.WriteLine (default (decimal));   // 0
```
می‌توانید به صورت اختیاری نوع را حذف کنید وقتی که قابل استنتاج باشد:

```csharp
decimal d = default;
```
مقدار پیش‌فرض در یک value type سفارشی (یعنی struct) همان مقدار پیش‌فرض برای هر فیلد تعریف شده توسط آن نوع سفارشی است.

## پارامترها (Parameters)

یک متد ممکن است دارای یک دنباله از پارامترها باشد. پارامترها مجموعه‌ای از آرگومان‌هایی را که باید برای آن متد ارائه شوند، تعریف می‌کنند. در مثال زیر، متد `Foo` دارای یک پارامتر به نام `p` از نوع `int` است:

```csharp
Foo (8);                        // 8 یک آرگومان است
static void Foo (int p) {...}   // p یک پارامتر است
```
می‌توانید نحوه انتقال پارامترها را با modifierهای `ref`، `in` و `out` کنترل کنید:

| Parameter modifier | نحوه انتقال | متغیر باید به طور قطعی مقداردهی شود |
|-------------------|-------------|-------------------------------------|
| (هیچ‌کدام) | Value | در ورود (Going in) |
| `ref` | Reference | در ورود (Going in) |
| `in` | Reference (فقط خواندنی) | در ورود (Going in) |
| `out` | Reference | در خروج (Going out) |


**خلاصه نکات مهم:**

222. **انتساب قطعی:** سی‌شارپ سیاست انتساب قطعی را اعمال می‌کند تا از دسترسی تصادفی به حافظه مقداردهی نشده جلوگیری کند.

223. **محدوده انتساب قطعی:** این سیاست در خارج از زمینه unsafe یا interop اعمال می‌شود.

224. **انتساب متغیرهای محلی:** متغیرهای محلی باید قبل از خواندن مقداردهی شوند.

225. **الزام آرگومان‌ها:** آرگومان‌های تابع باید هنگام فراخوانی متد ارائه شوند (مگر به عنوان optional علامت‌گذاری شده باشند).

226. **مقداردهی خودکار:** فیلدها و عناصر آرایه به طور خودکار توسط runtime مقداردهی اولیه می‌شوند.

227. **خطای عدم مقداردهی:** خواندن متغیر محلی قبل از مقداردهی منجر به خطای زمان کامپایل می‌شود.

228. **مقادیر پیش‌فرض فیلدها:** فیلدها (چه instance چه static) و عناصر آرایه با مقادیر پیش‌فرض مقداردهی می‌شوند.

229. **صفر کردن بیتی:** مقدار پیش‌فرض انواع از پیش تعریف شده نتیجه صفر کردن بیتی حافظه است.

230. **پیش‌فرض reference types:** مقدار پیش‌فرض برای reference types و nullable value types برابر `null` است.

231. **پیش‌فرض numeric types:** مقدار پیش‌فرض برای numeric و enum types برابر $0$ است.

232. **پیش‌فرض char:** مقدار پیش‌فرض برای `char` برابر `'\0'` است.

233. **پیش‌فرض bool:** مقدار پیش‌فرض برای `bool` برابر `false` است.

234. **کلمه کلیدی default:** از `default` برای دریافت مقدار پیش‌فرض هر نوعی استفاده می‌شود.

235. **حذف نوع در default:** می‌توان نوع را در `default` حذف کرد اگر قابل استنتاج باشد.

236. **پیش‌فرض struct:** مقدار پیش‌فرض struct برابر مقدار پیش‌فرض تمام فیلدهای آن است.

237. **تعریف پارامتر:** پارامترها مجموعه آرگومان‌های مورد نیاز برای فراخوانی متد را تعریف می‌کنند.

238. **تفاوت پارامتر و آرگومان:** پارامتر در تعریف متد و آرگومان در فراخوانی متد استفاده می‌شود.

239. ترجمه=> **Modifierهای پارامتر:** `ref`، `in` و `out` نحوه انتقال پارامترها را کنترل می‌کنند.

240. **پیش‌فرض: انتقال by value:** بدون modifier، پارامترها by value منتقل می‌شوند.

241. ترجمه=> **ref: انتقال by reference:** `ref` پارامتر را by reference منتقل می‌کند و متغیر باید در ورود مقداردهی شده باشد.

242. ترجمه=> **in: reference فقط خواندنی:** `in` پارامتر را by reference فقط خواندنی منتقل می‌کند و متغیر باید در ورود مقداردهی شده باشد.

243. ترجمه=> **out: خروجی reference:** `out` پارامتر را by reference منتقل می‌کند و متغیر باید در خروج (نه ورود) مقداردهی شده باشد.

 
