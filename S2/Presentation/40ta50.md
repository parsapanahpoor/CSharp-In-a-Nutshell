# مقایسه Top-Level Statements vs متد Main
روش مدرن: Top-Level Statements (C# 9+)

```csharp
using System;

// مستقیماً شروع می‌کنیم - بدون class و Main
int x = 12 * 30;
Console.WriteLine(x);  // 360
```
ویژگی‌ها:
 کد کوتاه‌تر و ساده‌تر
 مناسب برای برنامه‌های کوچک و اسکریپت‌ها
 کامپایلر به صورت خودکار Main می‌سازد
روش سنتی: متد Main



------------------------------------------------------------

چرا متد Main استاتیک است ؟ 
توضیح:

دات نت CLR قبل از ایجاد هر شی، باید entry point را پیدا کند
متد static بدون نیاز به شی قابل فراخوانی است
پس Main باید static باش

---------------------------------------------------------

## قوانین تعریف Main
قانون 1: محل تعریف
// ✅ می‌تواند در هر class باش

قانون 2: فقط یک Main

// ❌ خطا: دو entry point



## امضاهای مختلف Main
امضا 1: بدون پارامتر، بدون بازگشت
استفاده: برنامه‌های ساده که به command-line arguments نیاز ندارند.

امضا 2: با پارامتر args
استفاده: دریافت ورودی از command line

استفاده: برگرداندن Exit Code به سیستم‌عامل

قرارداد:

0 = موفقیت
غیر 0 = خطا (معمولاً 1, 2, …)
امضا 4: کامل (با پارامتر و Return)

امضا 3: با Return Type (int)


نکته: کامپایلر در پشت‌صحنه Top-Level Statements را به یک متد Main تبدیل می‌کند.

نکات مهم : 
استفاده از static اجباری است

نام باید Main باشد (حساس به حروف بزرگ/کوچک)

فقط یک Main مجاز است

4.استفاده از async Main نیز مجاز است (C# 7.1+)


-----------------------------------------------------------------------------------------



## 📌 مفهوم Conversion


### ✨ نکته کلیدی
> یک conversion همیشه یک **مقدار جدید** ایجاد می‌کند، نه تغییر مقدار موجود!

### 1️⃣ Implicit Conversion (تبدیل ضمنی)
**تعریف:** خودکار و بدون نیاز به دخالت برنامه‌نویس

#### 📋 شرایط (هر دو باید برقرار باشند):
✅ کامپایلر تضمین کند همیشه موفق است  
✅ هیچ اطلاعاتی از دست نمی‌رود


### 2️⃣ Explicit Conversion (تبدیل صریح)
**تعریف:** نیاز به **Cast** دارد: `(TargetType)value`

#### 📋 شرایط (یکی کافی است):
⚠️ کامپایلر نمی‌تواند موفقیت را تضمین کند  
⚠️ ممکن است اطلاعات از دست برود






