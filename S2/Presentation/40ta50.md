# مقایسه Top-Level Statements vs متد Main
روش مدرن: Top-Level Statements (C# 9+)

```csharp
using System;

// مستقیماً شروع می‌کنیم - بدون class و Main
int x = 12 * 30;
Console.WriteLine(x);  // 360
```
ویژگی‌ها:
 کد کوتاه‌تر و ساده‌تر
 مناسب برای برنامه‌های کوچک و اسکریپت‌ها
 کامپایلر به صورت خودکار Main می‌سازد
روش سنتی: متد Main



------------------------------------------------------------

چرا متد Main استاتیک است ؟ 
توضیح:

دات نت CLR قبل از ایجاد هر شی، باید entry point را پیدا کند
متد static بدون نیاز به شی قابل فراخوانی است
پس Main باید static باش

---------------------------------------------------------

## قوانین تعریف Main
قانون 1: محل تعریف
// ✅ می‌تواند در هر class باش

قانون 2: فقط یک Main

// ❌ خطا: دو entry point



## امضاهای مختلف Main
امضا 1: بدون پارامتر، بدون بازگشت
استفاده: برنامه‌های ساده که به command-line arguments نیاز ندارند.

امضا 2: با پارامتر args
استفاده: دریافت ورودی از command line

استفاده: برگرداندن Exit Code به سیستم‌عامل

قرارداد:

0 = موفقیت
غیر 0 = خطا (معمولاً 1, 2, …)
امضا 4: کامل (با پارامتر و Return)

امضا 3: با Return Type (int)


نکته: کامپایلر در پشت‌صحنه Top-Level Statements را به یک متد Main تبدیل می‌کند.

نکات مهم : 
استفاده از static اجباری است

نام باید Main باشد (حساس به حروف بزرگ/کوچک)

فقط یک Main مجاز است

4.استفاده از async Main نیز مجاز است (C# 7.1+)


-----------------------------------------------------------------------------------------



## 📌 مفهوم Conversion


### ✨ نکته کلیدی
> یک conversion همیشه یک **مقدار جدید** ایجاد می‌کند، نه تغییر مقدار موجود!

### 1️⃣ Implicit Conversion (تبدیل ضمنی)
**تعریف:** خودکار و بدون نیاز به دخالت برنامه‌نویس

#### 📋 شرایط (هر دو باید برقرار باشند):
✅ کامپایلر تضمین کند همیشه موفق است  
✅ هیچ اطلاعاتی از دست نمی‌رود


### 2️⃣ Explicit Conversion (تبدیل صریح)
**تعریف:** نیاز به **Cast** دارد: `(TargetType)value`

#### 📋 شرایط (یکی کافی است):
⚠️ کامپایلر نمی‌تواند موفقیت را تضمین کند  
⚠️ ممکن است اطلاعات از دست برود

##  طبقه‌بندی کلی Types در C#

تمام typeهای C# به **4 دسته** تقسیم می‌شوند:
```csharp
// 1. Value Types
int x = 5;
struct Point { }

// 2. Reference Types
string s = "Hello";
class MyClass { }

// 3. Generic Type Parameters
T GenericMethod<T>() { }

// 4. Pointer Types (unsafe context)
unsafe { int* ptr; }
```

##  Value Types (انواع مقداری)

### تعریف اساسی
> **محتوای** یک متغیر value type، **خود مقدار** است، نه مرجع به آن.

###  ذخیره‌سازی در حافظه

```csharp
int x = 32;  // مستقیماً 32 بیت داده در حافظه ذخیره می‌شود
```
**نکته حیاتی:**
- متغیر **خود داده** را نگه می‌دارد
- **نه** آدرس داده را (برخلاف Reference Types)



##  تعریف Custom Value Type با `struct`

### سینتکس کامل:
```csharp
public struct Point 
{ 
public int X; 
public int Y; 
}
```
### سینتکس فشرده (Terse):
```csharp
public struct Point 
{ 
public int X, Y;  // تعریف همزمان چند field
}
```
**⚠️ توجه:**
- هر دو سینتکس معادل هستند
- سینتکس فشرده فقط برای **fieldهای هم‌نوع** کار می‌کند


##  رفتار Copy در Value Types

### قانون طلایی:
> معنی = **Assignment** یک value type همیشه **کپی** ایجاد می‌کند، نه مرجع مشترک!

### مثال کامل:
```csharp
Point p1 = new Point();  // ایجاد نمونه اول
p1.X = 7;                // تنظیم مقدار

Point p2 = p1;           // ✅ کپی کامل محتوا (نه مرجع)

Console.WriteLine(p1.X); // خروجی: 7
Console.WriteLine(p2.X); // خروجی: 7

p2.X = 10;               // تغییر p2

Console.WriteLine(p1.X); // خروجی: 7  (تغییر نکرده!)
Console.WriteLine(p2.X); // خروجی: 10

```

##  تحلیل عمیق Copy Semantics

### مکانیزم حافظه:


قبل از Assignment:
```csharp
┌─────────┐
│ p1      │
│ X: 7    │
│ Y: 0    │
└─────────┘
```

بعد از p2 = p1:
```csharp
┌─────────┐       ┌─────────┐
│ p1      │       │ p2      │
│ X: 7    │  ═══> │ X: 7    │  (کپی مستقل)
│ Y: 0    │       │ Y: 0    │
└─────────┘       └─────────┘
↑                 ↑
```
 آدرس A           آدرس B (متفاوت!)

**نکات کلیدی:**
1. متغیر های `p1` و `p2` در **آدرس‌های مختلف** حافظه هستند
2. تغییر یکی بر دیگری تأثیر ندارد
3. هر کدام **مالک مستقل** داده‌های خود هستند

##  استفاده از `new` با Value Types

### مثال صفحه:
```csharp
Point p1 = new Point();
```
### ⚠️ نکته پیشرفته:
**کلمه ی  `new` برای value types اختیاری است!**

```csharp
Point p1 = new Point();
// روش 1: با new (صریح)
  // همه fieldها = 0

Point p2;
p2.X = 5;
p2.Y = 10;
// روش 2: بدون new

```
// ⚠️ باید قبل از استفاده، همه fieldها مقداردهی شوند

**تفاوت:**
- **با `new`**: تمام fieldها خودکار صفر می‌شوند
- **بدون `new`**: باید **دستی** همه fieldها را مقداردهی کنید (وگرنه خطای کامپایل)

##  Built-in Value Types

### دسته‌بندی کامل:

#### 1️⃣ Numeric Types
```csharp
// Integral
sbyte, byte          // 8-bit
short, ushort        // 16-bit
int, uint            // 32-bit ✅ (مثال صفحه)
long, ulong          // 64-bit

// Floating-point
float                // 32-bit
double               // 64-bit
decimal              // 128-bit (مالی)
```
#### 2️⃣ Boolean
```csharp
bool flag = true;    // 1 بیت (عملاً 1 بایت)
```
#### 3️⃣ Character
```csharp
char c = 'A';        // 16-bit Unicode
```
#### 4️⃣ Structs
```csharp
DateTime             // تاریخ/زمان
TimeSpan             // بازه زمانی
Guid                 // شناسه یکتا
Nullable<T>          // Nullable value types
```
// ... و بسیاری دیگر

#### 5️⃣ Enums
csharp
enum Color { Red, Green, Blue }

#### 6️⃣ Tuples (C# 7+)
```csharp
(int, string) tuple = (1, "test");
```
---

##  مقایسه مقدماتی با Reference Types

| ویژگی | Value Type | Reference Type |
|-------|-----------|----------------|
| **ذخیره‌سازی** | خود داده | آدرس داده |
| **تعریف** | `struct` | `class` |
| **Copy** | کپی کامل | کپی مرجع |
| **`null`** | ❌ (الا Nullable) | ✅ |
| **Performance** | سریع‌تر (Stack) | کمی کندتر (Heap) |
| **مثال Built-in** | `int` | `string` |



##  مثال مقایسه‌ای

### Value Type (Copy):
```csharp
int a = 5;
int b = a;   // کپی مقدار
b = 10;
Console.WriteLine(a);  // 5 (تغییر نکرده)
```
### Reference Type (مثال پیش‌نگر):
```csharp
var arr1 = new int[] { 5 };
var arr2 = arr1;  // کپی مرجع (نه محتوا)
arr2[0] = 10;
Console.WriteLine(arr1[0]);  // 10 (تغییر کرده!)
```

##  Performance Implications

### Stack vs Heap (مقدماتی):

**Value Types:**
```csharp
void Method() 
{
int x = 5;      // ✅ Stack allocation (سریع)
Point p;        // ✅ Stack allocation
}
// خودکار پاک می‌شود (scope exit)
```
**نکات:**
- **Allocation**: فوق‌العاده سریع (فقط تغییر Stack Pointer)
- **Deallocation**: خودکار و سریع
- **Garbage Collection**: نیاز ندارد

---

##  محدودیت‌های Value Types

### 1. نمی‌توانند `null` باشند (پیش‌فرض):
```csharp
int x = null;  // ❌ خطای کامپایل
```
**راه حل:** Nullable Value Types (موضوع آینده)
```csharp
int? x = null;  // ✅ Nullable<int>
```
### 2. نمی‌توانند از کلاس ارث ببرند:
```csharp
struct Point : MyClass { }  // ❌ غیرمجاز
```
**اما:**
```csharp
struct Point : IComparable { }  // ✅ Interface مجاز است
```
### 3. نمی‌توانند Abstract/Virtual باشند:
```csharp
abstract struct Point { }  // ❌ غیرمجاز
```


# Reference Types 

##  ساختار Reference Types

### تعریف اساسی:
> یک **Reference Type** دو بخش دارد:
> 1. آبجکت - **Object** (شیء واقعی در Heap)
> 2. رفرتس - **Reference** (مرجع/اشاره‌گر به آن شیء)

###  مفهوم کلیدی:
**محتوای** یک متغیر reference type، **آدرس object** است، نه خود داده!


##  ساختار حافظه Reference Type

### Figure 2-3: نمایش در حافظه

```csharp

Stack (متغیر)              Heap (Object واقعی)
┌──────────────┐           ┌──────────────┐
│ Point p1     │           │   Object     │
│              │  ───────> │   X: 7       │
│ Reference    │           │   Y: 0       │
│ (Address)    │           │              │
└──────────────┘           └──────────────┘
   0x1000                     0x2A4F8C
```
**نکات:**
1. متغیر `p1` روی **Stack** ذخیره می‌شود (فقط آدرس)
2. شی Object واقعی روی **Heap** قرار دارد
3. مقدار `p1` = آدرس object (مثلاً `0x2A4F8C`)
4. دسترسی به `X` و `Y` از طریق این آدرس انجام می‌شود

##  Copy Semantics در Reference Types

### قانون طلایی:
> نکته : **Assignment** یک reference type، **فقط reference** را کپی می‌کند، نه object!

### مثال کامل:
```csharp
Point p1 = new Point();
p1.X = 7;

Point p2 = p1;  // ⚠️ کپی reference (نه object)

Console.WriteLine(p1.X);  // 7
Console.WriteLine(p2.X);  // 7

p2.X = 9;  // تغییر از طریق p2

Console.WriteLine(p1.X);  // 9 (تغییر کرده!)
Console.WriteLine(p2.X);  // 9

**نتیجه:** تغییر از طریق `p2` روی **همان object** اثر می‌گذارد که `p1` هم به آن اشاره دارد.
##  ایجاد کپی مستقل (Clone)

### مشکل:
```csharp
Point p1 = new Point { X = 5, Y = 10 };
Point p2 = p1;  // reference مشترک
p2.X = 99;
Console.WriteLine(p1.X);  // 99 (ناخواسته تغییر کرد!)
```
### راه حل 1: کپی دستی
```csharp
Point p1 = new Point { X = 5, Y = 10 };
Point p2 = new Point { X = p1.X, Y = p1.Y };  // ✅ کپی واقعی
p2.X = 99;
Console.WriteLine(p1.X);  // 5 (تغییر نکرده)
```
### راه حل 2: Clone Method
```csharp
public class Point
{
public int X, Y;

public Point Clone()
{
return new Point { X = this.X, Y = this.Y };
}
}

Point p1 = new Point { X = 5, Y = 10 };
Point p2 = p1.Clone();  // ✅ object جدید
p2.X = 99;
Console.WriteLine(p1.X);  // 5



##  Built-in Reference Types

### دسته‌بندی:

#### 1️⃣ String (ویژه):
```csharp
string s1 = "Hello";
string s2 = s1;  // reference type اما...
s2 = "World";
Console.WriteLine(s1);  // "Hello" (تغییر نکرد!)
```
** استثنا:** `string` **immutable** است (رفتار شبیه value type)!

#### 2️⃣ Arrays:
```csharp
int[] arr1 = { 1, 2, 3 };
int[] arr2 = arr1;  // reference مشترک
arr2[0] = 999;
Console.WriteLine(arr1[0]);  // 999
```
#### 3️⃣ Classes:
```csharp
class MyClass { public int Value; }

MyClass obj1 = new MyClass { Value = 10 };
MyClass obj2 = obj1;  // reference
```
#### 4️⃣ Delegates:
```csharp
delegate void MyDelegate();
```
#### 5️⃣ Interfaces (خودشان reference نیستند، اما type را محدود می‌کنند):
```csharp
interface IMyInterface { }
```
#### 6️⃣ Object (پایه همه):
```csharp
object obj = new Point();  // هر چیزی می‌تواند object باشد
```
---

##  عملگر `new` در Reference Types

### الزامی است!
```csharp
Point p1;  // ❌ فقط اعلام (هنوز null است)
p1.X = 5;  // 💥 NullReferenceException

Point p2 = new Point();  // ✅ ایجاد object
p2.X = 5;  // ✅ کار می‌کند
```
### بدون `new`:
```csharp
Point p = null;  // ✅ مجاز (اما خطرناک)
Console.WriteLine(p.X);  // 💥 NullReferenceException
```

##  تفاوت‌های ظریف

### `new` در Value Type vs Reference Type:

#### Value Type:
```csharp
struct PointStruct { public int X; }

PointStruct p1;      // اعلام (uninitialized)
PointStruct p2 = new PointStruct();  // همه fieldها = 0

// p1 و p2 هر دو روی Stack هستند


> یک **reference** می‌تواند مقدار literal `null` بگیرد که نشان می‌دهد **به هیچ object‌ای اشاره نمی‌کند**.

#### مثال:
```csharp
class Point { /* ... */ }

Point p = null;  // ✅ قانونی
Console.WriteLine(p == null);  // True
```

### قانون پایه:
> یک **value type** به طور معمول **نمی‌تواند** مقدار `null` داشته باشد.

### مثال‌های خطا:
```csharp
struct Point { /* ... */ }

Point p = null;  // ❌ Compile-time error
int x = null;    // ❌ Compile-time error
```

### ✅ راه حل: Nullable Value Types

> **صفحه 210:** C# سازوکاری به نام **Nullable Value Types** دارد برای نمایش `null` در value types.

#### Syntax:
```csharp
int? x = null;     // ✅ کار می‌کند
Point? p = null;   // ✅ کار می‌کند

Console.WriteLine(x == null);  // True
Console.WriteLine(p == null);  // True
```
#### معادل کامل:
```csharp
Nullable<int> x = null;
Nullable<Point> p = null;
```
**نکته:** `?` یک shorthand برای `Nullable<T>` است.


###  مثال‌های بیشتر Alignment

#### مثال 1: Optimal Order
```csharp
struct Optimized 
{ 
long a;   // 8 bytes (offset 0)
int b;    // 4 bytes (offset 8)
short c;  // 2 bytes (offset 12)
byte d;   // 1 byte  (offset 14)
byte e;   // 1 byte  (offset 15)
}

// Total: 16 bytes (no waste!)
```

#### مثال 2: Bad Order
```csharp
struct BadOrder 
{ 
byte a;   // 1 byte  (offset 0)
long b;   // 8 bytes (offset 8) → 7 bytes padding!
byte c;   // 1 byte  (offset 16)
}

// Total: 24 bytes (11 bytes wasted!)
```
**درس:** **ترتیب فیلدها مهم است!**

**قانون:** **بزرگ‌ترین فیلدها را اول** بگذارید.

##  خلاصه نکات کلیدی

### نکته » Null:
1. ✅ نکته » Reference types **می‌توانند** `null` باشند
2. ✅ نکته » Value types **نمی‌توانند** `null` باشند (الا با `?`)
3. ✅ نکته » `NullReferenceException` = خطای Runtime
4. ✅ نکته » **NRTs** (صفحه 215) کمک می‌کند
5. ✅ نکته » `Nullable<T>` (صفحه 210) برای value types

### نکته » Storage:
1. ✅ نکته » Value type = **فقط فیلدها** (+ padding)
2. ✅ نکته » Reference type = **فیلدها + header + pointer**
3. ✅ نکته » **Alignment:** فیلدها در مضرب اندازه خودشان (≤8)
4. ✅ نکته » **Padding** ممکن است فضا را افزایش دهد
5. ✅ **ترتیب فیلدها** مهم است!
6. ✅ نکته » **Object header** حداقل 8 بایت
7. ✅ نکته » **Reference** = 4 (32-bit) یا 8 (64-bit) بایت
8.  نکته » `StructLayout` برای override (صفحه 997)




##  ارتباط با .NET Framework

### قانون Aliasing:
> **تمام** انواع از پیش تعریف شده در C# فقط **alias** (نام مستعار) برای typeهای .NET در namespace `System` هستند.

### مثال معادل‌سازی:

```csharp
// این دو خط کاملاً یکسان هستند:
int i = 5;
System.Int32 i = 5;

// تفاوت فقط سینتکسی است، نه معنایی!



##  جدول کامل Aliases
```csharp
| C# Keyword | .NET Type | دسته |
|------------|-----------|------|
| `sbyte` | `System.SByte` | Signed Integer |
| `byte` | `System.Byte` | Unsigned Integer |
| `short` | `System.Int16` | Signed Integer |
| `ushort` | `System.UInt16` | Unsigned Integer |
| `int` | `System.Int32` | Signed Integer |
| `uint` | `System.UInt32` | Unsigned Integer |
| `long` | `System.Int64` | Signed Integer |
| `ulong` | `System.UInt64` | Unsigned Integer |
| `float` | `System.Single` | Real Number |
| `double` | `System.Double` | Real Number |
| `decimal` | `System.Decimal` | Real Number |
| `bool` | `System.Boolean` | Logical |
| `char` | `System.Char` | Character |
| `string` | `System.String` | Reference |
| `object` | `System.Object` | Reference |
```
---


##  Primitive Types در CLR

### تعریف:
> تایپ های  **Primitive types** شامل همه value types از پیش تعریف شده **به جز `decimal`** هستند.

### لیست Primitive Types:
```csharp
// ✅ Primitive:
sbyte, byte, short, ushort, int, uint, long, ulong
float, double
bool
char

// ❌ NOT Primitive:
decimal
```


### 🔍 چرا Primitive؟

> **دلیل:** این typeها **مستقیماً** توسط دستورالعمل‌های (instructions) کد کامپایل شده پشتیبانی می‌شوند.

#### معنی:
1. **کامپایلر** کد بهینه تولید می‌کند
2. **پردازنده** معمولاً پشتیبانی سخت‌افزاری دارد
3. **عملیات** بسیار سریع هستند

##  طبقه‌بندی نهایی

```csharp
C# Predefined Types
│
├── Value Types
│   ├── Numeric
│   │   ├── Signed Integer (sbyte, short, int, long) ✅ Primitive
│   │   ├── Unsigned Integer (byte, ushort, uint, ulong) ✅ Primitive
│   │   └── Real Number (float, double, decimal)
│   │       ├── float ✅ Primitive
│   │       ├── double ✅ Primitive
│   │       └── decimal ❌ NOT Primitive
│   ├── Logical (bool) ✅ Primitive
│   └── Character (char) ✅ Primitive
│
└── Reference Types
├── string (System.String) ❌ NOT Primitive
└── object (System.Object) ❌ NOT Primitive
```

##  First-Class Citizens: `int` و `long`

### چرا `int` و `long` ترجیح داده می‌شوند؟

> از میان انواع Integral، **`int` و `long`** شهروندان درجه یک (first-class citizens) هستند و هم توسط **C#** و هم توسط **runtime** مورد علاقه قرار می‌گیرند.

#### دلایل:
1. **پشتیبانی مستقیم پردازنده:** بیشتر CPUها برای 32-bit (`int`) و 64-bit (`long`) بهینه شده‌اند
2. **عملیات سریع‌تر:** دستورالعمل‌های native processor
3. **استاندارد در API:** اکثر متدهای .NET از `int` استفاده می‌کنند
4. **Default choice:** برای اکثر محاسبات عددی
```csharp
// ✅ Preferred:
int count = 100;
long population = 7_800_000_000L;

// ⚠️ کمتر استفاده می‌شود (مگر در موارد خاص):
short age = 25;
byte flags = 0xFF;
```

### مقایسه: `double` vs `decimal`

#### ❌ مشکل با `double`:
```csharp
double price = 0.1;
double total = price + price + price;  // 0.1 + 0.1 + 0.1
Console.WriteLine(total);  // 0.30000000000000004 ⚠️ خطا!

// در محاسبات مالی فاجعه است:
double money = 0.1 + 0.2;
if (money == 0.3)  // ❌ False!
Console.WriteLine("Equal");
```
---

#### ✅ راه حل با `decimal`:
```csharp
decimal price = 0.1m;
decimal total = price + price + price;
Console.WriteLine(total);  // 0.3 ✅ دقیق!

// محاسبات بانکی:
decimal accountBalance = 1234.56m;
decimal interest = accountBalance * 0.05m;  // دقیق
decimal newBalance = accountBalance + interest;
```




