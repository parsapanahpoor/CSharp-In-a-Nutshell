# مقایسه Top-Level Statements vs متد Main
روش مدرن: Top-Level Statements (C# 9+)

```csharp
using System;

// مستقیماً شروع می‌کنیم - بدون class و Main
int x = 12 * 30;
Console.WriteLine(x);  // 360
```
ویژگی‌ها:
 کد کوتاه‌تر و ساده‌تر
 مناسب برای برنامه‌های کوچک و اسکریپت‌ها
 کامپایلر به صورت خودکار Main می‌سازد
روش سنتی: متد Main



------------------------------------------------------------

چرا متد Main استاتیک است ؟ 
توضیح:

دات نت CLR قبل از ایجاد هر شی، باید entry point را پیدا کند
متد static بدون نیاز به شی قابل فراخوانی است
پس Main باید static باش

---------------------------------------------------------

## قوانین تعریف Main
قانون 1: محل تعریف
// ✅ می‌تواند در هر class باش

قانون 2: فقط یک Main

// ❌ خطا: دو entry point



## امضاهای مختلف Main
امضا 1: بدون پارامتر، بدون بازگشت
استفاده: برنامه‌های ساده که به command-line arguments نیاز ندارند.

امضا 2: با پارامتر args
استفاده: دریافت ورودی از command line

استفاده: برگرداندن Exit Code به سیستم‌عامل

قرارداد:

0 = موفقیت
غیر 0 = خطا (معمولاً 1, 2, …)
امضا 4: کامل (با پارامتر و Return)

امضا 3: با Return Type (int)


نکته: کامپایلر در پشت‌صحنه Top-Level Statements را به یک متد Main تبدیل می‌کند.

نکات مهم : 
استفاده از static اجباری است

نام باید Main باشد (حساس به حروف بزرگ/کوچک)

فقط یک Main مجاز است

4.استفاده از async Main نیز مجاز است (C# 7.1+)


-----------------------------------------------------------------------------------------



## 📌 مفهوم Conversion


### ✨ نکته کلیدی
> یک conversion همیشه یک **مقدار جدید** ایجاد می‌کند، نه تغییر مقدار موجود!

### 1️⃣ Implicit Conversion (تبدیل ضمنی)
**تعریف:** خودکار و بدون نیاز به دخالت برنامه‌نویس

#### 📋 شرایط (هر دو باید برقرار باشند):
✅ کامپایلر تضمین کند همیشه موفق است  
✅ هیچ اطلاعاتی از دست نمی‌رود


### 2️⃣ Explicit Conversion (تبدیل صریح)
**تعریف:** نیاز به **Cast** دارد: `(TargetType)value`

#### 📋 شرایط (یکی کافی است):
⚠️ کامپایلر نمی‌تواند موفقیت را تضمین کند  
⚠️ ممکن است اطلاعات از دست برود

##  طبقه‌بندی کلی Types در C#

تمام typeهای C# به **4 دسته** تقسیم می‌شوند:
```csharp
// 1. Value Types
int x = 5;
struct Point { }

// 2. Reference Types
string s = "Hello";
class MyClass { }

// 3. Generic Type Parameters
T GenericMethod<T>() { }

// 4. Pointer Types (unsafe context)
unsafe { int* ptr; }
```

##  Value Types (انواع مقداری)

### تعریف اساسی
> **محتوای** یک متغیر value type، **خود مقدار** است، نه مرجع به آن.

###  ذخیره‌سازی در حافظه

```csharp
int x = 32;  // مستقیماً 32 بیت داده در حافظه ذخیره می‌شود
```
**نکته حیاتی:**
- متغیر **خود داده** را نگه می‌دارد
- **نه** آدرس داده را (برخلاف Reference Types)



##  تعریف Custom Value Type با `struct`

### سینتکس کامل:
```csharp
public struct Point 
{ 
public int X; 
public int Y; 
}
```
### سینتکس فشرده (Terse):
```csharp
public struct Point 
{ 
public int X, Y;  // تعریف همزمان چند field
}
```
**⚠️ توجه:**
- هر دو سینتکس معادل هستند
- سینتکس فشرده فقط برای **fieldهای هم‌نوع** کار می‌کند


##  رفتار Copy در Value Types

### قانون طلایی:
> معنی = **Assignment** یک value type همیشه **کپی** ایجاد می‌کند، نه مرجع مشترک!

### مثال کامل:
```csharp
Point p1 = new Point();  // ایجاد نمونه اول
p1.X = 7;                // تنظیم مقدار

Point p2 = p1;           // ✅ کپی کامل محتوا (نه مرجع)

Console.WriteLine(p1.X); // خروجی: 7
Console.WriteLine(p2.X); // خروجی: 7

p2.X = 10;               // تغییر p2

Console.WriteLine(p1.X); // خروجی: 7  (تغییر نکرده!)
Console.WriteLine(p2.X); // خروجی: 10

```

##  تحلیل عمیق Copy Semantics

### مکانیزم حافظه:


قبل از Assignment:
```csharp
┌─────────┐
│ p1      │
│ X: 7    │
│ Y: 0    │
└─────────┘
```

بعد از p2 = p1:
```csharp
┌─────────┐       ┌─────────┐
│ p1      │       │ p2      │
│ X: 7    │  ═══> │ X: 7    │  (کپی مستقل)
│ Y: 0    │       │ Y: 0    │
└─────────┘       └─────────┘
↑                 ↑
```
 آدرس A           آدرس B (متفاوت!)

**نکات کلیدی:**
1. متغیر های `p1` و `p2` در **آدرس‌های مختلف** حافظه هستند
2. تغییر یکی بر دیگری تأثیر ندارد
3. هر کدام **مالک مستقل** داده‌های خود هستند

##  استفاده از `new` با Value Types

### مثال صفحه:
```csharp
Point p1 = new Point();
```
### ⚠️ نکته پیشرفته:
**کلمه ی  `new` برای value types اختیاری است!**

```csharp
Point p1 = new Point();
// روش 1: با new (صریح)
  // همه fieldها = 0

Point p2;
p2.X = 5;
p2.Y = 10;
// روش 2: بدون new

```
// ⚠️ باید قبل از استفاده، همه fieldها مقداردهی شوند

**تفاوت:**
- **با `new`**: تمام fieldها خودکار صفر می‌شوند
- **بدون `new`**: باید **دستی** همه fieldها را مقداردهی کنید (وگرنه خطای کامپایل)

##  Built-in Value Types

### دسته‌بندی کامل:

#### 1️⃣ Numeric Types
```csharp
// Integral
sbyte, byte          // 8-bit
short, ushort        // 16-bit
int, uint            // 32-bit ✅ (مثال صفحه)
long, ulong          // 64-bit

// Floating-point
float                // 32-bit
double               // 64-bit
decimal              // 128-bit (مالی)
```
#### 2️⃣ Boolean
```csharp
bool flag = true;    // 1 بیت (عملاً 1 بایت)
```
#### 3️⃣ Character
```csharp
char c = 'A';        // 16-bit Unicode
```
#### 4️⃣ Structs
```csharp
DateTime             // تاریخ/زمان
TimeSpan             // بازه زمانی
Guid                 // شناسه یکتا
Nullable<T>          // Nullable value types
```
// ... و بسیاری دیگر

#### 5️⃣ Enums
csharp
enum Color { Red, Green, Blue }

#### 6️⃣ Tuples (C# 7+)
```csharp
(int, string) tuple = (1, "test");
```
---

##  مقایسه مقدماتی با Reference Types

| ویژگی | Value Type | Reference Type |
|-------|-----------|----------------|
| **ذخیره‌سازی** | خود داده | آدرس داده |
| **تعریف** | `struct` | `class` |
| **Copy** | کپی کامل | کپی مرجع |
| **`null`** | ❌ (الا Nullable) | ✅ |
| **Performance** | سریع‌تر (Stack) | کمی کندتر (Heap) |
| **مثال Built-in** | `int` | `string` |



##  مثال مقایسه‌ای

### Value Type (Copy):
```csharp
int a = 5;
int b = a;   // کپی مقدار
b = 10;
Console.WriteLine(a);  // 5 (تغییر نکرده)
```
### Reference Type (مثال پیش‌نگر):
```csharp
var arr1 = new int[] { 5 };
var arr2 = arr1;  // کپی مرجع (نه محتوا)
arr2[0] = 10;
Console.WriteLine(arr1[0]);  // 10 (تغییر کرده!)
```

##  Performance Implications

### Stack vs Heap (مقدماتی):

**Value Types:**
```csharp
void Method() 
{
int x = 5;      // ✅ Stack allocation (سریع)
Point p;        // ✅ Stack allocation
}
// خودکار پاک می‌شود (scope exit)
```
**نکات:**
- **Allocation**: فوق‌العاده سریع (فقط تغییر Stack Pointer)
- **Deallocation**: خودکار و سریع
- **Garbage Collection**: نیاز ندارد

---

##  محدودیت‌های Value Types

### 1. نمی‌توانند `null` باشند (پیش‌فرض):
```csharp
int x = null;  // ❌ خطای کامپایل
```
**راه حل:** Nullable Value Types (موضوع آینده)
```csharp
int? x = null;  // ✅ Nullable<int>
```
### 2. نمی‌توانند از کلاس ارث ببرند:
```csharp
struct Point : MyClass { }  // ❌ غیرمجاز
```
**اما:**
```csharp
struct Point : IComparable { }  // ✅ Interface مجاز است
```
### 3. نمی‌توانند Abstract/Virtual باشند:
```csharp
abstract struct Point { }  // ❌ غیرمجاز
```


# Reference Types 

##  ساختار Reference Types

### تعریف اساسی:
> یک **Reference Type** دو بخش دارد:
> 1. آبجکت - **Object** (شیء واقعی در Heap)
> 2. رفرتس - **Reference** (مرجع/اشاره‌گر به آن شیء)

###  مفهوم کلیدی:
**محتوای** یک متغیر reference type، **آدرس object** است، نه خود داده!


##  ساختار حافظه Reference Type

### Figure 2-3: نمایش در حافظه

```csharp

Stack (متغیر)              Heap (Object واقعی)
┌──────────────┐           ┌──────────────┐
│ Point p1     │           │   Object     │
│              │  ───────> │   X: 7       │
│ Reference    │           │   Y: 0       │
│ (Address)    │           │              │
└──────────────┘           └──────────────┘
   0x1000                     0x2A4F8C
```
**نکات:**
1. متغیر `p1` روی **Stack** ذخیره می‌شود (فقط آدرس)
2. شی Object واقعی روی **Heap** قرار دارد
3. مقدار `p1` = آدرس object (مثلاً `0x2A4F8C`)
4. دسترسی به `X` و `Y` از طریق این آدرس انجام می‌شود

##  Copy Semantics در Reference Types

### قانون طلایی:
> نکته : **Assignment** یک reference type، **فقط reference** را کپی می‌کند، نه object!

### مثال کامل:
```csharp
Point p1 = new Point();
p1.X = 7;

Point p2 = p1;  // ⚠️ کپی reference (نه object)

Console.WriteLine(p1.X);  // 7
Console.WriteLine(p2.X);  // 7

p2.X = 9;  // تغییر از طریق p2

Console.WriteLine(p1.X);  // 9 (تغییر کرده!)
Console.WriteLine(p2.X);  // 9

**نتیجه:** تغییر از طریق `p2` روی **همان object** اثر می‌گذارد که `p1` هم به آن اشاره دارد.
##  ایجاد کپی مستقل (Clone)

### مشکل:
```csharp
Point p1 = new Point { X = 5, Y = 10 };
Point p2 = p1;  // reference مشترک
p2.X = 99;
Console.WriteLine(p1.X);  // 99 (ناخواسته تغییر کرد!)
```
### راه حل 1: کپی دستی
```csharp
Point p1 = new Point { X = 5, Y = 10 };
Point p2 = new Point { X = p1.X, Y = p1.Y };  // ✅ کپی واقعی
p2.X = 99;
Console.WriteLine(p1.X);  // 5 (تغییر نکرده)
```
### راه حل 2: Clone Method
```csharp
public class Point
{
public int X, Y;

public Point Clone()
{
return new Point { X = this.X, Y = this.Y };
}
}

Point p1 = new Point { X = 5, Y = 10 };
Point p2 = p1.Clone();  // ✅ object جدید
p2.X = 99;
Console.WriteLine(p1.X);  // 5



##  Built-in Reference Types

### دسته‌بندی:

#### 1️⃣ String (ویژه):
```csharp
string s1 = "Hello";
string s2 = s1;  // reference type اما...
s2 = "World";
Console.WriteLine(s1);  // "Hello" (تغییر نکرد!)
```
** استثنا:** `string` **immutable** است (رفتار شبیه value type)!

#### 2️⃣ Arrays:
```csharp
int[] arr1 = { 1, 2, 3 };
int[] arr2 = arr1;  // reference مشترک
arr2[0] = 999;
Console.WriteLine(arr1[0]);  // 999
```
#### 3️⃣ Classes:
```csharp
class MyClass { public int Value; }

MyClass obj1 = new MyClass { Value = 10 };
MyClass obj2 = obj1;  // reference
```
#### 4️⃣ Delegates:
```csharp
delegate void MyDelegate();
```
#### 5️⃣ Interfaces (خودشان reference نیستند، اما type را محدود می‌کنند):
```csharp
interface IMyInterface { }
```
#### 6️⃣ Object (پایه همه):
```csharp
object obj = new Point();  // هر چیزی می‌تواند object باشد
```
---

##  عملگر `new` در Reference Types

### الزامی است!
```csharp
Point p1;  // ❌ فقط اعلام (هنوز null است)
p1.X = 5;  // 💥 NullReferenceException

Point p2 = new Point();  // ✅ ایجاد object
p2.X = 5;  // ✅ کار می‌کند
```
### بدون `new`:
```csharp
Point p = null;  // ✅ مجاز (اما خطرناک)
Console.WriteLine(p.X);  // 💥 NullReferenceException
```

##  تفاوت‌های ظریف

### `new` در Value Type vs Reference Type:

#### Value Type:
```csharp
struct PointStruct { public int X; }

PointStruct p1;      // اعلام (uninitialized)
PointStruct p2 = new PointStruct();  // همه fieldها = 0

// p1 و p2 هر دو روی Stack هستند


> یک **reference** می‌تواند مقدار literal `null` بگیرد که نشان می‌دهد **به هیچ object‌ای اشاره نمی‌کند**.

#### مثال:
```csharp
class Point { /* ... */ }

Point p = null;  // ✅ قانونی
Console.WriteLine(p == null);  // True
```

### قانون پایه:
> یک **value type** به طور معمول **نمی‌تواند** مقدار `null` داشته باشد.

### مثال‌های خطا:
```csharp
struct Point { /* ... */ }

Point p = null;  // ❌ Compile-time error
int x = null;    // ❌ Compile-time error
```

### ✅ راه حل: Nullable Value Types

> **صفحه 210:** C# سازوکاری به نام **Nullable Value Types** دارد برای نمایش `null` در value types.

#### Syntax:
```csharp
int? x = null;     // ✅ کار می‌کند
Point? p = null;   // ✅ کار می‌کند

Console.WriteLine(x == null);  // True
Console.WriteLine(p == null);  // True
```
#### معادل کامل:
```csharp
Nullable<int> x = null;
Nullable<Point> p = null;
```
**نکته:** `?` یک shorthand برای `Nullable<T>` است.


###  مثال‌های بیشتر Alignment

#### مثال 1: Optimal Order
```csharp
struct Optimized 
{ 
long a;   // 8 bytes (offset 0)
int b;    // 4 bytes (offset 8)
short c;  // 2 bytes (offset 12)
byte d;   // 1 byte  (offset 14)
byte e;   // 1 byte  (offset 15)
}

// Total: 16 bytes (no waste!)
```

#### مثال 2: Bad Order
```csharp
struct BadOrder 
{ 
byte a;   // 1 byte  (offset 0)
long b;   // 8 bytes (offset 8) → 7 bytes padding!
byte c;   // 1 byte  (offset 16)
}

// Total: 24 bytes (11 bytes wasted!)
```
**درس:** **ترتیب فیلدها مهم است!**

**قانون:** **بزرگ‌ترین فیلدها را اول** بگذارید.

##  خلاصه نکات کلیدی

### نکته » Null:
1. ✅ نکته » Reference types **می‌توانند** `null` باشند
2. ✅ نکته » Value types **نمی‌توانند** `null` باشند (الا با `?`)
3. ✅ نکته » `NullReferenceException` = خطای Runtime
4. ✅ نکته » **NRTs** (صفحه 215) کمک می‌کند
5. ✅ نکته » `Nullable<T>` (صفحه 210) برای value types

### نکته » Storage:
1. ✅ نکته » Value type = **فقط فیلدها** (+ padding)
2. ✅ نکته » Reference type = **فیلدها + header + pointer**
3. ✅ نکته » **Alignment:** فیلدها در مضرب اندازه خودشان (≤8)
4. ✅ نکته » **Padding** ممکن است فضا را افزایش دهد
5. ✅ **ترتیب فیلدها** مهم است!
6. ✅ نکته » **Object header** حداقل 8 بایت
7. ✅ نکته » **Reference** = 4 (32-bit) یا 8 (64-bit) بایت
8.  نکته » `StructLayout` برای override (صفحه 997)




##  ارتباط با .NET Framework

### قانون Aliasing:
> **تمام** انواع از پیش تعریف شده در C# فقط **alias** (نام مستعار) برای typeهای .NET در namespace `System` هستند.

### مثال معادل‌سازی:

```csharp
// این دو خط کاملاً یکسان هستند:
int i = 5;
System.Int32 i = 5;

// تفاوت فقط سینتکسی است، نه معنایی!



##  جدول کامل Aliases
```csharp
| C# Keyword | .NET Type | دسته |
|------------|-----------|------|
| `sbyte` | `System.SByte` | Signed Integer |
| `byte` | `System.Byte` | Unsigned Integer |
| `short` | `System.Int16` | Signed Integer |
| `ushort` | `System.UInt16` | Unsigned Integer |
| `int` | `System.Int32` | Signed Integer |
| `uint` | `System.UInt32` | Unsigned Integer |
| `long` | `System.Int64` | Signed Integer |
| `ulong` | `System.UInt64` | Unsigned Integer |
| `float` | `System.Single` | Real Number |
| `double` | `System.Double` | Real Number |
| `decimal` | `System.Decimal` | Real Number |
| `bool` | `System.Boolean` | Logical |
| `char` | `System.Char` | Character |
| `string` | `System.String` | Reference |
| `object` | `System.Object` | Reference |
```
---


##  Primitive Types در CLR

### تعریف:
> تایپ های  **Primitive types** شامل همه value types از پیش تعریف شده **به جز `decimal`** هستند.

### لیست Primitive Types:
```csharp
// ✅ Primitive:
sbyte, byte, short, ushort, int, uint, long, ulong
float, double
bool
char

// ❌ NOT Primitive:
decimal
```


### 🔍 چرا Primitive؟

> **دلیل:** این typeها **مستقیماً** توسط دستورالعمل‌های (instructions) کد کامپایل شده پشتیبانی می‌شوند.

#### معنی:
1. **کامپایلر** کد بهینه تولید می‌کند
2. **پردازنده** معمولاً پشتیبانی سخت‌افزاری دارد
3. **عملیات** بسیار سریع هستند

##  طبقه‌بندی نهایی

```csharp
C# Predefined Types
│
├── Value Types
│   ├── Numeric
│   │   ├── Signed Integer (sbyte, short, int, long) ✅ Primitive
│   │   ├── Unsigned Integer (byte, ushort, uint, ulong) ✅ Primitive
│   │   └── Real Number (float, double, decimal)
│   │       ├── float ✅ Primitive
│   │       ├── double ✅ Primitive
│   │       └── decimal ❌ NOT Primitive
│   ├── Logical (bool) ✅ Primitive
│   └── Character (char) ✅ Primitive
│
└── Reference Types
├── string (System.String) ❌ NOT Primitive
└── object (System.Object) ❌ NOT Primitive
```

##  First-Class Citizens: `int` و `long`

### چرا `int` و `long` ترجیح داده می‌شوند؟

> از میان انواع Integral، **`int` و `long`** شهروندان درجه یک (first-class citizens) هستند و هم توسط **C#** و هم توسط **runtime** مورد علاقه قرار می‌گیرند.

#### دلایل:
1. **پشتیبانی مستقیم پردازنده:** بیشتر CPUها برای 32-bit (`int`) و 64-bit (`long`) بهینه شده‌اند
2. **عملیات سریع‌تر:** دستورالعمل‌های native processor
3. **استاندارد در API:** اکثر متدهای .NET از `int` استفاده می‌کنند
4. **Default choice:** برای اکثر محاسبات عددی
```csharp
// ✅ Preferred:
int count = 100;
long population = 7_800_000_000L;

// ⚠️ کمتر استفاده می‌شود (مگر در موارد خاص):
short age = 25;
byte flags = 0xFF;
```

### مقایسه: `double` vs `decimal`

#### ❌ مشکل با `double`:
```csharp
double price = 0.1;
double total = price + price + price;  // 0.1 + 0.1 + 0.1
Console.WriteLine(total);  // 0.30000000000000004 ⚠️ خطا!

// در محاسبات مالی فاجعه است:
double money = 0.1 + 0.2;
if (money == 0.3)  // ❌ False!
Console.WriteLine("Equal");
```
---

#### ✅ راه حل با `decimal`:
```csharp
decimal price = 0.1m;
decimal total = price + price + price;
Console.WriteLine(total);  // 0.3 ✅ دقیق!

// محاسبات بانکی:
decimal accountBalance = 1234.56m;
decimal interest = accountBalance * 0.05m;  // دقیق
decimal newBalance = accountBalance + interest;
```



## 🔄 Converting Between Floating-Point Types

### قانون اصلی:

> نکته » **`float` می‌تواند به صورت implicit به `double` تبدیل شود**، اما **عکس آن باید explicit باشد**.

---

### مثال:
```csharp
// ✅ Implicit: float → double
float f = 1.5F;
double d = f;        // همیشه موفقیت‌آمیز

// ⚠️ Explicit: double → float
double d2 = 1.5;
float f2 = (float)d2; // نیاز به cast
```

## 🔢 Increment and Decrement Operators

### تعریف:

> عملگرهای **`++` (increment)** و **`--` (decrement)** مقدار یک متغیر عددی را **1 واحد افزایش یا کاهش می‌دهند**.

---

### دو حالت کاربرد:

| حالت | نام | سینتکس | رفتار |
```csharp
|------|-----|--------|-------|
| **Postfix** | پسوندی | `x++` یا `x--` |
 ابتدا مقدار **قبلی** برگردانده می‌شود، **سپس** افزایش/کاهش رخ می‌دهد |
| **Prefix** | پیشوندی | `++x` یا `--x` |
 ابتدا افزایش/کاهش رخ می‌دهد، **سپس** مقدار **جدید** برگردانده می‌شود |
```
---

### مثال 1: Postfix (`x++`)
```csharp
int x = 0;
Console.WriteLine(x++);  // ⚠️ خروجی: 0 (مقدار قبلی)
Console.WriteLine(x);     // 1 (x بعد از print افزایش یافت)
```
**مراحل اجرا:**
1. مقدار فعلی `x` (که `0` است) برای `Console.WriteLine` ارسال می‌شود
2. دوم `x` به `1` افزایش می‌یابد
3. سوم `Console.WriteLine` عدد `0` را چاپ می‌کند

---

### مثال 2: Prefix (`++x`)

```csharp
int y = 0;
Console.WriteLine(++y);  // ✅ خروجی: 1 (مقدار جدید)
Console.WriteLine(y);     // 1 (y همان 1 باقی می‌ماند)
```
**مراحل اجرا:**
1. ابتدا `y` به `1` افزایش می‌یابد
2. مقدار جدید `y` (که `1` است) برای `Console.WriteLine` ارسال می‌شود
3. سوم : `Console.WriteLine` عدد `1` را چاپ می‌کند



### ⚠️ Division by Zero (Runtime Error)

```csharp
int b = 0;
int c = 5 / b;  // ❌ Runtime Exception: DivideByZeroException
```
**دلیل:**
- تقسیم بر **متغیری** که مقدارش `0` است در **runtime** بررسی می‌شود
- منجر به **`DivideByZeroException`** می‌شود


### ✅ Division by Literal Zero (Compile-Time Error)

```csharp
int d = 5 / 0;  // ❌ Compile-time error: Division by constant zero
```
**دلیل:**
- کامپایلر می‌تواند تقسیم بر **عدد ثابت (literal) `0`** را در **compile-time** تشخیص دهد
- **خطای کامپایل** صادر می‌شود (نه runtime exception)


###  مقایسه Integer Division vs Float Division:

```csharp
// Integer division (truncate)
int a = 5 / 2;
Console.WriteLine(a);      // 2

// Float division (دقیق)
double b = 5.0 / 2.0;
Console.WriteLine(b);      // 2.5

// Mixed (ارتقا به double)
double c = 5 / 2.0;
Console.WriteLine(c);      // 2.5

// Cast برای نتیجه float
double d = (double)5 / 2;
Console.WriteLine(d);      // 2.5

// ⚠️ اشتباه متداول
double e = (double)(5 / 2);  // تقسیم ابتدا انجام می‌شود، سپس cast
Console.WriteLine(e);         // 2.0 (نه 2.5!)
```
---

###  راه حل: دریافت نتیجه اعشاری

```csharp
int numerator = 5;
int denominator = 2;

// روش 1: Cast کردن یکی از operandها
double result1 = (double)numerator / denominator;
Console.WriteLine(result1);  // 2.5 ✅

// روش 2: ضرب در 1.0
double result2 = numerator * 1.0 / denominator;
Console.WriteLine(result2);  // 2.5 ✅

// روش 3: استفاده از decimal
decimal result3 = (decimal)numerator / denominator;
Console.WriteLine(result3);  // 2.5 ✅
```



##  Overflow (سرریز) در Integral Types

### قانون پیش‌فرض:

> **در runtime، عملیات‌های حسابی روی integral types می‌توانند سرریز (overflow) شوند.**  
> **به طور پیش‌فرض، این اتفاق به صورت "خاموش" (silently) می‌افتد**:
> - ❌ هیچ exception پرتاب نمی‌شود
> - ⚠️ رفتار **wraparound** رخ می‌دهد

---

### مثال 1: Wraparound در Decrement

```csharp
int a = int.MinValue;    // -2,147,483,648
a--;                      // کاهش 1 واحد

Console.WriteLine(a);                     // 2147483647 ⚠️
Console.WriteLine(a == int.MaxValue);     // True
```
**توضیح:**

int.MinValue = -2,147,483,648 (32-bit signed)
در Binary:  10000000 00000000 00000000 00000000

کاهش 1 واحد:
01111111 11111111 11111111 11111111
= 2,147,483,647 (int.MaxValue)

---

### مثال 2: Wraparound در Increment

```csharp
int b = int.MaxValue;    // 2,147,483,647
b++;                      // افزایش 1 واحد

Console.WriteLine(b);                     // -2147483648 ⚠️
Console.WriteLine(b == int.MinValue);     // True
```
---

### مثال 3: Overflow در ضرب

```csharp
int x = 1000000;
int y = 1000000;
int z = x * y;

Console.WriteLine(z);  // -727379968 ⚠️ (نه 1,000,000,000,000)
```

**دلیل:**
- $1,000,000 \times 1,000,000 = 1,000,000,000,000$
- این عدد از محدوده `int` ($\approx 2.1$ میلیارد) خارج است
- بیت‌های اضافی **دور انداخته می‌شوند** و نتیجه **wraparound** می‌شود

---

### 🔬 تحلیل Wraparound:


محدوده int: -2,147,483,648 تا 2,147,483,647

فرض کنید عملیات روی یک "ساعت دایره‌ای" انجام می‌شود:

int.MaxValue (2,147,483,647)
↓ +1
int.MinValue (-2,147,483,648)

int.MinValue (-2,147,483,648)
↓ -1
int.MaxValue (2,147,483,647)


## 1. عملگر Checked برای بررسی سرریز (Overflow)

### نکات کلیدی برای ارائه:

**استفاده از checked در سطح Expression:**
```csharp
int a = 1000000;
int b = 1000000;
int c = checked (a * b); // فقط این عبارت چک می‌شود
```
- زمانی که `a * b` از حداکثر مقدار `int` تجاوز کند، `OverflowException` پرتاب می‌شود
- مقدار حاصل از $1000000 \times 1000000 = 10^{12}$ که از `int.MaxValue` ($2^{31}-1 \approx 2.1 \times 10^9$) بیشتر است

**استفاده از checked در سطح Statement Block:**

```csharp
checked 
{
// تمام عبارات داخل این بلوک چک می‌شوند
c = a * b;
// سایر عملیات‌ها...
}
```
### نکته مهم در ارائه:

⚠️ **بدون `checked`، سرریز به صورت خاموش اتفاق می‌افتد و نتیجه اشتباه برمی‌گردد (wraparound behavior)**



## 4. Constant Expressions و Compile-time Checking

### نکته بسیار مهم:

```csharp
int x = int.MaxValue + 1; // خطای کامپایل! (همیشه checked است)
int y = unchecked (int.MaxValue + 1); // OK، نتیجه: -2147483648
```
**تاکید در ارائه:**

- عبارات ثابت (constant expressions) که در زمان کامپایل ارزیابی می‌شوند **همیشه** checked هستند
- **استثنا:** استفاده صریح از `unchecked`
- این رفتار **مستقل** از تنظیمات پروژه است
## سوالات متداول برای آمادگی

### Q1: چرا باید از checked استفاده کنیم؟

نکته » **A:** برای جلوگیری از باگ‌های خاموش (silent bugs) که در محاسبات مالی یا حساس به امنیت می‌تواند خطرناک باشد.

### Q2: آیا checked روی performance تاثیر دارد؟


نکته » **A:** بله، اما معمولاً ناچیز است. در کدهای performance-critical می‌توان از `unchecked` استفاده کرد.

### Q3: چه زمانی از >>> استفاده کنیم?

نکته »**A:** 

- وقتی می‌خواهیم عدد را به عنوان bit pattern بی‌علامت در نظر بگیریم
- در الگوریتم‌های رمزنگاری و hash functions
- عملیات روی رنگ‌ها (Color manipulation)

## 1. انواع عددی صحیح 8 و 16 بیتی (8-bit and 16-bit Integral Types)

### انواع:
- `byte` (8-bit، بدون علامت: $0$ تا $255$)
- `sbyte` (8-bit، با علامت: $-128$ تا $127$)
- `short` (16-bit، با علامت: $-32768$ تا $32767$)
- `ushort` (16-bit، بدون علامت: $0$ تا $65535$)

### نکته کلیدی: عدم وجود عملگرهای مستقل ریاضی
```csharp
short x = 1, y = 1;
short z = x + y; // خطای کامپایل!
```
**چرا خطا می‌دهد؟**

1.سی شارپ C# به صورت خودکار `x` و `y` را به `int` تبدیل می‌کند (implicit conversion)
2. نتیجه `x + y` از نوع `int` است
3. نمی‌توان `int` را به صورت implicit به `short` تبدیل کرد (احتمال از دست رفتن داده)

### راه حل: استفاده از Cast صریح

```csharp
short z = (short)(x + y); // OK
```
⚠️ **نکته مهم برای ارائه:**
- پرانتز دور `(x + y)` ضروری است
- اگر بنویسیم `(short)x + y` فقط `x` cast می‌شود و مشکل حل نمی‌شود

### سوال 1: چرا short + short نتیجه int می‌دهد؟

نکته »  **A:** به دلایل تاریخی و عملکردی:
- پردازنده‌ها معمولاً عملیات 32-bit را سریع‌تر انجام می‌دهند
- جلوگیری از overflow در محاسبات میانی
- سازگاری با زبان‌های قدیمی‌تر (C/C++)



