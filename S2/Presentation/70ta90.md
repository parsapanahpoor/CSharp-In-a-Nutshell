# نکات فنی - out Modifier (متخصر)

 نکته => **`out`**  = انتقال به صورت ارجاع (مانند `ref`) با دو تفاوت اساسی:

## دو تفاوت اصلی با ref

| ویژگی | `ref` | `out` |
|-------|-------|-------|
| مقداردهی قبل از ورود | ✓ الزامی | ✗ غیرالزامی |
| مقداردهی قبل از خروج | اختیاری | ✓ الزامی |

---

## کاربرد اصلی

**برگرداندن چند مقدار از یک متد:**
```csharp
string a, b;
Split("Stevie Ray Vaughn", out a, out b);
Console.WriteLine(a);  // Stevie Ray
Console.WriteLine(b);  // Vaughn

void Split(string name, out string firstNames, out string lastName)
{
int i = name.LastIndexOf(' ');
firstNames = name.Substring(0, i);
lastName = name.Substring(i + 1);
// هر دو پارامتر out باید مقداردهی شوند
}
```
---

## نکات فنی کلیدی

1. نکته => **`out` = `ref`** (هر دو به صورت reference منتقل می‌شوند)
2. **مقداردهی اولیه غیرضروری:** متغیر می‌تواند بدون مقدار به متد برود
3. **الزام مقداردهی در متد:** کامپایلر خطا می‌دهد اگر متد `out` را مقداردهی نکند
4. **کاربرد:** زمانی که متد باید بیش از یک مقدار برگرداند


# نکات فنی - Out Variables, Discards, و in Modifier

## 1. Out Variables (تعریف لحظه‌ای)

**امکان تعریف متغیر همزمان با فراخوانی:**
```csharp
// قبلاً:
string a, b;
Split("Stevie Ray Vaughan", out a, out b);

// حالا (C# 7+):
Split("Stevie Ray Vaughan", out string a, out string b);
Console.WriteLine(a);  // Stevie Ray
```
**مزیت:** کد مختصرتر و خواناتر



## 4. in Modifier (فقط خواندنی)

**تعریف:** مانند `ref` اما **بدون اجازه تغییر**

### مقایسه سه Modifier:

| Modifier | انتقال | خواندن | نوشتن | مقداردهی قبلی |
|----------|--------|--------|-------|---------------|
| `ref` | Reference | ✓ | ✓ | الزامی |
| `out` | Reference | ✗ (قبل از نوشتن) | ✓ الزامی | غیرالزامی |
| `in` | Reference | ✓ | ✗ | الزامی |

### کاربرد اصلی:

**بهینه‌سازی برای Value Type‌های بزرگ (مثل `struct`):**

```csharp
void Foo(SomeBigStruct a) { ... }      // کپی کل struct
void Foo(in SomeBigStruct a) { ... }   // فقط ارجاع (بدون کپی)
```
**مزیت:** جلوگیری از overhead کپی + حفاظت از مقدار اصلی

---

## 5. Overloading با in

**امکان overload بر اساس `in`:**

```csharp
void Foo(SomeBigStruct a) { ... }      // اولین overload
void Foo(in SomeBigStruct a) { ... }   // دومین overload

SomeBigStruct x = ...;
Foo(x);      // فراخوانی اول
Foo(in x);   // فراخوانی دوم
```
**نکته:** برای فراخوانی overload دوم، `in` الزامی است

---

## 6. in اختیاری در فراخوانی

**زمانی که ابهامی نباشد:**

```csharp
void Bar(in SomeBigStruct a) { ... }

Bar(x);      // OK
Bar(in x);   // OK (هر دو یکسان)
```
**قانون:** اگر فقط یک overload با `in` وجود داشته باشد، نوشتن `in` در فراخوانی اختیاری است

---

## خلاصه نکات کلیدی

1. نکته => **Out variables:** تعریف لحظه‌ای متغیر (`out string a`)
2. نکته => **Discards:** نادیده گرفتن با `_` (مگر `_` متغیر واقعی باشد)
3. نکته => **Aliasing:** `ref`/`out` = یک حافظه، دو نام
4. نکته => **`in` modifier:** `ref` فقط خواندنی (برای struct های بزرگ)
5. نکته => **Overloading:** می‌توان فقط بر اساس `in` overload کرد
6. نکته => **`in` در فراخوانی:** اختیاری (مگر overload باشد)



# نکات فنی - params Modifier (متخصر)

## تعریف کلیدی

 نکته => **`params`** = اجازه ارسال تعداد نامحدود آرگومان از یک نوع خاص

---

## قوانین استفاده

1. **فقط آخرین پارامتر** متد می‌تواند `params` باشد
2. **نوع پارامتر:** باید آرایه **یک‌بعدی** باشد
3. **صفر آرگومان:** آرایه خالی (`Length = 0`) ساخته می‌شود

---

## مثال پایه
```csharp
int total = Sum(1, 2, 3, 4);
Console.WriteLine(total);  // 10

int Sum(params int[] ints)
{
int sum = 0;
for (int i = 0; i < ints.Length; i++)
sum += ints[i];
return sum;
}
```
---

## معادل‌سازی خودکار کامپایلر

**کامپایلر خودکار آرگومان‌ها را به آرایه تبدیل می‌کند:**

```csharp
// این دو فراخوانی یکسان هستند:
Sum(1, 2, 3, 4);
Sum(new int[] { 1, 2, 3, 4 });
```
---

## حالات مختلف فراخوانی

```csharp
Sum(1, 2, 3);              // OK: ساخت int[3]
Sum();                     // OK: ساخت int[0] (آرایه خالی)
Sum(new int[] { 5, 6 });   // OK: ارسال مستقیم آرایه
```
---

## نکات فنی کلیدی

| ویژگی | توضیح |
|-------|-------|
| **موقعیت** | فقط آخرین پارامتر |
| **نوع** | آرایه یک‌بعدی |
| **تعداد آرگومان** | $0$ تا $\infty$ |
| **آرایه خالی** | خودکار با صفر آرگومان |
| **کامپایل** | تبدیل خودکار به آرایه |

---

## کاربرد اصلی

**سادگی فراخوانی متد با تعداد متغیر ورودی:**

```csharp
// بدون params:
Console.WriteLine("{0}, {1}, {2}", new object[] { a, b, c });

// با params:
Console.WriteLine("{0}, {1}, {2}", a, b, c);
```
**مثال واقعی:** `Console.WriteLine()`, `string.Format()`, `Math.Max()`



# نکات فنی - Optional Parameters و Named Arguments

## 1. Optional Parameters (پارامترهای اختیاری)

### تعریف و استفاده

**پارامتر اختیاری:** پارامتری که مقدار پیش‌فرض دارد
```csharp
void Foo(int x = 23) 
{ 
Console.WriteLine(x); 
}

Foo();     // 23 (استفاده از مقدار پیش‌فرض)
Foo(50);   // 50 (مقدار صریح)
```
---

### مکانیزم کامپایلر

**نکته کلیدی:** کامپایلر مقدار پیش‌فرض را در **calling site** جایگذاری می‌کند

```csharp
Foo();  // معادل: Foo(23)
```
**پیامد مهم:** اگر متد در assembly دیگری باشد و مقدار پیش‌فرض تغییر کند:
- **هر دو assembly** باید recompile شوند
- مانند پارامتر اجباری عمل می‌کند

---

### محدودیت‌های مقدار پیش‌فرض

**مقدار پیش‌فرض باید یکی از این‌ها باشد:**

1. **Constant expression:** `int x = 5`, `string s = "hello"`
2. **Parameterless constructor of value type:** `DateTime d = new()`
3. **`default` expression:** `MyStruct s = default`

**ممنوع:**
```csharp
void Foo(ref int x = 5) { }   // ❌ Error: ref نمی‌تواند optional باشد
void Foo(out int x = 5) { }   // ❌ Error: out نمی‌تواند optional باشد
```
---

### ترتیب پارامترها

**قانون:** اجباری → اختیاری → `params`

```csharp
void Foo(int x = 0, int y = 0) 
{ 
Console.WriteLine(x + ", " + y); 
}

Foo(1);      // 1, 0 (x صریح، y پیش‌فرض)
Foo();       // 0, 0 (هر دو پیش‌فرض)
Foo(1, 2);   // 1, 2 (هر دو صریح)
```
---

## 2. Named Arguments (آرگومان‌های نام‌دار)

### استفاده پایه

**شناسایی آرگومان با نام به جای موقعیت:**

```csharp
void Foo(int x, int y) 
{ 
Console.WriteLine(x + ", " + y); 
}

Foo(x: 1, y: 2);   // 1, 2
Foo(y: 2, x: 1);   // 1, 2 (ترتیب مهم نیست)
```
---

### ترتیب ارزیابی (Evaluation Order)

**نکته حساس:** عبارات به ترتیب **نوشته شدن** ارزیابی می‌شوند، نه ترتیب پارامترها

```csharp
int a = 0;
Foo(y: ++a, x: --a);   // خروجی: 0, 1

// چرا؟
// 1. ++a ارزیابی می‌شود → a = 1, y = 1
// 2. --a ارزیابی می‌شود → a = 0, x = 0
// 3. Foo(x: 0, y: 1) فراخوانی می‌شود
```
**توصیه:** از چنین کدهایی خودداری کنید!

---

### ترکیب Positional و Named

**قوانین:**

1. ✅ Positional قبل از Named:
```csharp
Foo(1, y: 2);         // OK
```
2. ✅ Named در موقعیت صحیح:
```csharp
Foo(x: 1, 2);         // OK (x موقعیت اول، 2 موقعیت دوم)
```
3. ❌ Named در موقعیت اشتباه:
```csharp
Foo(y: 2, 1);         // ❌ Error: y موقعیت دوم است، نه اول
```
---

## 3. ترکیب Optional + Named

**کاربرد اصلی:** ارسال انتخابی پارامترها

```csharp
void Bar(int a = 0, int b = 0, int c = 0, int d = 0) 
{ 
Console.WriteLine($"{a}, {b}, {c}, {d}"); 
}

Bar(d: 3);           // 0, 0, 0, 3
Bar(b: 5, d: 7);     // 0, 5, 0, 7
Bar(c: 2);           // 0, 0, 2, 0
```
**مزیت:** خوانایی بالا در متدهای چندپارامتری

---

## 4. کاربردهای واقعی

### COM APIs (Chapter 24)

```csharp
// بدون Named + Optional:
excelRange.Copy(Missing.Value, Missing.Value, Missing.Value, 
Missing.Value, Missing.Value, Missing.Value, 
Missing.Value);

// با Named + Optional:
excelRange.Copy(Destination: targetRange);
```
---

## نکات کلیدی برای حفظ

1. نکته => **Optional:** کامپایلر مقدار را در calling site جایگذاری می‌کند
2. نکته => **Recompilation:** تغییر مقدار پیش‌فرض = نیاز به recompile هر دو assembly
3. نکته => **Evaluation order:** Named arguments به ترتیب نوشتاری ارزیابی می‌شوند
4.  نکته => **Positional قبل Named:** مگر Named در موقعیت صحیح باشد
5. **کاربرد اصلی:** COM APIs و متدهای چندپارامتری



# نکات فنی - Optional Parameters, Named Arguments, و Ref Returns

## 1. Optional Parameters (پارامترهای اختیاری)

### قوانین اساسی
```csharp
void Foo(int x = 23) 
{ 
Console.WriteLine(x); 
}

Foo();     // 23
Foo(15);   // 15
```
**نکات کلیدی:**

| ویژگی | توضیح |
|-------|-------|
| **مقدار پیش‌فرض** | باید ثابت (`const`) یا `default` باشد |
 نکته =>| **Compile-time** | کامپایلر مقدار را در calling site می‌نویسد |
| **ترتیب** | پارامترهای اجباری قبل از اختیاری |
| **محدودیت** | نمی‌توان با `ref`/`out` استفاده کرد |
 نکته =>| **`params`** | همیشه آخرین پارامتر (بعد از optional) |

---

### مقادیر مجاز برای Default Value

```csharp
void Method(
int a = 5,                          // ✓ ثابت
string b = "test",                  // ✓ ثابت
DateTime c = default,               // ✓ default expression
Point d = new Point(),              // ✓ parameterless constructor (value type)
object e = null                     // ✓ null
)
```
---

### هشدار مهم: Recompilation

**اگر متد در assembly دیگری فراخوانی شود:**

```csharp
// Assembly A:
public void Foo(int x = 23) { ... }

// Assembly B:
Foo();  // مقدار 23 در Assembly B کامپایل شده
```
**مشکل:** تغییر مقدار پیش‌فرض نیاز به **recompile هر دو assembly** دارد

---

## 2. Named Arguments (آرگومان‌های نام‌دار)

### استفاده پایه

```csharp
void Foo(int x, int y) 
{ 
Console.WriteLine(x + ", " + y); 
}

Foo(x: 1, y: 2);    // 1, 2
Foo(y: 2, x: 1);    // 1, 2 (ترتیب مهم نیست)
```
---

### ترکیب Named و Positional

```csharp
Foo(1, y: 2);      // ✓ OK
Foo(x: 1, 2);      // ✓ OK (آرگومان دوم در موقعیت صحیح)
Foo(y: 2, 1);      // ✗ خطا (y در موقعیت اول نیست)
```
**قانون:** Positional arguments باید قبل از Named باشند، **مگر** Named در موقعیت صحیح باشد

---

### Ref Readonly (جلوگیری از تغییر)

```csharp
static ref readonly string Prop => ref x;

// استفاده:
string val = Prop;      // ✓ OK (خواندن)
Prop = "New";           // ✗ خطا (نوشتن ممنوع)
```
**کاربرد:** بهینه‌سازی عملکرد + حفاظت از داده

---

## مقایسه Ref Return با Return عادی

| ویژگی | Return عادی | Ref Return |
|-------|-------------|-----------|
| **برگشت** | کپی مقدار | ارجاع به متغیر |
| **تغییر** | فقط local | تغییر متغیر اصلی |
| **کارایی** | کپی overhead | بدون کپی |
نکنه => | **Reference Types** | کپی ارجاع (32/64-bit) | سود کم |
نکنه => | **Value Types** | کپی کل struct | **سود زیاد** (با `readonly struct`) |

---



# نکات فنی - var و Target-Typed new Expressions

## 1. var (Implicitly Typed Local Variables)

### تعریف کلیدی


نکنه => **`var`** = حذف نوع متغیر؛ کامپایلر از سمت راست نوع را استنباط می‌کند

---

### مثال‌های پایه
```csharp
var x = "hello";
var y = new System.Text.StringBuilder();
var z = (float)Math.PI;
```
**معادل دقیق:**

```csharp
string x = "hello";
System.Text.StringBuilder y = new System.Text.StringBuilder();
float z = (float)Math.PI;
```
---

### نکات فنی کلیدی

| ویژگی | توضیح |
|-------|-------|

نکنه => | **Static Typing** | `var` ≠ dynamic؛ نوع در compile-time تعیین می‌شود |

نکنه => | **Type Safety** | تغییر نوع بعد از تعریف ممنوع است |
| **محدوده** | فقط برای متغیرهای محلی |
| **الزام initialization** | باید همزمان با تعریف مقداردهی شود |

---

### مثال Static Typing

csharp
var x = 5;           // x از نوع int
x = "hello";         // ✗ خطای compile-time

**توضیح:** `x` برای همیشه `int` است (نه `dynamic`)

---

### مشکل خوانایی

```csharp
Random r = new Random();
var x = r.Next();    // ❓ x چه نوعی است؟
```
**نکته بهینه:** از `var` زمانی استفاده کنید که نوع از کد واضح باشد:

```csharp
// ✓ واضح:
var name = "John";
var builder = new StringBuilder();

// ✗ مبهم:
var result = CalculateSomething();
```
---

### استثنا: Anonymous Types

**تنها جایی که `var` الزامی است:**

```csharp
var person = new { Name = "Ali", Age = 25 };
// نوع anonymous است، نمی‌توان صریح نوشت
```
*(جزئیات در فصل Anonymous Types)*

---

## 2. Target-Typed new Expressions (C# 9+)

### تعریف کلیدی

**حذف تکرار نوع در سمت راست `new`:**

```csharp
System.Text.StringBuilder sb1 = new();
System.Text.StringBuilder sb2 = new("Test");
```
**معادل دقیق:**

```csharp
System.Text.StringBuilder sb1 = new System.Text.StringBuilder();
System.Text.StringBuilder sb2 = new System.Text.StringBuilder("Test");
```
---

### قانون اصلی

**شرط:** کامپایلر باید بتواند نوع را **بدون ابهام** از سمت چپ استنباط کند

---

### کاربرد اصلی: جداسازی Declaration و Initialization

```csharp
class Foo
{
System.Text.StringBuilder sb;

public Foo(string initialValue)
{
sb = new(initialValue);  // ✓ نوع از field مشخص است
}
}
```
**مزیت:** بدون تکرار نام طولانی نوع

---

### مثال‌های بیشتر

```csharp
// 1. در متد:
List<string> names = new();

// 2. در آرایه:
Point[] points = new[]
{
new(1, 2),
new(3, 4)
};

// 3. در property:
class Person
{
public Address Address { get; set; } = new();
}

// 4. در return:
StringBuilder GetBuilder() => new("Initial");
```
---

### مقایسه var vs Target-Typed new

```csharp
// 1. حذف از چپ (var):
var sb = new System.Text.StringBuilder();

// 2. حذف از راست (target-typed new):
System.Text.StringBuilder sb = new();

// 3. نمی‌توان هر دو را حذف کرد:
var sb = new();  // ✗ خطا: نوع مبهم است
```
---

## مقایسه کلی

| روش | سمت چپ | سمت راست | خوانایی |
|-----|---------|----------|---------|
| **کلاسیک** | `StringBuilder sb` | `new StringBuilder()` | واضح اما پرحجم |

نکنه => | **var** | `var sb` | `new StringBuilder()` | مختصر، نوع از راست |

نکنه => | **Target-typed** | `StringBuilder sb` | `new()` | مختصر، نوع از چپ |

---

## توصیه‌های عملی

### استفاده از var

**✓ استفاده کنید:**
- نوع از سمت راست واضح است
- نام متغیر کافی توضیح می‌دهد
-
نکنه =>  Anonymous types

**✗ استفاده نکنید:**
- فراخوانی متد با نام مبهم
- نوع از expression مشخص نیست
- خوانایی کاهش می‌یابد

---

### استفاده از Target-Typed new

**✓ استفاده کنید:**
- نوع در سمت چپ نوشته شده
-نکنه => Field initialization در constructor
-نکنه =>Return statements

**✗ استفاده نکنید:**
- ابهام در نوع وجود دارد
- نوع در سمت چپ نیست

---


# نکات فنی - Expressions و Operators در C#

## 1. تعریف Expression (عبارت)

**Expression = هر چیزی که یک مقدار را نشان می‌دهد**

---

### ساده‌ترین انواع Expressions
```csharp
// 1. Constant (ثابت):
12

// 2. Variable (متغیر):
x

// 3. ترکیب با operator:
12 * 30
```
---

## 2. ساختار Operators (عملگرها)

### فرمول کلی

$$\text{Operator} + \text{Operand(s)} \rightarrow \text{New Expression}$$


---

## 4. Primary Expressions

**تعریف:** Expressions ساخته شده با operators پایه‌ای زبان

---

### مثال پیچیده

```csharp
Math.Log(1)
```
**تحلیل:**
1. `Math.Log` → **Member Lookup** (`.` operator)
2. `Log(1)` → **Method Call** (`()` operator)

**نتیجه:** دو primary expression ترکیب شده‌اند

---

### انواع Primary Operators

```csharp
// 1. Member Access (.):
object.Property
object.Method()

// 2. Method Call (()):
Console.WriteLine("test")

// 3. Array/Indexer ([]):
array[0]
list[index]

// 4. Cast ((...)):
(int)3.5

// 5. new:
new StringBuilder()
```
---

## 5. Void Expressions

**تعریف:** Expression که **هیچ مقداری ندارد**

---

### مثال

```csharp
Console.WriteLine(1)
```
**ویژگی:** 
- متد را اجرا می‌کند
- مقداری برنمی‌گرداند (`void`)

---

### محدودیت: نمی‌توان به عنوان Operand استفاده کرد

```csharp
1 + Console.WriteLine(1)  // ✗ خطای compile-time
```
**دلیل:** `Console.WriteLine` مقداری ندارد که به `1` اضافه شود

---

### مقایسه: Void vs Non-Void

```csharp
// ✗ Void expression:
var x = Console.WriteLine("Hi");  // خطا

// ✓ Non-void expression:
var x = Console.ReadLine();       // OK (برمی‌گرداند string)
```
---

### استثنا: Expression Statement


نکنه => **Void expressions می‌توانند به صورت مستقل به عنوان statement باشند:**

```csharp
Console.WriteLine("Hello");  // ✓ OK به تنهایی
int x = 5;                   // ✓ OK به تنهایی
```
---

## خلاصه ساختار Expressions


┌─────────────────────────────────────┐
│         Expression Tree             │
├─────────────────────────────────────┤
│                                     │
│    1    +    (12   *   30)          │
│    ↓         ↓         ↓            │
│  const    expression                │
│              ↓                      │
│           (12 * 30)                 │
│            ↓   ↓   ↓                │
│         const op const              │
│                                     │
└─────────────────────────────────────┘

---

## نکات کلیدی

### Expressions
- هر چیزی که مقدار دارد
- می‌توانند تو در تو باشند (nested)
- از operators ساخته می‌شوند

### Operators
- **Unary:** 1 operand
- **Binary:** 2 operands (infix)
- **Ternary:** 3 operands

### Primary Expressions
- `.` (member access)
- `()` (method call)
- `[]` (indexer)
- `new` (instantiation)

### Void Expressions
- بدون مقدار برگشتی
- نمی‌توانند operand باشند
- فقط به صورت statement مستقل

---

## مثال جامع

```csharp
// Expression پیچیده:
int result = (Math.Sqrt(25) + 10) * 2;

// تحلیل:
// 1. Math.Sqrt(25)       → primary (method call)
// 2. (... + 10)          → binary (+)
// 3. (...) * 2           → binary (*)
// 4. int result = ...    → assignment
```
**نتیجه نهایی:** Expression tree با چند سطح

---

## کاربرد عملی

### خوانایی کد

```csharp
// ✗ بد (بیش از حد پیچیده):
var x = (((a + b) * c) / d) - (e % f);

// ✓ خوب (تقسیم شده):
var sum = a + b;
var product = sum * c;
var quotient = product / d;
var remainder = e % f;
var x = quotient - remainder;
```

### کاربرد با Nullable Value Types

```csharp
int? x = null;
int y = x ?? 0;  // y = 0

int? z = 5;
int w = z ?? 0;  // w = 5
```
---

## 2. Null-Coalescing Assignment Operator (`??=`)

### تعریف (C# 8+)

**`??=` = "اگر چپ null است، مقدار راست را به آن assign کن"**

---

### Syntax

```csharp
variable ??= value;
```
**معادل:**
```csharp
if (variable == null)
variable = value;
```
---

### کاربرد: Lazy Initialization

**مفید برای مقداردهی تنبل (lazy calculated properties):**

```csharp
private string _cachedData;

public string CachedData
{
get
{
_cachedData ??= LoadExpensiveData();
return _cachedData;
}
}
```
**مزیت:** `LoadExpensiveData()` فقط یک بار و فقط زمانی که لازم است اجرا می‌شود

---



## نکته پیشرفته: Chaining

```csharp
// زنجیره ??
string result = a ?? b ?? c ?? "default";
// اولین non-null برگردانده می‌شود

// ترکیب با ??=
_cache ??= _fallback ??= GetDefault();
```
*(جزئیات lazy evaluation در صفحه 233)*


 # خلاصه نکات

### ✅ مزایا
- **جلوگیری از `NullReferenceException`**
- **کد تمیزتر** (بدون `if (x != null)`)
-نکنه =>  **Short-circuiting** دارد
- با **`??`** ترکیب عالی می‌شود

### ⚠️ نکات
- نتیجه باید **nullable** باشد (برای value types از `int?` استفاده کن)
- فقط جایی که احتمال null هست از `?.` استفاده کن
- می‌تواند **زنجیره‌ای** (`?.?.?`) باشد

*(ادامه Nullable Value Types در صفحه 210)*


#### ویژگی‌های `const`

| ویژگی | توضیح |
|-------|-------|
| **Immutable** | بعد از تعریف تغییر نمی‌کند |
| **Compile-time** | مقدار باید در زمان compile معلوم باشد |
| **Initialization required** | **باید** هنگام تعریف مقداردهی شود |

---

#### مثال صحیح

```csharp
const double c = 2.99792458E08;  // سرعت نور
const int MaxValue = 100;
const string AppName = "MyApp";
```
#### مثال خطا

```csharp
const double c = 2.99792458E08;
c += 10;  // ❌ Compile-time Error: نمی‌توان const را تغییر داد
```
```csharp
const int x;  // ❌ Error: مقداردهی اولیه الزامی است
x = 10;
```
```csharp
const DateTime now = DateTime.Now;  // ❌ Error: مقدار باید compile-time باشد
```
---
## 6. نکات مهم

### ✅ Best Practices

1. **از `const` برای مقادیر ثابت واقعی استفاده کن:**
```csharp
   const int DaysInWeek = 7;
```




# نکات کلیدی - Local Variables و Expression Statements

## 1. Local Variables - Scope

### تعریف Scope

**Scope = محدوده‌ای که متغیر در آن قابل دسترسی است**

**قانون اصلی:** Scope یک local variable یا local constant در کل block جاری گسترش می‌یابد

---

### 1.1 قوانین Scope

#### قانون 1: نمی‌توان متغیر همنام در همان block تعریف کرد
```csharp
int x;
{
int y;
int x;  // ❌ Error: x قبلاً تعریف شده
}
```
---

#### قانون 2: نمی‌توان متغیر همنام در nested block تعریف کرد

```csharp
int x;
{
int x;  // ❌ Error: x در block بیرونی تعریف شده
}
```
**تفاوت با C++:** در C++ این مجاز است (shadowing)

---

#### قانون 3: متغیرهای blocks مختلف می‌توانند همنام باشند

```csharp
{
int y;
}
{
int y;  // ✅ OK: y در scope نیست
}
```
**دلیل:** blockهای برادر (sibling) scope مشترک ندارند

---

### 1.2 خطای Out of Scope

```csharp
{
int y;
}
Console.Write(y);  // ❌ Error: y is out of scope
```
**دلیل:** `y` فقط داخل block خودش قابل دسترسی است

### مثال‌های بهتر (استفاده صحیح)

```csharp
// بجای:
new StringBuilder();

// بنویس:
sb = new StringBuilder();

// بجای:
x.Equals(y);

// بنویس:
if (x.Equals(y)) { /* ... */ }
// یا:
bool areEqual = x.Equals(y);
```
---


## 8. نکات مهم

### ✅ Valid Expression Statements

```csharp
x = 10;                     // Assignment
x++;                        // Increment
Console.WriteLine("Hi");    // Method call
obj.DoSomething();         // Method call
list.Add(5);               // Method call با side-effect
sb = new StringBuilder();   // Instantiation + assignment
```
### ❌ Invalid Expression Statements

```csharp
x + 5;          // ❌ فقط محاسبه (بدون assignment یا call)
x == y;         // ❌ فقط مقایسه (بدون تغییر state)
x < 10;         // ❌ فقط ارزیابی boolean
"Hello";        // ❌ فقط literal
```
**دلیل:** هیچ‌کدام state را تغییر نمی‌دهند

---

## 1. مکانیزم‌های کنترل جریان


نکنه => C# چهار مکانیزم برای کنترل شرطی دارد:
- **Selection:** `if`, `switch`
- **Conditional Operator:** `?:`
- **Loop:** `while`, `do-while`, `for`, `foreach`

---

## 2. `if` Statement

### Syntax پایه
```csharp
if (condition)
statement;
```
**شرط:** `condition` باید `bool` باشد

### مثال

```csharp
if (5 < 2 * 3)
Console.WriteLine("true");  // اجرا می‌شود
```
---

### با Code Block

```csharp
if (5 < 2 * 3)
{
Console.WriteLine("true");
Console.WriteLine("Let's move on!");
}
```
**توصیه:** همیشه از `{}` استفاده کن (حتی برای یک خط)

---

## 3. `else` Clause

### Syntax

```csharp
if (condition)
statement1;
else
statement2;
```
### مثال

```csharp
if (2 + 2 == 5)
Console.WriteLine("Does not compute");
else
Console.WriteLine("False");  // اجرا می‌شود
```
---

## 4. `else if` (Nested)

### Syntax

```csharp
if (condition1)
statement1;
else if (condition2)
statement2;
else
statement3;
```
### مثال

```csharp
if (2 + 2 == 5)
Console.WriteLine("Does not compute");
else if (2 + 2 == 4)
Console.WriteLine("Computes");  // اجرا می‌شود
```
---


# Braces و Flow Control در if Statements - نکات کلیدی

## 1. قانون پیش‌فرض `else`


نکنه => **`else` همیشه به نزدیک‌ترین `if` قبلی تعلق دارد**

### مثال - بدون Braces
```csharp
if (true)
if (false)
Console.WriteLine();
else
Console.WriteLine("executes");  // ✅ اجرا می‌شود
```
**تعلق `else`:** به `if (false)` تعلق دارد، نه `if (true)`

---

### معادل صریح

```csharp
if (true)
{
if (false)
Console.WriteLine();
else
Console.WriteLine("executes");  // ✅ اجرا می‌شود
}
```
---

## 2. تغییر Flow با Braces

### جابجایی Braces

```csharp
if (true)
{
if (false)
Console.WriteLine();
}
else
Console.WriteLine("does not execute");  // ❌ اجرا نمی‌شود
```
**تغییر:** حالا `else` به `if (true)` بیرونی تعلق دارد

---

## 3. مزیت Braces

### ✅ خوانایی بهتر

```csharp
// بدون braces - مبهم
if (x > 0)
if (y > 0)
Console.WriteLine("Both positive");
else
Console.WriteLine("???");  // else کدام if است؟

// با braces - واضح
if (x > 0)
{
if (y > 0)
Console.WriteLine("Both positive");
}
else
{
Console.WriteLine("x is not positive");  // ✅ روشن
}
```
**توصیه:** همیشه از braces استفاده کن (حتی وقت لازم نیست)

---

## 4. الگوی `else if` Chain

### استثنا: Pattern معمول

```csharp
void TellMeWhatICanDo(int age)
{
if (age >= 35)
Console.WriteLine("You can be president!");
else if (age >= 21)
Console.WriteLine("You can drink!");
else if (age >= 18)
Console.WriteLine("You can vote!");
else
Console.WriteLine("You can wait!");
}
```
**ویژگی‌ها:**
- شبیه `elseif` زبان‌های دیگر
- Visual Studio indentation را حفظ می‌کند
- **واقعیت:** هر `if` داخل `else` قبلی nest شده است

---

### ساختار واقعی (با Braces)

```csharp
if (age >= 35)
Console.WriteLine("You can be president!");
else
{
if (age >= 21)
Console.WriteLine("You can drink!");
else
{
if (age >= 18)
Console.WriteLine("You can vote!");
else
Console.WriteLine("You can wait!");
}
}
```
**نکته:** همه `else if` ها دارای nesting هستند، اما formatting خوانایی را بهبود می‌دهد

---

# Switch Statement - نکات کلیدی

## 1. کاربرد اصلی

**انشعاب بر اساس مقادیر مختلف یک متغیر**

### مزیت نسبت به `if`
```csharp
// ✅ switch - تنها یک بار ارزیابی می‌شود
switch (cardNumber)
{
case 13: /* ... */ break;
case 12: /* ... */ break;
}

// ❌ if - چندین بار ارزیابی می‌شود
if (cardNumber == 13) { }
else if (cardNumber == 12) { }
```
**نتیجه:** کد تمیزتر و کارآمدتر

---

## 2. Syntax پایه

```csharp
void ShowCard(int cardNumber)
{
switch (cardNumber)
{
case 13:
Console.WriteLine("King");
break;
case 12:
Console.WriteLine("Queen");
break;
case 11:
Console.WriteLine("Jack");
break;
default:
Console.WriteLine(cardNumber);
break;
}
}
```
---

## 3. انواع مجاز برای Constants

| نوع | مثال |
|-----|------|
| **اعداد (Built-in)** | `int`, `long`, `byte`, ... |
| **`bool`** | `true`, `false` |
| **`char`** | `'a'`, `'Z'` |
| **`string`** | `"hello"` |
| **`enum`** | `Color.Red` |

---

## 4. Jump Statements (الزامی)

**در پایان هر `case` باید یکی از این‌ها باشد:**

| Statement | عملکرد |
|-----------|--------|
| **`break`** | خروج از `switch` |
| **`goto case x`** | پرش به `case` دیگر |
| **`goto default`** | پرش به `default` |
| **`return`** | خروج از متد |
| **`throw`** | پرتاب Exception |
| **`continue`** | (در loop) |
| **`goto label`** | پرش به label |

---

## 5. `goto case` - مثال

```csharp
case -1:  // Joker
goto case 12;  // ✅ پرش به Queen
```
**کاربرد:** یک مقدار رفتار مقدار دیگری را دارد

---

## 6. Multiple Cases - یک کد

### کدهای مشترک

```csharp
switch (cardNumber)
{
case 13:  // King
case 12:  // Queen
case 11:  // Jack
Console.WriteLine("Face card");
break;
default:
Console.WriteLine("Plain card");
break;
}
```
**مزیت:** کد تمیزتر از `if-else` های متعدد

---

## 7. `default` Clause

**اجرا می‌شود اگر هیچ `case` دیگری match نکند**

```csharp
default:
Console.WriteLine("Unknown card");
break;
```
**نکته:** اختیاری است، اما توصیه می‌شود

---

## خلاصه مقایسه

| ویژگی | `switch` | `if-else` |
|-------|----------|-----------|
| **ارزیابی** | یک بار | چند بار |
| **خوانایی** | بهتر (برای مقادیر زیاد) | بدتر |
| **محدودیت** | فقط constants | هر شرط `bool` |

نکنه => | **Fall-through** | نیاز به `goto case` | ندارد |

---

## Best Practice

```csharp
// ✅ خوب - همیشه default داشته باش
switch (value)
{
case 1:
DoSomething();
break;
default:
HandleUnexpected();
break;
}

// ✅ خوب - گروه‌بندی cases مشابه
switch (grade)
{
case 'A':
case 'B':
Console.WriteLine("Pass");
break;
case 'F':
Console.WriteLine("Fail");
break;
}
```
---

## نکته کلیدی


نکنه => **`switch` برای انشعاب بر اساس مقادیر ثابت (constants) ایده‌آل است و کد را از `if-else` های زنجیره‌ای تمیزتر می‌کند**




# Switching on Types - نکات کلیدی

## 1. مفهوم اصلی

**از C# 7 می‌توان روی Types (انواع) switch کرد**
```csharp
void TellMeTheType(object x)
{
switch (x)
{
case int i:
Console.WriteLine("It's an int!");
Console.WriteLine($"The square of {i} is {i * i}");
break;
case string s:
Console.WriteLine("It's a string");
Console.WriteLine($"The length of {s} is {s.Length}");
break;
case DateTime:
Console.WriteLine("It's a DateTime");
break;
default:
Console.WriteLine("I don't know what x is");
break;
}
}
```
# Switch Statement - نکات تکمیلی

## 1. اهمیت ترتیب Cases در Type Switching

**برخلاف Constants، در Type Switching ترتیب مهم است:**
```csharp
// ✅ صحیح
case int i:
// ...
break;
case object o:  // عمومی‌تر
// ...
break;

// ❌ غلط - Compile نمی‌شود
case object o:  // عمومی‌تر اول
// ...
break;
case int i:     // Unreachable! (هرگز اجرا نمی‌شود)
// ...
break;
```
**دلیل:** کامپایلر می‌فهمد case دوم هرگز اجرا نخواهد شد

**استثنا:** `default` همیشه آخر اجرا می‌شود، مهم نیست کجا باشد

---

## 2. Stacking Multiple Cases با Pattern

**یک کد برای چند type:**

```csharp
switch (x)
{
case float f when f > 1000:
case double d when d > 1000:
case decimal m when m > 1000:
Console.WriteLine("We can refer to x here but not f or d or m");
break;
}
```
**نکته کلیدی:** متغیرهای Pattern (`f`, `d`, `m`) فقط در `when` قابل استفاده‌اند، در بدنه case خارج از scope هستند (چون کامپایلر نمی‌داند کدام assign شده)

---

## 3. ترکیب Constants و Patterns

**مجاز است:**

```csharp
switch (x)
{
case 0:           // constant
// ...
break;
case int i:       // pattern
// ...
break;
case null:        // null value
Console.WriteLine("Nothing here");
break;
}
```
---

## 4. Switch Expressions (C# 8+)

**فرم فشرده‌تر برای بازگشت مقدار:**

```csharp
string cardName = cardNumber switch
{
13 => "King",
12 => "Queen",
11 => "Jack",
_ => "Pip card"  // معادل default
};
```
**تفاوت‌ها:**
-نکنه =>  `switch` بعد از متغیر می‌آید
-نکنه =>  Cases به جای statement، expression هستند (با `,` خاتمه می‌یابند)
- `_` به جای `default`
- فشرده‌تر و قابل استفاده در LINQ

**هشدار:** اگر `_` را حذف کنید و هیچ case match نکند، **Exception** پرتاب می‌شود
