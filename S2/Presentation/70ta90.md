# Ù†Ú©Ø§Øª ÙÙ†ÛŒ - out Modifier (Ù…ØªØ®ØµØ±)

## ØªØ¹Ø±ÛŒÙ Ú©Ù„ÛŒØ¯ÛŒ

**`out`** = Ø§Ù†ØªÙ‚Ø§Ù„ Ø¨Ù‡ ØµÙˆØ±Øª Ø§Ø±Ø¬Ø§Ø¹ (Ù…Ø§Ù†Ù†Ø¯ `ref`) Ø¨Ø§ Ø¯Ùˆ ØªÙØ§ÙˆØª Ø§Ø³Ø§Ø³ÛŒ:

## Ø¯Ùˆ ØªÙØ§ÙˆØª Ø§ØµÙ„ÛŒ Ø¨Ø§ ref

| ÙˆÛŒÚ˜Ú¯ÛŒ | `ref` | `out` |
|-------|-------|-------|
| Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ù‚Ø¨Ù„ Ø§Ø² ÙˆØ±ÙˆØ¯ | âœ“ Ø§Ù„Ø²Ø§Ù…ÛŒ | âœ— ØºÛŒØ±Ø§Ù„Ø²Ø§Ù…ÛŒ |
| Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ù‚Ø¨Ù„ Ø§Ø² Ø®Ø±ÙˆØ¬ | Ø§Ø®ØªÛŒØ§Ø±ÛŒ | âœ“ Ø§Ù„Ø²Ø§Ù…ÛŒ |

---

## Ú©Ø§Ø±Ø¨Ø±Ø¯ Ø§ØµÙ„ÛŒ

**Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯Ù† Ú†Ù†Ø¯ Ù…Ù‚Ø¯Ø§Ø± Ø§Ø² ÛŒÚ© Ù…ØªØ¯:**
```csharp
string a, b;
Split("Stevie Ray Vaughn", out a, out b);
Console.WriteLine(a);  // Stevie Ray
Console.WriteLine(b);  // Vaughn

void Split(string name, out string firstNames, out string lastName)
{
int i = name.LastIndexOf(' ');
firstNames = name.Substring(0, i);
lastName = name.Substring(i + 1);
// Ù‡Ø± Ø¯Ùˆ Ù¾Ø§Ø±Ø§Ù…ØªØ± out Ø¨Ø§ÛŒØ¯ Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ø´ÙˆÙ†Ø¯
}
```
---

## Ù†Ú©Ø§Øª ÙÙ†ÛŒ Ú©Ù„ÛŒØ¯ÛŒ

1. **`out` = `ref`** (Ù‡Ø± Ø¯Ùˆ Ø¨Ù‡ ØµÙˆØ±Øª reference Ù…Ù†ØªÙ‚Ù„ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯)
2. **Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ ØºÛŒØ±Ø¶Ø±ÙˆØ±ÛŒ:** Ù…ØªØºÛŒØ± Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨Ø¯ÙˆÙ† Ù…Ù‚Ø¯Ø§Ø± Ø¨Ù‡ Ù…ØªØ¯ Ø¨Ø±ÙˆØ¯
3. **Ø§Ù„Ø²Ø§Ù… Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ø¯Ø± Ù…ØªØ¯:** Ú©Ø§Ù…Ù¾Ø§ÛŒÙ„Ø± Ø®Ø·Ø§ Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ Ø§Ú¯Ø± Ù…ØªØ¯ `out` Ø±Ø§ Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ù†Ú©Ù†Ø¯
4. **Ú©Ø§Ø±Ø¨Ø±Ø¯:** Ø²Ù…Ø§Ù†ÛŒ Ú©Ù‡ Ù…ØªØ¯ Ø¨Ø§ÛŒØ¯ Ø¨ÛŒØ´ Ø§Ø² ÛŒÚ© Ù…Ù‚Ø¯Ø§Ø± Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯

---

## Ù‚Ø§Ù†ÙˆÙ† Ø­Ø§ÙØ¸Ù‡


out parameter = ref parameter
(Ù‡Ø± Ø¯Ùˆ Ø¯Ø± ÛŒÚ© Ø¢Ø¯Ø±Ø³ Ø­Ø§ÙØ¸Ù‡ Ù‚Ø±Ø§Ø± Ø¯Ø§Ø±Ù†Ø¯)



# Ù†Ú©Ø§Øª ÙÙ†ÛŒ - Out Variables, Discards, Ùˆ in Modifier

## 1. Out Variables (ØªØ¹Ø±ÛŒÙ Ù„Ø­Ø¸Ù‡â€ŒØ§ÛŒ)

**Ø§Ù…Ú©Ø§Ù† ØªØ¹Ø±ÛŒÙ Ù…ØªØºÛŒØ± Ù‡Ù…Ø²Ù…Ø§Ù† Ø¨Ø§ ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ:**
```csharp
// Ù‚Ø¨Ù„Ø§Ù‹:
string a, b;
Split("Stevie Ray Vaughan", out a, out b);

// Ø­Ø§Ù„Ø§ (C# 7+):
Split("Stevie Ray Vaughan", out string a, out string b);
Console.WriteLine(a);  // Stevie Ray
```
**Ù…Ø²ÛŒØª:** Ú©Ø¯ Ù…Ø®ØªØµØ±ØªØ± Ùˆ Ø®ÙˆØ§Ù†Ø§ØªØ±

---

## 2. Discards (Ù†Ø§Ø¯ÛŒØ¯Ù‡ Ú¯Ø±ÙØªÙ† Ø®Ø±ÙˆØ¬ÛŒ)

**Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² `_` Ø¨Ø±Ø§ÛŒ Ø®Ø±ÙˆØ¬ÛŒâ€ŒÙ‡Ø§ÛŒ ØºÛŒØ±Ø¶Ø±ÙˆØ±ÛŒ:**

```csharp
// Ù†Ø§Ø¯ÛŒØ¯Ù‡ Ú¯Ø±ÙØªÙ† Ù¾Ø§Ø±Ø§Ù…ØªØ± Ø¯ÙˆÙ…:
Split("Stevie Ray Vaughan", out string a, out _);
Console.WriteLine(a);  // Stevie Ray

// Ù†Ø§Ø¯ÛŒØ¯Ù‡ Ú¯Ø±ÙØªÙ† Ú†Ù†Ø¯ Ù¾Ø§Ø±Ø§Ù…ØªØ±:
SomeBigMethod(out _, out _, out _, out int x, out _, out _, out _);
```
**Ù†Ú©ØªÙ‡ ÙÙ†ÛŒ:** Ú©Ø§Ù…Ù¾Ø§ÛŒÙ„Ø± `_` Ø±Ø§ Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ù†Ù…Ø§Ø¯ ÙˆÛŒÚ˜Ù‡ Discard ØªØ´Ø®ÛŒØµ Ù…ÛŒâ€ŒØ¯Ù‡Ø¯

**Ø§Ø³ØªØ«Ù†Ø§:** Ø§Ú¯Ø± Ù…ØªØºÛŒØ± ÙˆØ§Ù‚Ø¹ÛŒ `_` Ø¯Ø± scope Ø¨Ø§Ø´Ø¯ØŒ discard ØºÛŒØ±ÙØ¹Ø§Ù„ Ù…ÛŒâ€ŒØ´ÙˆØ¯:

```csharp
string _;
Split("Stevie Ray Vaughan", out string a, out _);
Console.WriteLine(_);  // Vaughan (Ù…ØªØºÛŒØ± ÙˆØ§Ù‚Ø¹ÛŒ Ø§Ø³ØªØŒ Ù†Ù‡ discard)
```
---

## 3. Aliasing Ø¯Ø± Passing by Reference

**Ù…ÙÙ‡ÙˆÙ… Ú©Ù„ÛŒØ¯ÛŒ:** `ref`/`out` ÛŒØ¹Ù†ÛŒ **ÛŒÚ© Ø¢Ø¯Ø±Ø³ Ø­Ø§ÙØ¸Ù‡ØŒ Ø¯Ùˆ Ù†Ø§Ù…**

```csharp
class Test
{
static int x;
static void Main()
{
Foo(out x);
}

static void Foo(out int y)
{
Console.WriteLine(x);  // 0
y = 1;                 // ØªØºÛŒÛŒØ± y = ØªØºÛŒÛŒØ± x
Console.WriteLine(x);  // 1
}
}
```
**ØªÙˆØ¶ÛŒØ­:** `x` Ùˆ `y` Ù‡Ù…Ø§Ù† Ù…ØªØºÛŒØ± Ù‡Ø³ØªÙ†Ø¯ (aliasing)

---

## 4. in Modifier (ÙÙ‚Ø· Ø®ÙˆØ§Ù†Ø¯Ù†ÛŒ)

**ØªØ¹Ø±ÛŒÙ:** Ù…Ø§Ù†Ù†Ø¯ `ref` Ø§Ù…Ø§ **Ø¨Ø¯ÙˆÙ† Ø§Ø¬Ø§Ø²Ù‡ ØªØºÛŒÛŒØ±**

### Ù…Ù‚Ø§ÛŒØ³Ù‡ Ø³Ù‡ Modifier:

| Modifier | Ø§Ù†ØªÙ‚Ø§Ù„ | Ø®ÙˆØ§Ù†Ø¯Ù† | Ù†ÙˆØ´ØªÙ† | Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ù‚Ø¨Ù„ÛŒ |
|----------|--------|--------|-------|---------------|
| `ref` | Reference | âœ“ | âœ“ | Ø§Ù„Ø²Ø§Ù…ÛŒ |
| `out` | Reference | âœ— (Ù‚Ø¨Ù„ Ø§Ø² Ù†ÙˆØ´ØªÙ†) | âœ“ Ø§Ù„Ø²Ø§Ù…ÛŒ | ØºÛŒØ±Ø§Ù„Ø²Ø§Ù…ÛŒ |
| `in` | Reference | âœ“ | âœ— | Ø§Ù„Ø²Ø§Ù…ÛŒ |

### Ú©Ø§Ø±Ø¨Ø±Ø¯ Ø§ØµÙ„ÛŒ:

**Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø±Ø§ÛŒ Value Typeâ€ŒÙ‡Ø§ÛŒ Ø¨Ø²Ø±Ú¯ (Ù…Ø«Ù„ `struct`):**

```csharp
void Foo(SomeBigStruct a) { ... }      // Ú©Ù¾ÛŒ Ú©Ù„ struct
void Foo(in SomeBigStruct a) { ... }   // ÙÙ‚Ø· Ø§Ø±Ø¬Ø§Ø¹ (Ø¨Ø¯ÙˆÙ† Ú©Ù¾ÛŒ)
```
**Ù…Ø²ÛŒØª:** Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² overhead Ú©Ù¾ÛŒ + Ø­ÙØ§Ø¸Øª Ø§Ø² Ù…Ù‚Ø¯Ø§Ø± Ø§ØµÙ„ÛŒ

---

## 5. Overloading Ø¨Ø§ in

**Ø§Ù…Ú©Ø§Ù† overload Ø¨Ø± Ø§Ø³Ø§Ø³ `in`:**

```csharp
void Foo(SomeBigStruct a) { ... }      // Ø§ÙˆÙ„ÛŒÙ† overload
void Foo(in SomeBigStruct a) { ... }   // Ø¯ÙˆÙ…ÛŒÙ† overload

SomeBigStruct x = ...;
Foo(x);      // ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ Ø§ÙˆÙ„
Foo(in x);   // ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ Ø¯ÙˆÙ…
```
**Ù†Ú©ØªÙ‡:** Ø¨Ø±Ø§ÛŒ ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ overload Ø¯ÙˆÙ…ØŒ `in` Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª

---

## 6. in Ø§Ø®ØªÛŒØ§Ø±ÛŒ Ø¯Ø± ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ

**Ø²Ù…Ø§Ù†ÛŒ Ú©Ù‡ Ø§Ø¨Ù‡Ø§Ù…ÛŒ Ù†Ø¨Ø§Ø´Ø¯:**

```csharp
void Bar(in SomeBigStruct a) { ... }

Bar(x);      // OK
Bar(in x);   // OK (Ù‡Ø± Ø¯Ùˆ ÛŒÚ©Ø³Ø§Ù†)
```
**Ù‚Ø§Ù†ÙˆÙ†:** Ø§Ú¯Ø± ÙÙ‚Ø· ÛŒÚ© overload Ø¨Ø§ `in` ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯ØŒ Ù†ÙˆØ´ØªÙ† `in` Ø¯Ø± ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ Ø§Ø®ØªÛŒØ§Ø±ÛŒ Ø§Ø³Øª

---

## Ø®Ù„Ø§ØµÙ‡ Ù†Ú©Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ

1. **Out variables:** ØªØ¹Ø±ÛŒÙ Ù„Ø­Ø¸Ù‡â€ŒØ§ÛŒ Ù…ØªØºÛŒØ± (`out string a`)
2. **Discards:** Ù†Ø§Ø¯ÛŒØ¯Ù‡ Ú¯Ø±ÙØªÙ† Ø¨Ø§ `_` (Ù…Ú¯Ø± `_` Ù…ØªØºÛŒØ± ÙˆØ§Ù‚Ø¹ÛŒ Ø¨Ø§Ø´Ø¯)
3. **Aliasing:** `ref`/`out` = ÛŒÚ© Ø­Ø§ÙØ¸Ù‡ØŒ Ø¯Ùˆ Ù†Ø§Ù…
4. **`in` modifier:** `ref` ÙÙ‚Ø· Ø®ÙˆØ§Ù†Ø¯Ù†ÛŒ (Ø¨Ø±Ø§ÛŒ struct Ù‡Ø§ÛŒ Ø¨Ø²Ø±Ú¯)
5. **Overloading:** Ù…ÛŒâ€ŒØªÙˆØ§Ù† ÙÙ‚Ø· Ø¨Ø± Ø§Ø³Ø§Ø³ `in` overload Ú©Ø±Ø¯
6. **`in` Ø¯Ø± ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ:** Ø§Ø®ØªÛŒØ§Ø±ÛŒ (Ù…Ú¯Ø± overload Ø¨Ø§Ø´Ø¯)



# Ù†Ú©Ø§Øª ÙÙ†ÛŒ - params Modifier (Ù…ØªØ®ØµØ±)

## ØªØ¹Ø±ÛŒÙ Ú©Ù„ÛŒØ¯ÛŒ

**`params`** = Ø§Ø¬Ø§Ø²Ù‡ Ø§Ø±Ø³Ø§Ù„ ØªØ¹Ø¯Ø§Ø¯ Ù†Ø§Ù…Ø­Ø¯ÙˆØ¯ Ø¢Ø±Ú¯ÙˆÙ…Ø§Ù† Ø§Ø² ÛŒÚ© Ù†ÙˆØ¹ Ø®Ø§Øµ

---

## Ù‚ÙˆØ§Ù†ÛŒÙ† Ø§Ø³ØªÙØ§Ø¯Ù‡

1. **ÙÙ‚Ø· Ø¢Ø®Ø±ÛŒÙ† Ù¾Ø§Ø±Ø§Ù…ØªØ±** Ù…ØªØ¯ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ `params` Ø¨Ø§Ø´Ø¯
2. **Ù†ÙˆØ¹ Ù¾Ø§Ø±Ø§Ù…ØªØ±:** Ø¨Ø§ÛŒØ¯ Ø¢Ø±Ø§ÛŒÙ‡ **ÛŒÚ©â€ŒØ¨Ø¹Ø¯ÛŒ** Ø¨Ø§Ø´Ø¯
3. **ØµÙØ± Ø¢Ø±Ú¯ÙˆÙ…Ø§Ù†:** Ø¢Ø±Ø§ÛŒÙ‡ Ø®Ø§Ù„ÛŒ (`Length = 0`) Ø³Ø§Ø®ØªÙ‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯

---

## Ù…Ø«Ø§Ù„ Ù¾Ø§ÛŒÙ‡
```csharp
int total = Sum(1, 2, 3, 4);
Console.WriteLine(total);  // 10

int Sum(params int[] ints)
{
int sum = 0;
for (int i = 0; i < ints.Length; i++)
sum += ints[i];
return sum;
}
```
---

## Ù…Ø¹Ø§Ø¯Ù„â€ŒØ³Ø§Ø²ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø± Ú©Ø§Ù…Ù¾Ø§ÛŒÙ„Ø±

**Ú©Ø§Ù…Ù¾Ø§ÛŒÙ„Ø± Ø®ÙˆØ¯Ú©Ø§Ø± Ø¢Ø±Ú¯ÙˆÙ…Ø§Ù†â€ŒÙ‡Ø§ Ø±Ø§ Ø¨Ù‡ Ø¢Ø±Ø§ÛŒÙ‡ ØªØ¨Ø¯ÛŒÙ„ Ù…ÛŒâ€ŒÚ©Ù†Ø¯:**

```csharp
// Ø§ÛŒÙ† Ø¯Ùˆ ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ ÛŒÚ©Ø³Ø§Ù† Ù‡Ø³ØªÙ†Ø¯:
Sum(1, 2, 3, 4);
Sum(new int[] { 1, 2, 3, 4 });
```
---

## Ø­Ø§Ù„Ø§Øª Ù…Ø®ØªÙ„Ù ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ

```csharp
Sum(1, 2, 3);              // OK: Ø³Ø§Ø®Øª int[3]
Sum();                     // OK: Ø³Ø§Ø®Øª int[0] (Ø¢Ø±Ø§ÛŒÙ‡ Ø®Ø§Ù„ÛŒ)
Sum(new int[] { 5, 6 });   // OK: Ø§Ø±Ø³Ø§Ù„ Ù…Ø³ØªÙ‚ÛŒÙ… Ø¢Ø±Ø§ÛŒÙ‡
```
---

## Ù†Ú©Ø§Øª ÙÙ†ÛŒ Ú©Ù„ÛŒØ¯ÛŒ

| ÙˆÛŒÚ˜Ú¯ÛŒ | ØªÙˆØ¶ÛŒØ­ |
|-------|-------|
| **Ù…ÙˆÙ‚Ø¹ÛŒØª** | ÙÙ‚Ø· Ø¢Ø®Ø±ÛŒÙ† Ù¾Ø§Ø±Ø§Ù…ØªØ± |
| **Ù†ÙˆØ¹** | Ø¢Ø±Ø§ÛŒÙ‡ ÛŒÚ©â€ŒØ¨Ø¹Ø¯ÛŒ |
| **ØªØ¹Ø¯Ø§Ø¯ Ø¢Ø±Ú¯ÙˆÙ…Ø§Ù†** | $0$ ØªØ§ $\infty$ |
| **Ø¢Ø±Ø§ÛŒÙ‡ Ø®Ø§Ù„ÛŒ** | Ø®ÙˆØ¯Ú©Ø§Ø± Ø¨Ø§ ØµÙØ± Ø¢Ø±Ú¯ÙˆÙ…Ø§Ù† |
| **Ú©Ø§Ù…Ù¾Ø§ÛŒÙ„** | ØªØ¨Ø¯ÛŒÙ„ Ø®ÙˆØ¯Ú©Ø§Ø± Ø¨Ù‡ Ø¢Ø±Ø§ÛŒÙ‡ |

---

## Ú©Ø§Ø±Ø¨Ø±Ø¯ Ø§ØµÙ„ÛŒ

**Ø³Ø§Ø¯Ú¯ÛŒ ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ Ù…ØªØ¯ Ø¨Ø§ ØªØ¹Ø¯Ø§Ø¯ Ù…ØªØºÛŒØ± ÙˆØ±ÙˆØ¯ÛŒ:**

```csharp
// Ø¨Ø¯ÙˆÙ† params:
Console.WriteLine("{0}, {1}, {2}", new object[] { a, b, c });

// Ø¨Ø§ params:
Console.WriteLine("{0}, {1}, {2}", a, b, c);
```
**Ù…Ø«Ø§Ù„ ÙˆØ§Ù‚Ø¹ÛŒ:** `Console.WriteLine()`, `string.Format()`, `Math.Max()`



# Ù†Ú©Ø§Øª ÙÙ†ÛŒ - Optional Parameters Ùˆ Named Arguments

## 1. Optional Parameters (Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ Ø§Ø®ØªÛŒØ§Ø±ÛŒ)

### ØªØ¹Ø±ÛŒÙ Ùˆ Ø§Ø³ØªÙØ§Ø¯Ù‡

**Ù¾Ø§Ø±Ø§Ù…ØªØ± Ø§Ø®ØªÛŒØ§Ø±ÛŒ:** Ù¾Ø§Ø±Ø§Ù…ØªØ±ÛŒ Ú©Ù‡ Ù…Ù‚Ø¯Ø§Ø± Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ø¯Ø§Ø±Ø¯
```csharp
void Foo(int x = 23) 
{ 
Console.WriteLine(x); 
}

Foo();     // 23 (Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù…Ù‚Ø¯Ø§Ø± Ù¾ÛŒØ´â€ŒÙØ±Ø¶)
Foo(50);   // 50 (Ù…Ù‚Ø¯Ø§Ø± ØµØ±ÛŒØ­)
```
---

### Ù…Ú©Ø§Ù†ÛŒØ²Ù… Ú©Ø§Ù…Ù¾Ø§ÛŒÙ„Ø±

**Ù†Ú©ØªÙ‡ Ú©Ù„ÛŒØ¯ÛŒ:** Ú©Ø§Ù…Ù¾Ø§ÛŒÙ„Ø± Ù…Ù‚Ø¯Ø§Ø± Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ø±Ø§ Ø¯Ø± **calling site** Ø¬Ø§ÛŒÚ¯Ø°Ø§Ø±ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ø¯

```csharp
Foo();  // Ù…Ø¹Ø§Ø¯Ù„: Foo(23)
```
**Ù¾ÛŒØ§Ù…Ø¯ Ù…Ù‡Ù…:** Ø§Ú¯Ø± Ù…ØªØ¯ Ø¯Ø± assembly Ø¯ÛŒÚ¯Ø±ÛŒ Ø¨Ø§Ø´Ø¯ Ùˆ Ù…Ù‚Ø¯Ø§Ø± Ù¾ÛŒØ´â€ŒÙØ±Ø¶ ØªØºÛŒÛŒØ± Ú©Ù†Ø¯:
- **Ù‡Ø± Ø¯Ùˆ assembly** Ø¨Ø§ÛŒØ¯ recompile Ø´ÙˆÙ†Ø¯
- Ù…Ø§Ù†Ù†Ø¯ Ù¾Ø§Ø±Ø§Ù…ØªØ± Ø§Ø¬Ø¨Ø§Ø±ÛŒ Ø¹Ù…Ù„ Ù…ÛŒâ€ŒÚ©Ù†Ø¯

---

### Ù…Ø­Ø¯ÙˆØ¯ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ù…Ù‚Ø¯Ø§Ø± Ù¾ÛŒØ´â€ŒÙØ±Ø¶

**Ù…Ù‚Ø¯Ø§Ø± Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ø¨Ø§ÛŒØ¯ ÛŒÚ©ÛŒ Ø§Ø² Ø§ÛŒÙ†â€ŒÙ‡Ø§ Ø¨Ø§Ø´Ø¯:**

1. **Constant expression:** `int x = 5`, `string s = "hello"`
2. **Parameterless constructor of value type:** `DateTime d = new()`
3. **`default` expression:** `MyStruct s = default`

**Ù…Ù…Ù†ÙˆØ¹:**
```csharp
void Foo(ref int x = 5) { }   // âŒ Error: ref Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ optional Ø¨Ø§Ø´Ø¯
void Foo(out int x = 5) { }   // âŒ Error: out Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ optional Ø¨Ø§Ø´Ø¯
```
---

### ØªØ±ØªÛŒØ¨ Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§

**Ù‚Ø§Ù†ÙˆÙ†:** Ø§Ø¬Ø¨Ø§Ø±ÛŒ â†’ Ø§Ø®ØªÛŒØ§Ø±ÛŒ â†’ `params`

```csharp
void Foo(int x = 0, int y = 0) 
{ 
Console.WriteLine(x + ", " + y); 
}

Foo(1);      // 1, 0 (x ØµØ±ÛŒØ­ØŒ y Ù¾ÛŒØ´â€ŒÙØ±Ø¶)
Foo();       // 0, 0 (Ù‡Ø± Ø¯Ùˆ Ù¾ÛŒØ´â€ŒÙØ±Ø¶)
Foo(1, 2);   // 1, 2 (Ù‡Ø± Ø¯Ùˆ ØµØ±ÛŒØ­)
```
---

## 2. Named Arguments (Ø¢Ø±Ú¯ÙˆÙ…Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ù†Ø§Ù…â€ŒØ¯Ø§Ø±)

### Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù¾Ø§ÛŒÙ‡

**Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø¢Ø±Ú¯ÙˆÙ…Ø§Ù† Ø¨Ø§ Ù†Ø§Ù… Ø¨Ù‡ Ø¬Ø§ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª:**

```csharp
void Foo(int x, int y) 
{ 
Console.WriteLine(x + ", " + y); 
}

Foo(x: 1, y: 2);   // 1, 2
Foo(y: 2, x: 1);   // 1, 2 (ØªØ±ØªÛŒØ¨ Ù…Ù‡Ù… Ù†ÛŒØ³Øª)
```
---

### ØªØ±ØªÛŒØ¨ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ (Evaluation Order)

**Ù†Ú©ØªÙ‡ Ø­Ø³Ø§Ø³:** Ø¹Ø¨Ø§Ø±Ø§Øª Ø¨Ù‡ ØªØ±ØªÛŒØ¨ **Ù†ÙˆØ´ØªÙ‡ Ø´Ø¯Ù†** Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯ØŒ Ù†Ù‡ ØªØ±ØªÛŒØ¨ Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§

```csharp
int a = 0;
Foo(y: ++a, x: --a);   // Ø®Ø±ÙˆØ¬ÛŒ: 0, 1

// Ú†Ø±Ø§ØŸ
// 1. ++a Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÛŒâ€ŒØ´ÙˆØ¯ â†’ a = 1, y = 1
// 2. --a Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÛŒâ€ŒØ´ÙˆØ¯ â†’ a = 0, x = 0
// 3. Foo(x: 0, y: 1) ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ Ù…ÛŒâ€ŒØ´ÙˆØ¯
```
**ØªÙˆØµÛŒÙ‡:** Ø§Ø² Ú†Ù†ÛŒÙ† Ú©Ø¯Ù‡Ø§ÛŒÛŒ Ø®ÙˆØ¯Ø¯Ø§Ø±ÛŒ Ú©Ù†ÛŒØ¯!

---

### ØªØ±Ú©ÛŒØ¨ Positional Ùˆ Named

**Ù‚ÙˆØ§Ù†ÛŒÙ†:**

1. âœ… Positional Ù‚Ø¨Ù„ Ø§Ø² Named:
```csharp
Foo(1, y: 2);         // OK
```
2. âœ… Named Ø¯Ø± Ù…ÙˆÙ‚Ø¹ÛŒØª ØµØ­ÛŒØ­:
```csharp
Foo(x: 1, 2);         // OK (x Ù…ÙˆÙ‚Ø¹ÛŒØª Ø§ÙˆÙ„ØŒ 2 Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¯ÙˆÙ…)
```
3. âŒ Named Ø¯Ø± Ù…ÙˆÙ‚Ø¹ÛŒØª Ø§Ø´ØªØ¨Ø§Ù‡:
```csharp
Foo(y: 2, 1);         // âŒ Error: y Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¯ÙˆÙ… Ø§Ø³ØªØŒ Ù†Ù‡ Ø§ÙˆÙ„
```
---

## 3. ØªØ±Ú©ÛŒØ¨ Optional + Named

**Ú©Ø§Ø±Ø¨Ø±Ø¯ Ø§ØµÙ„ÛŒ:** Ø§Ø±Ø³Ø§Ù„ Ø§Ù†ØªØ®Ø§Ø¨ÛŒ Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§

```csharp
void Bar(int a = 0, int b = 0, int c = 0, int d = 0) 
{ 
Console.WriteLine($"{a}, {b}, {c}, {d}"); 
}

Bar(d: 3);           // 0, 0, 0, 3
Bar(b: 5, d: 7);     // 0, 5, 0, 7
Bar(c: 2);           // 0, 0, 2, 0
```
**Ù…Ø²ÛŒØª:** Ø®ÙˆØ§Ù†Ø§ÛŒÛŒ Ø¨Ø§Ù„Ø§ Ø¯Ø± Ù…ØªØ¯Ù‡Ø§ÛŒ Ú†Ù†Ø¯Ù¾Ø§Ø±Ø§Ù…ØªØ±ÛŒ

---

## 4. Ú©Ø§Ø±Ø¨Ø±Ø¯Ù‡Ø§ÛŒ ÙˆØ§Ù‚Ø¹ÛŒ

### COM APIs (Chapter 24)

```csharp
// Ø¨Ø¯ÙˆÙ† Named + Optional:
excelRange.Copy(Missing.Value, Missing.Value, Missing.Value, 
Missing.Value, Missing.Value, Missing.Value, 
Missing.Value);

// Ø¨Ø§ Named + Optional:
excelRange.Copy(Destination: targetRange);
```
---

## Ø®Ù„Ø§ØµÙ‡ Ø¬Ø¯ÙˆÙ„ Ù…Ù‚Ø§ÛŒØ³Ù‡

| ÙˆÛŒÚ˜Ú¯ÛŒ | Optional Parameters | Named Arguments |
|-------|-------------------|-----------------|
| **ØªØ¹Ø±ÛŒÙ** | Ù…Ù‚Ø¯Ø§Ø± Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ø¯Ø± ØªØ¹Ø±ÛŒÙ | Ù†Ø§Ù… Ø¯Ø± ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ |
| **ØªØ±ØªÛŒØ¨** | Ø¨Ø¹Ø¯ Ø§Ø² Ø§Ø¬Ø¨Ø§Ø±ÛŒ | Ù‡Ø± ØªØ±ØªÛŒØ¨ÛŒ |
| **Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ù…Ù‚Ø¯Ø§Ø±** | constant/default | - |
| **`ref`/`out`** | âŒ | âœ“ |
| **Recompilation** | Ù‡Ø± Ø¯Ùˆ assembly | - |
| **ØªØ±Ú©ÛŒØ¨** | Ø¨Ø§ Named Ø¨Ø³ÛŒØ§Ø± Ú©Ø§Ø±Ø¨Ø±Ø¯ÛŒ | Ø¨Ø§ Optional Ø¨Ø³ÛŒØ§Ø± Ú©Ø§Ø±Ø¨Ø±Ø¯ÛŒ |

---

## Ù†Ú©Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ Ø¨Ø±Ø§ÛŒ Ø­ÙØ¸

1. **Optional:** Ú©Ø§Ù…Ù¾Ø§ÛŒÙ„Ø± Ù…Ù‚Ø¯Ø§Ø± Ø±Ø§ Ø¯Ø± calling site Ø¬Ø§ÛŒÚ¯Ø°Ø§Ø±ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ø¯
2. **Recompilation:** ØªØºÛŒÛŒØ± Ù…Ù‚Ø¯Ø§Ø± Ù¾ÛŒØ´â€ŒÙØ±Ø¶ = Ù†ÛŒØ§Ø² Ø¨Ù‡ recompile Ù‡Ø± Ø¯Ùˆ assembly
3. **Evaluation order:** Named arguments Ø¨Ù‡ ØªØ±ØªÛŒØ¨ Ù†ÙˆØ´ØªØ§Ø±ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯
4. **Positional Ù‚Ø¨Ù„ Named:** Ù…Ú¯Ø± Named Ø¯Ø± Ù…ÙˆÙ‚Ø¹ÛŒØª ØµØ­ÛŒØ­ Ø¨Ø§Ø´Ø¯
5. **Ú©Ø§Ø±Ø¨Ø±Ø¯ Ø§ØµÙ„ÛŒ:** COM APIs Ùˆ Ù…ØªØ¯Ù‡Ø§ÛŒ Ú†Ù†Ø¯Ù¾Ø§Ø±Ø§Ù…ØªØ±ÛŒ



# Ù†Ú©Ø§Øª ÙÙ†ÛŒ - Ref Locals (Ù…Ø±Ø§Ø¬Ø¹ Ù…Ø­Ù„ÛŒ)

## ØªØ¹Ø±ÛŒÙ Ú©Ù„ÛŒØ¯ÛŒ

**Ref Local:** Ù…ØªØºÛŒØ± Ù…Ø­Ù„ÛŒ Ú©Ù‡ **Ø§Ø±Ø¬Ø§Ø¹ Ù…Ø³ØªÙ‚ÛŒÙ…** Ø¨Ù‡ Ø¹Ù†ØµØ± Ø¢Ø±Ø§ÛŒÙ‡ ÛŒØ§ field Ø§Ø³Øª (Ù†Ù‡ Ú©Ù¾ÛŒ)

---

## Ù…Ø«Ø§Ù„ Ù¾Ø§ÛŒÙ‡
```csharp
int[] numbers = { 0, 1, 2, 3, 4 };
ref int numRef = ref numbers[2];

numRef *= 10;
Console.WriteLine(numRef);      // 20
Console.WriteLine(numbers[2]);  // 20
```
**ØªÙˆØ¶ÛŒØ­:** `numRef` Ùˆ `numbers[2]` **Ù‡Ù…Ø§Ù† Ø¢Ø¯Ø±Ø³ Ø­Ø§ÙØ¸Ù‡** Ù‡Ø³ØªÙ†Ø¯ (aliasing)

---

## Ù…Ù‚Ø§ÛŒØ³Ù‡ Ø¨Ø§ Ù…ØªØºÛŒØ± Ø¹Ø§Ø¯ÛŒ

```csharp
// Ù…ØªØºÛŒØ± Ø¹Ø§Ø¯ÛŒ (Ú©Ù¾ÛŒ Ù…Ù‚Ø¯Ø§Ø±):
int normalVar = numbers[2];
normalVar *= 10;
Console.WriteLine(numbers[2]);  // 2 (ØªØºÛŒÛŒØ± Ù†Ú©Ø±Ø¯Ù‡)

// Ref Local (Ø§Ø±Ø¬Ø§Ø¹ Ù…Ø³ØªÙ‚ÛŒÙ…):
ref int refVar = ref numbers[2];
refVar *= 10;
Console.WriteLine(numbers[2]);  // 20 (ØªØºÛŒÛŒØ± Ú©Ø±Ø¯Ù‡)
```
---

## Ù…Ø­Ø¯ÙˆØ¯ÛŒØªâ€ŒÙ‡Ø§ÛŒ Target

**Ref local ÙÙ‚Ø· Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨Ù‡ Ø§ÛŒÙ†â€ŒÙ‡Ø§ Ø§Ø´Ø§Ø±Ù‡ Ú©Ù†Ø¯:**

| âœ… Ù…Ø¬Ø§Ø² | âŒ ØºÛŒØ±Ù…Ø¬Ø§Ø² |
|---------|-----------|
| Array element | Property |
| Field | - |
| Local variable | - |

```csharp
class MyClass
{
public int field;
public int Property { get; set; }
}

MyClass obj = new MyClass();

ref int r1 = ref obj.field;      // âœ… OK
ref int r2 = ref obj.Property;   // âŒ Error: Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ property Ø¨Ø§Ø´Ø¯
```
---

## Ú©Ø§Ø±Ø¨Ø±Ø¯ Ø§ØµÙ„ÛŒ

**Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù…ÛŒÚ©Ø±Ùˆ (Micro-optimization):**

1. **Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ú©Ù¾ÛŒ Value Typeâ€ŒÙ‡Ø§ÛŒ Ø¨Ø²Ø±Ú¯:**
```csharp
struct BigStruct { /* 100 bytes */ }

BigStruct[] array = new BigStruct[1000];
ref BigStruct item = ref array[500];  // Ø¨Ø¯ÙˆÙ† Ú©Ù¾ÛŒ
item.SomeField = 10;                  // ØªØºÛŒÛŒØ± Ù…Ø³ØªÙ‚ÛŒÙ… Ø¯Ø± Ø¢Ø±Ø§ÛŒÙ‡
```
2. **Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù‡Ù…Ø±Ø§Ù‡ Ref Returns (Ù…ÙˆØ¶ÙˆØ¹ Ø¨Ø¹Ø¯ÛŒ):**
```csharp
ref int GetElement(int[] arr, int index)
{
return ref arr[index];
}

ref int element = ref GetElement(numbers, 2);
element = 100;  // ØªØºÛŒÛŒØ± Ù…Ø³ØªÙ‚ÛŒÙ… numbers[2]
```
---

## Ù†Ú©Ø§Øª ÙÙ†ÛŒ Ù…Ù‡Ù…

### 1. Aliasing (Ù†Ø§Ù…â€ŒÚ¯Ø°Ø§Ø±ÛŒ Ù…Ø¬Ø¯Ø¯)

```csharp
int x = 5;
ref int y = ref x;
y = 10;
Console.WriteLine(x);  // 10 (x Ùˆ y ÛŒÚ©ÛŒ Ù‡Ø³ØªÙ†Ø¯)
```
### 2. Ref Reassignment (ØªØ®ØµÛŒØµ Ù…Ø¬Ø¯Ø¯ Ø§Ø±Ø¬Ø§Ø¹)

**Ù†Ú©ØªÙ‡:** Ù¾Ø³ Ø§Ø² ØªØ¹Ø±ÛŒÙØŒ ref local Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨Ù‡ target Ø¯ÛŒÚ¯Ø±ÛŒ Ø§Ø´Ø§Ø±Ù‡ Ú©Ù†Ø¯:

```csharp
int[] arr1 = { 1, 2 };
int[] arr2 = { 3, 4 };

ref int r = ref arr1[0];
r = ref arr2[0];  // âŒ Error: Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù† ref Ø±Ø§ ØªØºÛŒÛŒØ± Ø¯Ø§Ø¯
```
**Ø±Ø§Ù‡ Ø­Ù„:** Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² `ref` Ø¯Ø± Ø³Ù…Øª Ú†Ù¾ (C# 7.3+):
```csharp
ref int r = ref arr1[0];
r = ref arr2[0];  // âœ… OK Ø¯Ø± C# 7.3+
```
### 3. Lifetime Ùˆ Safety

**Ú©Ø§Ù…Ù¾Ø§ÛŒÙ„Ø± Ø¬Ù„ÙˆÛŒ dangling reference Ø±Ø§ Ù…ÛŒâ€ŒÚ¯ÛŒØ±Ø¯:**

```csharp
ref int GetDangling()
{
int local = 5;
return ref local;  // âŒ Error: local Ù¾Ø³ Ø§Ø² return Ø§Ø² Ø¨ÛŒÙ† Ù…ÛŒâ€ŒØ±ÙˆØ¯
}
```
---

## Ù…Ù‚Ø§ÛŒØ³Ù‡ Ø¨Ø§ Ø³Ø§ÛŒØ± Ù…ÙØ§Ù‡ÛŒÙ…

| Ù…ÙÙ‡ÙˆÙ… | Ú©Ù¾ÛŒ/Ø§Ø±Ø¬Ø§Ø¹ | ØªØºÛŒÛŒØ± Ø§ØµÙ„ | Ú©Ø§Ø±Ø¨Ø±Ø¯ |
|-------|-----------|----------|--------|
| **Ù…ØªØºÛŒØ± Ø¹Ø§Ø¯ÛŒ** | Ú©Ù¾ÛŒ | âŒ | Ø¹Ù…ÙˆÙ…ÛŒ |
| **`ref` parameter** | Ø§Ø±Ø¬Ø§Ø¹ | âœ… | Ø§Ø±Ø³Ø§Ù„ Ø¨Ù‡ Ù…ØªØ¯ |
| **`ref` local** | Ø§Ø±Ø¬Ø§Ø¹ | âœ… | Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù…Ø­Ù„ÛŒ |
| **Pointer (unsafe)** | Ø§Ø±Ø¬Ø§Ø¹ | âœ… | Ú©Ø¯ unsafe |

---

## Ø®Ù„Ø§ØµÙ‡ Ù†Ú©Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ

1. **ØªØ¹Ø±ÛŒÙ:** `ref int x = ref target;`
2. **Aliasing:** x Ùˆ target Ù‡Ù…Ø§Ù† Ø­Ø§ÙØ¸Ù‡ Ù‡Ø³ØªÙ†Ø¯
3. **Target Ù…Ø¬Ø§Ø²:** Array element, Field, Local variable
4. **Target ØºÛŒØ±Ù…Ø¬Ø§Ø²:** Property
5. **Ú©Ø§Ø±Ø¨Ø±Ø¯:** Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù…ÛŒÚ©Ø±Ùˆ + Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø¨Ø§ ref returns
6. **ÙˆÛŒÚ˜Ú¯ÛŒ C#:** Ø§Ø² C# 7
7. **Safety:** Ú©Ø§Ù…Ù¾Ø§ÛŒÙ„Ø± lifetime Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ø¯

---

## Ø²Ù…Ø§Ù† Ø§Ø³ØªÙØ§Ø¯Ù‡

**Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯:**
- Ø­Ù„Ù‚Ù‡â€ŒÙ‡Ø§ÛŒ performance-critical Ø±ÙˆÛŒ Ø¢Ø±Ø§ÛŒÙ‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø²Ø±Ú¯
- Ú©Ø§Ø± Ø¨Ø§ Value Typeâ€ŒÙ‡Ø§ÛŒ Ø¨Ø²Ø±Ú¯
- Ø§Ù„Ú¯ÙˆØ±ÛŒØªÙ…â€ŒÙ‡Ø§ÛŒ low-level

**Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù†Ú©Ù†ÛŒØ¯:**
- Ú©Ø¯ Ù…Ø¹Ù…ÙˆÙ„ÛŒ Ø±ÙˆØ²Ù…Ø±Ù‡ (over-engineering)
- Ø²Ù…Ø§Ù†ÛŒ Ú©Ù‡ Ø®ÙˆØ§Ù†Ø§ÛŒÛŒ Ù…Ù‡Ù…â€ŒØªØ± Ø§Ø² performance Ø§Ø³Øª


# Ù†Ú©Ø§Øª ÙÙ†ÛŒ - Optional Parameters, Named Arguments, Ùˆ Ref Returns

## 1. Optional Parameters (Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ Ø§Ø®ØªÛŒØ§Ø±ÛŒ)

### Ù‚ÙˆØ§Ù†ÛŒÙ† Ø§Ø³Ø§Ø³ÛŒ
```csharp
void Foo(int x = 23) 
{ 
Console.WriteLine(x); 
}

Foo();     // 23
Foo(15);   // 15
```
**Ù†Ú©Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ:**

| ÙˆÛŒÚ˜Ú¯ÛŒ | ØªÙˆØ¶ÛŒØ­ |
|-------|-------|
| **Ù…Ù‚Ø¯Ø§Ø± Ù¾ÛŒØ´â€ŒÙØ±Ø¶** | Ø¨Ø§ÛŒØ¯ Ø«Ø§Ø¨Øª (`const`) ÛŒØ§ `default` Ø¨Ø§Ø´Ø¯ |
| **Compile-time** | Ú©Ø§Ù…Ù¾Ø§ÛŒÙ„Ø± Ù…Ù‚Ø¯Ø§Ø± Ø±Ø§ Ø¯Ø± calling site Ù…ÛŒâ€ŒÙ†ÙˆÛŒØ³Ø¯ |
| **ØªØ±ØªÛŒØ¨** | Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ Ø§Ø¬Ø¨Ø§Ø±ÛŒ Ù‚Ø¨Ù„ Ø§Ø² Ø§Ø®ØªÛŒØ§Ø±ÛŒ |
| **Ù…Ø­Ø¯ÙˆØ¯ÛŒØª** | Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù† Ø¨Ø§ `ref`/`out` Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ø±Ø¯ |
| **`params`** | Ù‡Ù…ÛŒØ´Ù‡ Ø¢Ø®Ø±ÛŒÙ† Ù¾Ø§Ø±Ø§Ù…ØªØ± (Ø¨Ø¹Ø¯ Ø§Ø² optional) |

---

### Ù…Ù‚Ø§Ø¯ÛŒØ± Ù…Ø¬Ø§Ø² Ø¨Ø±Ø§ÛŒ Default Value

```csharp
void Method(
int a = 5,                          // âœ“ Ø«Ø§Ø¨Øª
string b = "test",                  // âœ“ Ø«Ø§Ø¨Øª
DateTime c = default,               // âœ“ default expression
Point d = new Point(),              // âœ“ parameterless constructor (value type)
object e = null                     // âœ“ null
)
```
---

### Ù‡Ø´Ø¯Ø§Ø± Ù…Ù‡Ù…: Recompilation

**Ø§Ú¯Ø± Ù…ØªØ¯ Ø¯Ø± assembly Ø¯ÛŒÚ¯Ø±ÛŒ ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ Ø´ÙˆØ¯:**

```csharp
// Assembly A:
public void Foo(int x = 23) { ... }

// Assembly B:
Foo();  // Ù…Ù‚Ø¯Ø§Ø± 23 Ø¯Ø± Assembly B Ú©Ø§Ù…Ù¾Ø§ÛŒÙ„ Ø´Ø¯Ù‡
```
**Ù…Ø´Ú©Ù„:** ØªØºÛŒÛŒØ± Ù…Ù‚Ø¯Ø§Ø± Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ù†ÛŒØ§Ø² Ø¨Ù‡ **recompile Ù‡Ø± Ø¯Ùˆ assembly** Ø¯Ø§Ø±Ø¯

---

### Ù…Ø«Ø§Ù„ ØªØ±Ú©ÛŒØ¨ÛŒ

```csharp
void Foo(int x = 0, int y = 0) 
{ 
Console.WriteLine(x + ", " + y); 
}

Foo(1);        // 1, 0 (x=1 ØµØ±ÛŒØ­ØŒ y=0 Ù¾ÛŒØ´â€ŒÙØ±Ø¶)
Foo();         // 0, 0 (Ù‡Ø± Ø¯Ùˆ Ù¾ÛŒØ´â€ŒÙØ±Ø¶)
Foo(5, 10);    // 5, 10 (Ù‡Ø± Ø¯Ùˆ ØµØ±ÛŒØ­)
```
---

## 2. Named Arguments (Ø¢Ø±Ú¯ÙˆÙ…Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ù†Ø§Ù…â€ŒØ¯Ø§Ø±)

### Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù¾Ø§ÛŒÙ‡

```csharp
void Foo(int x, int y) 
{ 
Console.WriteLine(x + ", " + y); 
}

Foo(x: 1, y: 2);    // 1, 2
Foo(y: 2, x: 1);    // 1, 2 (ØªØ±ØªÛŒØ¨ Ù…Ù‡Ù… Ù†ÛŒØ³Øª)
```
---

### ØªØ±Ú©ÛŒØ¨ Named Ùˆ Positional

```csharp
Foo(1, y: 2);      // âœ“ OK
Foo(x: 1, 2);      // âœ“ OK (Ø¢Ø±Ú¯ÙˆÙ…Ø§Ù† Ø¯ÙˆÙ… Ø¯Ø± Ù…ÙˆÙ‚Ø¹ÛŒØª ØµØ­ÛŒØ­)
Foo(y: 2, 1);      // âœ— Ø®Ø·Ø§ (y Ø¯Ø± Ù…ÙˆÙ‚Ø¹ÛŒØª Ø§ÙˆÙ„ Ù†ÛŒØ³Øª)
```
**Ù‚Ø§Ù†ÙˆÙ†:** Positional arguments Ø¨Ø§ÛŒØ¯ Ù‚Ø¨Ù„ Ø§Ø² Named Ø¨Ø§Ø´Ù†Ø¯ØŒ **Ù…Ú¯Ø±** Named Ø¯Ø± Ù…ÙˆÙ‚Ø¹ÛŒØª ØµØ­ÛŒØ­ Ø¨Ø§Ø´Ø¯

---

### ØªØ±ØªÛŒØ¨ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Expressions

```csharp
int a = 0;
Foo(y: ++a, x: --a);  // Ø®Ø±ÙˆØ¬ÛŒ: 0, 1
```
**ØªÙˆØ¶ÛŒØ­:** 
1. `++a` Ø§ÙˆÙ„ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÛŒâ€ŒØ´ÙˆØ¯ â†’ `a = 1`
2. `--a` Ø¨Ø¹Ø¯ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÛŒâ€ŒØ´ÙˆØ¯ â†’ `a = 0`

---

### Ú©Ø§Ø±Ø¨Ø±Ø¯ Ø§ØµÙ„ÛŒ: ØªØ±Ú©ÛŒØ¨ Ø¨Ø§ Optional Parameters

```csharp
void Bar(int a = 0, int b = 0, int c = 0, int d = 0) { ... }

Bar(d: 3);              // ÙÙ‚Ø· d Ø±Ø§ ØªÙ†Ø¸ÛŒÙ… Ú©Ù†
Bar(b: 5, d: 10);       // ÙÙ‚Ø· b Ùˆ d
```
**Ù…Ø²ÛŒØª:** Ø®ÙˆØ§Ù†Ø§ÛŒÛŒ Ùˆ ÙˆØ¶ÙˆØ­ Ø¯Ø± API Ù‡Ø§ÛŒ Ù¾ÛŒÚ†ÛŒØ¯Ù‡ (Ø®ØµÙˆØµØ§Ù‹ COM APIs)

---

## 3. Ref Returns (Ø¨Ø±Ú¯Ø´Øª Ø§Ø±Ø¬Ø§Ø¹)

### Ù…ÙÙ‡ÙˆÙ… Ú©Ù„ÛŒØ¯ÛŒ

**Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯Ù† Ø§Ø±Ø¬Ø§Ø¹ Ø¨Ù‡ Ù…ØªØºÛŒØ± (Ù†Ù‡ Ú©Ù¾ÛŒ Ù…Ù‚Ø¯Ø§Ø±):**

```csharp
class Program
{
static string x = "Old Value";

static ref string GetX() => ref x;  // Ø¨Ø±Ú¯Ø´Øª Ø§Ø±Ø¬Ø§Ø¹

static void Main()
{
ref string xRef = ref GetX();   // Ø¯Ø±ÛŒØ§ÙØª Ø§Ø±Ø¬Ø§Ø¹
xRef = "New Value";             // ØªØºÛŒÛŒØ± Ù…ØªØºÛŒØ± Ø§ØµÙ„ÛŒ
Console.WriteLine(x);           // New Value
}
}
```
---

### Ø­Ø§Ù„Øªâ€ŒÙ‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù Ø¯Ø±ÛŒØ§ÙØª

```csharp
// 1. Ø¯Ø±ÛŒØ§ÙØª Ø¨Ù‡ ØµÙˆØ±Øª ref:
ref string xRef = ref GetX();
xRef = "Changed";  // ØªØºÛŒÛŒØ± x Ø§ØµÙ„ÛŒ

// 2. Ø¯Ø±ÛŒØ§ÙØª Ø¨Ù‡ ØµÙˆØ±Øª value (Ø­Ø°Ù ref):
string localX = GetX();
localX = "Changed";  // ÙÙ‚Ø· localX ØªØºÛŒÛŒØ± Ù…ÛŒâ€ŒÚ©Ù†Ø¯
```
---

### Ref Return Ø¯Ø± Property

```csharp
static string x = "Old";

static ref string Prop => ref x;

// Ø§Ø³ØªÙØ§Ø¯Ù‡:
Prop = "New Value";  // ØªØºÛŒÛŒØ± Ù…Ø³ØªÙ‚ÛŒÙ… x (Ø¨Ø¯ÙˆÙ† set accessor)
```
**Ù†Ú©ØªÙ‡:** Property Ø¨Ù‡ ØµÙˆØ±Øª implicit Ù‚Ø§Ø¨Ù„ Ù†ÙˆØ´ØªÙ† Ø§Ø³Øª

---

### Ref Readonly (Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² ØªØºÛŒÛŒØ±)

```csharp
static ref readonly string Prop => ref x;

// Ø§Ø³ØªÙØ§Ø¯Ù‡:
string val = Prop;      // âœ“ OK (Ø®ÙˆØ§Ù†Ø¯Ù†)
Prop = "New";           // âœ— Ø®Ø·Ø§ (Ù†ÙˆØ´ØªÙ† Ù…Ù…Ù†ÙˆØ¹)
```
**Ú©Ø§Ø±Ø¨Ø±Ø¯:** Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¹Ù…Ù„Ú©Ø±Ø¯ + Ø­ÙØ§Ø¸Øª Ø§Ø² Ø¯Ø§Ø¯Ù‡

---

## Ù…Ù‚Ø§ÛŒØ³Ù‡ Ref Return Ø¨Ø§ Return Ø¹Ø§Ø¯ÛŒ

| ÙˆÛŒÚ˜Ú¯ÛŒ | Return Ø¹Ø§Ø¯ÛŒ | Ref Return |
|-------|-------------|-----------|
| **Ø¨Ø±Ú¯Ø´Øª** | Ú©Ù¾ÛŒ Ù…Ù‚Ø¯Ø§Ø± | Ø§Ø±Ø¬Ø§Ø¹ Ø¨Ù‡ Ù…ØªØºÛŒØ± |
| **ØªØºÛŒÛŒØ±** | ÙÙ‚Ø· local | ØªØºÛŒÛŒØ± Ù…ØªØºÛŒØ± Ø§ØµÙ„ÛŒ |
| **Ú©Ø§Ø±Ø§ÛŒÛŒ** | Ú©Ù¾ÛŒ overhead | Ø¨Ø¯ÙˆÙ† Ú©Ù¾ÛŒ |
| **Reference Types** | Ú©Ù¾ÛŒ Ø§Ø±Ø¬Ø§Ø¹ (32/64-bit) | Ø³ÙˆØ¯ Ú©Ù… |
| **Value Types** | Ú©Ù¾ÛŒ Ú©Ù„ struct | **Ø³ÙˆØ¯ Ø²ÛŒØ§Ø¯** (Ø¨Ø§ `readonly struct`) |

---

## Ú©Ø§Ø±Ø¨Ø±Ø¯Ù‡Ø§ÛŒ ÙˆØ§Ù‚Ø¹ÛŒ

### 1. Span<T> Ùˆ ReadOnlySpan<T>

```csharp
public ref T this[int index] => ref _array[index];
```
**Ù…Ø²ÛŒØª:** Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ø¯ÙˆÙ† Ú©Ù¾ÛŒ Ø¨Ù‡ Ø¹Ù†Ø§ØµØ± Ø¢Ø±Ø§ÛŒÙ‡

---

### 2. Readonly Struct (Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ)

```csharp
readonly struct BigStruct { /* 100 bytes */ }

static BigStruct data;

// Ø¨Ø¯ÙˆÙ† ref: Ú©Ù¾ÛŒ 100 Ø¨Ø§ÛŒØª
static BigStruct GetData() => data;

// Ø¨Ø§ ref readonly: ÙÙ‚Ø· Ø§Ø±Ø¬Ø§Ø¹ (4/8 Ø¨Ø§ÛŒØª)
static ref readonly BigStruct GetData() => ref data;
```
**Ø´Ø±Ø·:** struct Ø¨Ø§ÛŒØ¯ `readonly` Ø¨Ø§Ø´Ø¯ (ÙˆÚ¯Ø±Ù†Ù‡ defensive copy)

---

### Ù…Ø­Ø¯ÙˆØ¯ÛŒØª: Explicit Set Accessor

```csharp
// âœ— ØºÛŒØ±Ù…Ø¬Ø§Ø²:
static ref string Prop 
{ 
get => ref x;
set => x = value;  // Ø®Ø·Ø§ÛŒ Ú©Ø§Ù…Ù¾Ø§ÛŒÙ„
}
```
**Ø¯Ù„ÛŒÙ„:** Ref return Ø®ÙˆØ¯ implicit writable Ø§Ø³Øª

---

## Ø®Ù„Ø§ØµÙ‡ Ù†Ú©Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ

### Optional Parameters
- Ù…Ù‚Ø¯Ø§Ø± Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ø¨Ø§ÛŒØ¯ Ø«Ø§Ø¨Øª Ø¨Ø§Ø´Ø¯
- Compile-time baking (Ù†ÛŒØ§Ø² Ø¨Ù‡ recompilation)
- Ø§Ø¬Ø¨Ø§Ø±ÛŒ Ù‚Ø¨Ù„ Ø§Ø² Ø§Ø®ØªÛŒØ§Ø±ÛŒ

### Named Arguments
- Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø¨Ø§ Ù†Ø§Ù… (ØªØ±ØªÛŒØ¨ Ù…Ù‡Ù… Ù†ÛŒØ³Øª)
- Positional Ù‚Ø¨Ù„ Ø§Ø² Named (Ù…Ú¯Ø± Ø¯Ø± Ù…ÙˆÙ‚Ø¹ÛŒØª ØµØ­ÛŒØ­)
- Ú©Ø§Ø±Ø¨Ø±Ø¯: optional parameters Ùˆ COM APIs

### Ref Returns
- Ø¨Ø±Ú¯Ø´Øª Ø§Ø±Ø¬Ø§Ø¹ (Ù†Ù‡ Ú©Ù¾ÛŒ)
- `ref readonly` Ø¨Ø±Ø§ÛŒ Ø­ÙØ§Ø¸Øª
- Micro-optimization (Ù…ÙÛŒØ¯ Ø¨Ø±Ø§ÛŒ struct Ù‡Ø§ÛŒ Ø¨Ø²Ø±Ú¯)
- Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§ØµÙ„ÛŒ: `Span<T>` indexer



# Ù†Ú©Ø§Øª ÙÙ†ÛŒ - var Ùˆ Target-Typed new Expressions

## 1. var (Implicitly Typed Local Variables)

### ØªØ¹Ø±ÛŒÙ Ú©Ù„ÛŒØ¯ÛŒ

**`var`** = Ø­Ø°Ù Ù†ÙˆØ¹ Ù…ØªØºÛŒØ±Ø› Ú©Ø§Ù…Ù¾Ø§ÛŒÙ„Ø± Ø§Ø² Ø³Ù…Øª Ø±Ø§Ø³Øª Ù†ÙˆØ¹ Ø±Ø§ Ø§Ø³ØªÙ†Ø¨Ø§Ø· Ù…ÛŒâ€ŒÚ©Ù†Ø¯

---

### Ù…Ø«Ø§Ù„â€ŒÙ‡Ø§ÛŒ Ù¾Ø§ÛŒÙ‡
```csharp
var x = "hello";
var y = new System.Text.StringBuilder();
var z = (float)Math.PI;
```
**Ù…Ø¹Ø§Ø¯Ù„ Ø¯Ù‚ÛŒÙ‚:**

```csharp
string x = "hello";
System.Text.StringBuilder y = new System.Text.StringBuilder();
float z = (float)Math.PI;
```
---

### Ù†Ú©Ø§Øª ÙÙ†ÛŒ Ú©Ù„ÛŒØ¯ÛŒ

| ÙˆÛŒÚ˜Ú¯ÛŒ | ØªÙˆØ¶ÛŒØ­ |
|-------|-------|
| **Static Typing** | `var` â‰  dynamicØ› Ù†ÙˆØ¹ Ø¯Ø± compile-time ØªØ¹ÛŒÛŒÙ† Ù…ÛŒâ€ŒØ´ÙˆØ¯ |
| **Type Safety** | ØªØºÛŒÛŒØ± Ù†ÙˆØ¹ Ø¨Ø¹Ø¯ Ø§Ø² ØªØ¹Ø±ÛŒÙ Ù…Ù…Ù†ÙˆØ¹ Ø§Ø³Øª |
| **Ù…Ø­Ø¯ÙˆØ¯Ù‡** | ÙÙ‚Ø· Ø¨Ø±Ø§ÛŒ Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ Ù…Ø­Ù„ÛŒ |
| **Ø§Ù„Ø²Ø§Ù… initialization** | Ø¨Ø§ÛŒØ¯ Ù‡Ù…Ø²Ù…Ø§Ù† Ø¨Ø§ ØªØ¹Ø±ÛŒÙ Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ø´ÙˆØ¯ |

---

### Ù…Ø«Ø§Ù„ Static Typing

csharp
var x = 5;           // x Ø§Ø² Ù†ÙˆØ¹ int
x = "hello";         // âœ— Ø®Ø·Ø§ÛŒ compile-time

**ØªÙˆØ¶ÛŒØ­:** `x` Ø¨Ø±Ø§ÛŒ Ù‡Ù…ÛŒØ´Ù‡ `int` Ø§Ø³Øª (Ù†Ù‡ `dynamic`)

---

### Ù…Ø´Ú©Ù„ Ø®ÙˆØ§Ù†Ø§ÛŒÛŒ

```csharp
Random r = new Random();
var x = r.Next();    // â“ x Ú†Ù‡ Ù†ÙˆØ¹ÛŒ Ø§Ø³ØªØŸ
```
**Ù†Ú©ØªÙ‡ Ø¨Ù‡ÛŒÙ†Ù‡:** Ø§Ø² `var` Ø²Ù…Ø§Ù†ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯ Ú©Ù‡ Ù†ÙˆØ¹ Ø§Ø² Ú©Ø¯ ÙˆØ§Ø¶Ø­ Ø¨Ø§Ø´Ø¯:

```csharp
// âœ“ ÙˆØ§Ø¶Ø­:
var name = "John";
var builder = new StringBuilder();

// âœ— Ù…Ø¨Ù‡Ù…:
var result = CalculateSomething();
```
---

### Ø§Ø³ØªØ«Ù†Ø§: Anonymous Types

**ØªÙ†Ù‡Ø§ Ø¬Ø§ÛŒÛŒ Ú©Ù‡ `var` Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª:**

```csharp
var person = new { Name = "Ali", Age = 25 };
// Ù†ÙˆØ¹ anonymous Ø§Ø³ØªØŒ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù† ØµØ±ÛŒØ­ Ù†ÙˆØ´Øª
```
*(Ø¬Ø²Ø¦ÛŒØ§Øª Ø¯Ø± ÙØµÙ„ Anonymous Types)*

---

## 2. Target-Typed new Expressions (C# 9+)

### ØªØ¹Ø±ÛŒÙ Ú©Ù„ÛŒØ¯ÛŒ

**Ø­Ø°Ù ØªÚ©Ø±Ø§Ø± Ù†ÙˆØ¹ Ø¯Ø± Ø³Ù…Øª Ø±Ø§Ø³Øª `new`:**

```csharp
System.Text.StringBuilder sb1 = new();
System.Text.StringBuilder sb2 = new("Test");
```
**Ù…Ø¹Ø§Ø¯Ù„ Ø¯Ù‚ÛŒÙ‚:**

```csharp
System.Text.StringBuilder sb1 = new System.Text.StringBuilder();
System.Text.StringBuilder sb2 = new System.Text.StringBuilder("Test");
```
---

### Ù‚Ø§Ù†ÙˆÙ† Ø§ØµÙ„ÛŒ

**Ø´Ø±Ø·:** Ú©Ø§Ù…Ù¾Ø§ÛŒÙ„Ø± Ø¨Ø§ÛŒØ¯ Ø¨ØªÙˆØ§Ù†Ø¯ Ù†ÙˆØ¹ Ø±Ø§ **Ø¨Ø¯ÙˆÙ† Ø§Ø¨Ù‡Ø§Ù…** Ø§Ø² Ø³Ù…Øª Ú†Ù¾ Ø§Ø³ØªÙ†Ø¨Ø§Ø· Ú©Ù†Ø¯

---

### Ú©Ø§Ø±Ø¨Ø±Ø¯ Ø§ØµÙ„ÛŒ: Ø¬Ø¯Ø§Ø³Ø§Ø²ÛŒ Declaration Ùˆ Initialization

```csharp
class Foo
{
System.Text.StringBuilder sb;

public Foo(string initialValue)
{
sb = new(initialValue);  // âœ“ Ù†ÙˆØ¹ Ø§Ø² field Ù…Ø´Ø®Øµ Ø§Ø³Øª
}
}
```
**Ù…Ø²ÛŒØª:** Ø¨Ø¯ÙˆÙ† ØªÚ©Ø±Ø§Ø± Ù†Ø§Ù… Ø·ÙˆÙ„Ø§Ù†ÛŒ Ù†ÙˆØ¹

---

### Ù…Ø«Ø§Ù„â€ŒÙ‡Ø§ÛŒ Ø¨ÛŒØ´ØªØ±

```csharp
// 1. Ø¯Ø± Ù…ØªØ¯:
List<string> names = new();

// 2. Ø¯Ø± Ø¢Ø±Ø§ÛŒÙ‡:
Point[] points = new[]
{
new(1, 2),
new(3, 4)
};

// 3. Ø¯Ø± property:
class Person
{
public Address Address { get; set; } = new();
}

// 4. Ø¯Ø± return:
StringBuilder GetBuilder() => new("Initial");
```
---

### Ù…Ù‚Ø§ÛŒØ³Ù‡ var vs Target-Typed new

```csharp
// 1. Ø­Ø°Ù Ø§Ø² Ú†Ù¾ (var):
var sb = new System.Text.StringBuilder();

// 2. Ø­Ø°Ù Ø§Ø² Ø±Ø§Ø³Øª (target-typed new):
System.Text.StringBuilder sb = new();

// 3. Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù† Ù‡Ø± Ø¯Ùˆ Ø±Ø§ Ø­Ø°Ù Ú©Ø±Ø¯:
var sb = new();  // âœ— Ø®Ø·Ø§: Ù†ÙˆØ¹ Ù…Ø¨Ù‡Ù… Ø§Ø³Øª
```
---

## Ù…Ù‚Ø§ÛŒØ³Ù‡ Ú©Ù„ÛŒ

| Ø±ÙˆØ´ | Ø³Ù…Øª Ú†Ù¾ | Ø³Ù…Øª Ø±Ø§Ø³Øª | Ø®ÙˆØ§Ù†Ø§ÛŒÛŒ |
|-----|---------|----------|---------|
| **Ú©Ù„Ø§Ø³ÛŒÚ©** | `StringBuilder sb` | `new StringBuilder()` | ÙˆØ§Ø¶Ø­ Ø§Ù…Ø§ Ù¾Ø±Ø­Ø¬Ù… |
| **var** | `var sb` | `new StringBuilder()` | Ù…Ø®ØªØµØ±ØŒ Ù†ÙˆØ¹ Ø§Ø² Ø±Ø§Ø³Øª |
| **Target-typed** | `StringBuilder sb` | `new()` | Ù…Ø®ØªØµØ±ØŒ Ù†ÙˆØ¹ Ø§Ø² Ú†Ù¾ |

---

## ØªÙˆØµÛŒÙ‡â€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ù„ÛŒ

### Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² var

**âœ“ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯:**
- Ù†ÙˆØ¹ Ø§Ø² Ø³Ù…Øª Ø±Ø§Ø³Øª ÙˆØ§Ø¶Ø­ Ø§Ø³Øª
- Ù†Ø§Ù… Ù…ØªØºÛŒØ± Ú©Ø§ÙÛŒ ØªÙˆØ¶ÛŒØ­ Ù…ÛŒâ€ŒØ¯Ù‡Ø¯
- Anonymous types

**âœ— Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù†Ú©Ù†ÛŒØ¯:**
- ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ Ù…ØªØ¯ Ø¨Ø§ Ù†Ø§Ù… Ù…Ø¨Ù‡Ù…
- Ù†ÙˆØ¹ Ø§Ø² expression Ù…Ø´Ø®Øµ Ù†ÛŒØ³Øª
- Ø®ÙˆØ§Ù†Ø§ÛŒÛŒ Ú©Ø§Ù‡Ø´ Ù…ÛŒâ€ŒÛŒØ§Ø¨Ø¯

---

### Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Target-Typed new

**âœ“ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯:**
- Ù†ÙˆØ¹ Ø¯Ø± Ø³Ù…Øª Ú†Ù¾ Ù†ÙˆØ´ØªÙ‡ Ø´Ø¯Ù‡
- Field initialization Ø¯Ø± constructor
- Return statements

**âœ— Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù†Ú©Ù†ÛŒØ¯:**
- Ø§Ø¨Ù‡Ø§Ù… Ø¯Ø± Ù†ÙˆØ¹ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯
- Ù†ÙˆØ¹ Ø¯Ø± Ø³Ù…Øª Ú†Ù¾ Ù†ÛŒØ³Øª

---

## Ø®Ù„Ø§ØµÙ‡ Ù†Ú©Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ

### var
- Static typing (Ù†Ù‡ dynamic)
- ÙÙ‚Ø· Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ Ù…Ø­Ù„ÛŒ
- Ø§Ù„Ø²Ø§Ù… Ø¨Ù‡ initialization
- Ø§Ù„Ø²Ø§Ù…ÛŒ Ø¨Ø±Ø§ÛŒ anonymous types

### Target-Typed new
- C# 9+
- Ø­Ø°Ù ØªÚ©Ø±Ø§Ø± Ù†ÙˆØ¹
- Ø§Ø³ØªÙ†Ø¨Ø§Ø· Ø§Ø² Ø³Ù…Øª Ú†Ù¾
- Ù…ÙÛŒØ¯ Ø¯Ø± initialization Ø¬Ø¯Ø§Ú¯Ø§Ù†Ù‡

### Ù‡Ø± Ø¯Ùˆ
- Ú©Ø§Ù‡Ø´ Ú©Ø¯ boilerplate
- Ø­ÙØ¸ type safety
- Ø¨Ù‡Ø¨ÙˆØ¯ Ø®ÙˆØ§Ù†Ø§ÛŒÛŒ (Ø¯Ø± ØµÙˆØ±Øª Ø§Ø³ØªÙØ§Ø¯Ù‡ ØµØ­ÛŒØ­)


# Ù†Ú©Ø§Øª ÙÙ†ÛŒ - Expressions Ùˆ Operators Ø¯Ø± C#

## 1. ØªØ¹Ø±ÛŒÙ Expression (Ø¹Ø¨Ø§Ø±Øª)

**Expression = Ù‡Ø± Ú†ÛŒØ²ÛŒ Ú©Ù‡ ÛŒÚ© Ù…Ù‚Ø¯Ø§Ø± Ø±Ø§ Ù†Ø´Ø§Ù† Ù…ÛŒâ€ŒØ¯Ù‡Ø¯**

---

### Ø³Ø§Ø¯Ù‡â€ŒØªØ±ÛŒÙ† Ø§Ù†ÙˆØ§Ø¹ Expressions
```csharp
// 1. Constant (Ø«Ø§Ø¨Øª):
12

// 2. Variable (Ù…ØªØºÛŒØ±):
x

// 3. ØªØ±Ú©ÛŒØ¨ Ø¨Ø§ operator:
12 * 30
```
---

## 2. Ø³Ø§Ø®ØªØ§Ø± Operators (Ø¹Ù…Ù„Ú¯Ø±Ù‡Ø§)

### ÙØ±Ù…ÙˆÙ„ Ú©Ù„ÛŒ

$$\text{Operator} + \text{Operand(s)} \rightarrow \text{New Expression}$$

---

### Ù…Ø«Ø§Ù„ Ø³Ø§Ø®ØªÙ† Expression Ù¾ÛŒÚ†ÛŒØ¯Ù‡

```csharp
1 + (12 * 30)
```
**ØªØ­Ù„ÛŒÙ„:**
- `12` Ùˆ `30` â†’ operands
- `12 * 30` â†’ expression (Ø®ÙˆØ¯Ø´ operand Ø¨Ø±Ø§ÛŒ `+`)
- `1 + (...)` â†’ expression Ù†Ù‡Ø§ÛŒÛŒ

**Ù‚Ø§Ù†ÙˆÙ†:** Ù‡Ø± operand Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø®ÙˆØ¯Ø´ ÛŒÚ© expression Ø¨Ø§Ø´Ø¯ (Recursive)

---

## 3. Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Operators Ø¨Ø± Ø§Ø³Ø§Ø³ ØªØ¹Ø¯Ø§Ø¯ Operands

| Ù†ÙˆØ¹ | ØªØ¹Ø¯Ø§Ø¯ Operands | Ù…Ø«Ø§Ù„ |
|-----|----------------|------|
| **Unary** | 1 | `-x`, `!flag`, `++i` |
| **Binary** | 2 | `a + b`, `x * y` |
| **Ternary** | 3 | `condition ? a : b` |

---

### Ù†Ú©ØªÙ‡: Infix Notation

**Binary operators Ù‡Ù…ÛŒØ´Ù‡ Ø¨ÛŒÙ† Ø¯Ùˆ operand Ù‚Ø±Ø§Ø± Ù…ÛŒâ€ŒÚ¯ÛŒØ±Ù†Ø¯:**

```csharp
operand1  operator  operand2
   â†“         â†“         â†“
  12        *        30
```
---

## 4. Primary Expressions

**ØªØ¹Ø±ÛŒÙ:** Expressions Ø³Ø§Ø®ØªÙ‡ Ø´Ø¯Ù‡ Ø¨Ø§ operators Ù¾Ø§ÛŒÙ‡â€ŒØ§ÛŒ Ø²Ø¨Ø§Ù†

---

### Ù…Ø«Ø§Ù„ Ù¾ÛŒÚ†ÛŒØ¯Ù‡

```csharp
Math.Log(1)
```
**ØªØ­Ù„ÛŒÙ„:**
1. `Math.Log` â†’ **Member Lookup** (`.` operator)
2. `Log(1)` â†’ **Method Call** (`()` operator)

**Ù†ØªÛŒØ¬Ù‡:** Ø¯Ùˆ primary expression ØªØ±Ú©ÛŒØ¨ Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯

---

### Ø§Ù†ÙˆØ§Ø¹ Primary Operators

```csharp
// 1. Member Access (.):
object.Property
object.Method()

// 2. Method Call (()):
Console.WriteLine("test")

// 3. Array/Indexer ([]):
array[0]
list[index]

// 4. Cast ((...)):
(int)3.5

// 5. new:
new StringBuilder()
```
---

## 5. Void Expressions

**ØªØ¹Ø±ÛŒÙ:** Expression Ú©Ù‡ **Ù‡ÛŒÚ† Ù…Ù‚Ø¯Ø§Ø±ÛŒ Ù†Ø¯Ø§Ø±Ø¯**

---

### Ù…Ø«Ø§Ù„

```csharp
Console.WriteLine(1)
```
**ÙˆÛŒÚ˜Ú¯ÛŒ:** 
- Ù…ØªØ¯ Ø±Ø§ Ø§Ø¬Ø±Ø§ Ù…ÛŒâ€ŒÚ©Ù†Ø¯
- Ù…Ù‚Ø¯Ø§Ø±ÛŒ Ø¨Ø±Ù†Ù…ÛŒâ€ŒÚ¯Ø±Ø¯Ø§Ù†Ø¯ (`void`)

---

### Ù…Ø­Ø¯ÙˆØ¯ÛŒØª: Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù† Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Operand Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ø±Ø¯

```csharp
1 + Console.WriteLine(1)  // âœ— Ø®Ø·Ø§ÛŒ compile-time
```
**Ø¯Ù„ÛŒÙ„:** `Console.WriteLine` Ù…Ù‚Ø¯Ø§Ø±ÛŒ Ù†Ø¯Ø§Ø±Ø¯ Ú©Ù‡ Ø¨Ù‡ `1` Ø§Ø¶Ø§ÙÙ‡ Ø´ÙˆØ¯

---

### Ù…Ù‚Ø§ÛŒØ³Ù‡: Void vs Non-Void

```csharp
// âœ— Void expression:
var x = Console.WriteLine("Hi");  // Ø®Ø·Ø§

// âœ“ Non-void expression:
var x = Console.ReadLine();       // OK (Ø¨Ø±Ù…ÛŒâ€ŒÚ¯Ø±Ø¯Ø§Ù†Ø¯ string)
```
---

### Ø§Ø³ØªØ«Ù†Ø§: Expression Statement

**Void expressions Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ù†Ø¯ Ø¨Ù‡ ØµÙˆØ±Øª Ù…Ø³ØªÙ‚Ù„ Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† statement Ø¨Ø§Ø´Ù†Ø¯:**

```csharp
Console.WriteLine("Hello");  // âœ“ OK Ø¨Ù‡ ØªÙ†Ù‡Ø§ÛŒÛŒ
int x = 5;                   // âœ“ OK Ø¨Ù‡ ØªÙ†Ù‡Ø§ÛŒÛŒ
```
---

## Ø®Ù„Ø§ØµÙ‡ Ø³Ø§Ø®ØªØ§Ø± Expressions


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Expression Tree             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                     â”‚
â”‚    1    +    (12   *   30)          â”‚
â”‚    â†“         â†“         â†“            â”‚
â”‚  const    expression                â”‚
â”‚              â†“                      â”‚
â”‚           (12 * 30)                 â”‚
â”‚            â†“   â†“   â†“                â”‚
â”‚         const op const              â”‚
â”‚                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

---

## Ù†Ú©Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ

### Expressions
- Ù‡Ø± Ú†ÛŒØ²ÛŒ Ú©Ù‡ Ù…Ù‚Ø¯Ø§Ø± Ø¯Ø§Ø±Ø¯
- Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ù†Ø¯ ØªÙˆ Ø¯Ø± ØªÙˆ Ø¨Ø§Ø´Ù†Ø¯ (nested)
- Ø§Ø² operators Ø³Ø§Ø®ØªÙ‡ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯

### Operators
- **Unary:** 1 operand
- **Binary:** 2 operands (infix)
- **Ternary:** 3 operands

### Primary Expressions
- `.` (member access)
- `()` (method call)
- `[]` (indexer)
- `new` (instantiation)

### Void Expressions
- Ø¨Ø¯ÙˆÙ† Ù…Ù‚Ø¯Ø§Ø± Ø¨Ø±Ú¯Ø´ØªÛŒ
- Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ù†Ø¯ operand Ø¨Ø§Ø´Ù†Ø¯
- ÙÙ‚Ø· Ø¨Ù‡ ØµÙˆØ±Øª statement Ù…Ø³ØªÙ‚Ù„

---

## Ù…Ø«Ø§Ù„ Ø¬Ø§Ù…Ø¹

```csharp
// Expression Ù¾ÛŒÚ†ÛŒØ¯Ù‡:
int result = (Math.Sqrt(25) + 10) * 2;

// ØªØ­Ù„ÛŒÙ„:
// 1. Math.Sqrt(25)       â†’ primary (method call)
// 2. (... + 10)          â†’ binary (+)
// 3. (...) * 2           â†’ binary (*)
// 4. int result = ...    â†’ assignment
```
**Ù†ØªÛŒØ¬Ù‡ Ù†Ù‡Ø§ÛŒÛŒ:** Expression tree Ø¨Ø§ Ú†Ù†Ø¯ Ø³Ø·Ø­

---

## Ú©Ø§Ø±Ø¨Ø±Ø¯ Ø¹Ù…Ù„ÛŒ

### Ø®ÙˆØ§Ù†Ø§ÛŒÛŒ Ú©Ø¯

```csharp
// âœ— Ø¨Ø¯ (Ø¨ÛŒØ´ Ø§Ø² Ø­Ø¯ Ù¾ÛŒÚ†ÛŒØ¯Ù‡):
var x = (((a + b) * c) / d) - (e % f);

// âœ“ Ø®ÙˆØ¨ (ØªÙ‚Ø³ÛŒÙ… Ø´Ø¯Ù‡):
var sum = a + b;
var product = sum * c;
var quotient = product / d;
var remainder = e % f;
var x = quotient - remainder;
```
### Expression-Bodied Members

```csharp
// Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² expressions Ø¨Ø±Ø§ÛŒ Ø§Ø¹Ø¶Ø§:
int Square(int x) => x * x;
string Name => firstName + " " + lastName;
```

# Ù†Ú©Ø§Øª ÙÙ†ÛŒ - Assignment Expressions Ùˆ Operator Precedence

## 1. Assignment Expressions (Ø¹Ø¨Ø§Ø±Ø§Øª Ø§Ù†ØªØ³Ø§Ø¨)

### ØªØ¹Ø±ÛŒÙ Ú©Ù„ÛŒØ¯ÛŒ

**Assignment Ø¨Ø§ `=` ÛŒÚ© expression Ø§Ø³Øª (Ù†Ù‡ ÙÙ‚Ø· statement)**

---

### Ù…Ø«Ø§Ù„ Ù¾Ø§ÛŒÙ‡
```csharp
x = x * 5
```
**Ù†Ú©ØªÙ‡ Ù…Ù‡Ù…:** Ø§ÛŒÙ† ÛŒÚ© expression Ø§Ø³Øª Ú©Ù‡ **Ù…Ù‚Ø¯Ø§Ø± Ø¯Ø§Ø±Ø¯**

---

### ÙˆÛŒÚ˜Ú¯ÛŒ Ú©Ù„ÛŒØ¯ÛŒ: Assignment Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Expression

```csharp
y = 5 * (x = 2)
```
**ØªØ­Ù„ÛŒÙ„ Ú¯Ø§Ù…â€ŒØ¨Ù‡â€ŒÚ¯Ø§Ù…:**
1. `x = 2` Ø§Ø¬Ø±Ø§ Ù…ÛŒâ€ŒØ´ÙˆØ¯ â†’ `x` Ù…ÛŒâ€ŒØ´ÙˆØ¯ `2`
2. Assignment expression **Ù…Ù‚Ø¯Ø§Ø± `2` Ø±Ø§ Ø¨Ø±Ù…ÛŒâ€ŒÚ¯Ø±Ø¯Ø§Ù†Ø¯**
3. `y = 5 * 2` â†’ `y` Ù…ÛŒâ€ŒØ´ÙˆØ¯ `10`

**Ù†ØªÛŒØ¬Ù‡ Ù†Ù‡Ø§ÛŒÛŒ:**
- `x = 2`
- `y = 10`

---

### Ú©Ø§Ø±Ø¨Ø±Ø¯: Multiple Assignment (Ø§Ù†ØªØ³Ø§Ø¨ Ø²Ù†Ø¬ÛŒØ±Ù‡â€ŒØ§ÛŒ)

```csharp
a = b = c = d = 0
```
**Ú†Ú¯ÙˆÙ†Ú¯ÛŒ Ø§Ø¬Ø±Ø§ (Ø±Ø§Ø³Øª Ø¨Ù‡ Ú†Ù¾):**
```csharp
// Ù…Ø¹Ø§Ø¯Ù„:
d = 0;           // d = 0
c = (d = 0);     // c = 0
b = (c = 0);     // b = 0
a = (b = 0);     // a = 0
```
**Ù‚Ø§Ù†ÙˆÙ†:** Assignment Ø§Ø² Ø±Ø§Ø³Øª Ø¨Ù‡ Ú†Ù¾ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÛŒâ€ŒØ´ÙˆØ¯ (right-associative)

---

### Assignment â‰  Void Expression

```csharp
// âœ“ Ù…ÛŒâ€ŒØªÙˆØ§Ù† Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† operand Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ø±Ø¯:
int result = 5 * (x = 3);

// âœ— void expression Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ operand Ø¨Ø§Ø´Ø¯:
int result = 5 * Console.WriteLine(3);  // Ø®Ø·Ø§
```
---

## 2. Compound Assignment Operators (Ø¹Ù…Ù„Ú¯Ø±Ù‡Ø§ÛŒ Ø§Ù†ØªØ³Ø§Ø¨ ØªØ±Ú©ÛŒØ¨ÛŒ)

### ØªØ¹Ø±ÛŒÙ

**Shortcut Ø¨Ø±Ø§ÛŒ ØªØ±Ú©ÛŒØ¨ operator Ø¨Ø§ assignment:**

$$\text{x op= y} \equiv \text{x = x op y}$$

---

### Ù…Ø«Ø§Ù„â€ŒÙ‡Ø§ÛŒ Ù…ØªØ¯Ø§ÙˆÙ„

```csharp
x *= 2      // x = x * 2
x /= 2      // x = x / 2
x += 5      // x = x + 5
x -= 3      // x = x - 3
x %= 4      // x = x % 4
x &= 0xFF   // x = x & 0xFF
x |= 1      // x = x | 1
x ^= 1      // x = x ^ 1
x <<= 1     // x = x << 1  (shift left)
x >>= 1     // x = x >> 1  (shift right)
```
---

### Ù…Ù‚Ø§ÛŒØ³Ù‡ Syntax

```csharp
// âœ— Ø·ÙˆÙ„Ø§Ù†ÛŒ:
x = x * 2;

// âœ“ Ù…Ø®ØªØµØ±:
x *= 2;
```
---

### Ø§Ø³ØªØ«Ù†Ø§: Events (Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§)

**Ø¨Ø±Ø§ÛŒ eventsØŒ `+=` Ùˆ `-=` Ù…Ø¹Ù†ÛŒ Ø®Ø§ØµÛŒ Ø¯Ø§Ø±Ù†Ø¯:**

```csharp
button.Click += MyHandler;    // ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ add accessor
button.Click -= MyHandler;    // ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ remove accessor
```
**Ù†Ú©ØªÙ‡:** Ø§ÛŒÙ†â€ŒÙ‡Ø§ Ù…Ø³ØªÙ‚ÛŒÙ…Ø§Ù‹ Ø¨Ù‡ `x = x + ...` map Ù†Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯

*(Ø¬Ø²Ø¦ÛŒØ§Øª Ø¯Ø± ÙØµÙ„ 4 - Events)*

---

## 3. Operator Precedence (ØªÙ‚Ø¯Ù… Ø¹Ù…Ù„Ú¯Ø±Ù‡Ø§)

### ØªØ¹Ø±ÛŒÙ

**Precedence = ØªØ±ØªÛŒØ¨ Ø§Ø¬Ø±Ø§ÛŒ operators Ø²Ù…Ø§Ù†ÛŒ Ú©Ù‡ parentheses Ù†ÛŒØ³Øª**

---

### Ù…Ø«Ø§Ù„ Ú©Ù„Ø§Ø³ÛŒÚ©

```csharp
1 + 2 * 3
```
**Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ:**
```csharp
// * ØªÙ‚Ø¯Ù… Ø¨Ø§Ù„Ø§ØªØ±ÛŒ Ø¯Ø§Ø±Ø¯:
1 + (2 * 3)
// Ù†ØªÛŒØ¬Ù‡: 7
```
**Ø¯Ù„ÛŒÙ„:** Ø¶Ø±Ø¨ (`*`) Ù‚Ø¨Ù„ Ø§Ø² Ø¬Ù…Ø¹ (`+`) Ø§Ø¬Ø±Ø§ Ù…ÛŒâ€ŒØ´ÙˆØ¯

---

### Ø¬Ø¯ÙˆÙ„ Precedence (Ø¨Ø§Ù„Ø§ Ø¨Ù‡ Ù¾Ø§ÛŒÛŒÙ† = Ø¨ÛŒØ´ØªØ±ÛŒÙ† ØªÙ‚Ø¯Ù…)

| Ø³Ø·Ø­ | Ø¹Ù…Ù„Ú¯Ø±Ù‡Ø§ | Ù…Ø«Ø§Ù„ |
|-----|---------|------|
| **Ø¨Ø§Ù„Ø§ØªØ±ÛŒÙ†** | Primary (`x.y`, `x()`, `x[]`) | `Math.Sqrt(x)` |
| | Unary (`+`, `-`, `!`, `~`, `++`, `--`) | `-x`, `!flag` |
| | Multiplicative (`*`, `/`, `%`) | `x * y` |
| | Additive (`+`, `-`) | `x + y` |
| | Shift (`<<`, `>>`) | `x << 2` |
| | Relational (`<`, `>`, `<=`, `>=`) | `x < y` |
| | Equality (`==`, `!=`) | `x == y` |
| | Logical AND (`&`) | `x & y` |
| | Logical XOR (`^`) | `x ^ y` |
| | Logical OR (`|`) | `x | y` |
| | Conditional AND (`&&`) | `x && y` |
| | Conditional OR (`||`) | `x || y` |
| | Null-coalescing (`??`) | `x ?? y` |
| | Conditional (`? :`) | `x ? a : b` |
| **Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±ÛŒÙ†** | Assignment (`=`, `*=`, etc.) | `x = y` |

---

### Ù…Ø«Ø§Ù„ Ù¾ÛŒÚ†ÛŒØ¯Ù‡

```csharp
int result = 2 + 3 * 4 - 5 / 2;
```
**ØªØ±ØªÛŒØ¨ Ø§Ø¬Ø±Ø§:**
```csharp
// Ú¯Ø§Ù… 1: 3 * 4 = 12
int result = 2 + 12 - 5 / 2;

// Ú¯Ø§Ù… 2: 5 / 2 = 2
int result = 2 + 12 - 2;

// Ú¯Ø§Ù… 3: 2 + 12 = 14
int result = 14 - 2;

// Ú¯Ø§Ù… 4: 14 - 2 = 12
int result = 12;
```
---

## 4. Operator Associativity (Ø´Ø±Ú©Øªâ€ŒÙ¾Ø°ÛŒØ±ÛŒ)

### ØªØ¹Ø±ÛŒÙ

**Associativity = ØªØ±ØªÛŒØ¨ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ø²Ù…Ø§Ù†ÛŒ Ú©Ù‡ operators **Ù‡Ù…â€ŒØ³Ø·Ø­** Ù‡Ø³ØªÙ†Ø¯**

---

### Left-Associative (Ú†Ù¾ Ø¨Ù‡ Ø±Ø§Ø³Øª)

**Ø§Ú©Ø«Ø± binary operators:**

```csharp
8 / 4 / 2
```
**Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ:**
```csharp
// Ú†Ù¾ Ø¨Ù‡ Ø±Ø§Ø³Øª:
(8 / 4) / 2
// = 2 / 2
// = 1
```
---

### Right-Associative (Ø±Ø§Ø³Øª Ø¨Ù‡ Ú†Ù¾)

**Assignment Ùˆ Ú†Ù†Ø¯ operator Ø¯ÛŒÚ¯Ø±:**

```csharp
a = b = c = 5
```
**Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ:**
```csharp
// Ø±Ø§Ø³Øª Ø¨Ù‡ Ú†Ù¾:
a = (b = (c = 5))
```
---

### Ù…Ø«Ø§Ù„ ØªØ£Ø«ÛŒØ± Associativity

```csharp
// Left-associative:
8 / 4 / 2   // (8 / 4) / 2 = 1

// ØªØºÛŒÛŒØ± Ø¨Ø§ parentheses:
8 / (4 / 2) // 8 / 2 = 4
```
---

### Ø¬Ø¯ÙˆÙ„ Associativity

| Ù†ÙˆØ¹ | Operators | Ù…Ø«Ø§Ù„ |
|-----|-----------|------|
| **Left** | Ø§Ú©Ø«Ø± binary operators | `a - b - c` |
| | Arithmetic | `a + b + c` |
| | Logical | `a && b && c` |
| **Right** | Assignment | `a = b = c` |
| | Conditional | `a ? b : c ? d : e` |
| | Null-coalescing | `a ?? b ?? c` |

---

## 5. Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Parentheses (Ù¾Ø±Ø§Ù†ØªØ²Ù‡Ø§)

### Ù‚Ø§Ù†ÙˆÙ† Ø·Ù„Ø§ÛŒÛŒ

**Ù‡Ù†Ú¯Ø§Ù… Ø´Ú©ØŒ parentheses Ø¨Ú¯Ø°Ø§Ø±ÛŒØ¯**

---

### Ù…Ø«Ø§Ù„â€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ù„ÛŒ

```csharp
// âœ— Ù†ÛŒØ§Ø² Ø¨Ù‡ ÛŒØ§Ø¯Ø¢ÙˆØ±ÛŒ precedence:
if (x > 5 && y < 10 || z == 0)

// âœ“ ÙˆØ§Ø¶Ø­â€ŒØªØ±:
if ((x > 5 && y < 10) || (z == 0))
```
```csharp
// âœ— Ù…Ø¨Ù‡Ù…:
int result = a + b * c / d - e;

// âœ“ Ø±ÙˆØ´Ù†:
int result = a + ((b * c) / d) - e;
```
---

## Ø®Ù„Ø§ØµÙ‡ Ù†Ú©Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ

### Assignment Expressions
- **Ù…Ù‚Ø¯Ø§Ø± Ø¯Ø§Ø±Ù†Ø¯** (Ø¨Ø±Ú¯Ø´ØªÛŒ = Ù…Ù‚Ø¯Ø§Ø± assign Ø´Ø¯Ù‡)
- Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ù†Ø¯ nested Ø¨Ø§Ø´Ù†Ø¯
- Right-associative (Ø±Ø§Ø³Øª Ø¨Ù‡ Ú†Ù¾)
- Multiple assignment: `a = b = c = 0`

### Compound Assignment
- Shortcut: `x op= y` â‰¡ `x = x op y`
- Ø§Ø³ØªØ«Ù†Ø§: events (`+=`, `-=`)

### Precedence
- Multiplicative (`*`, `/`) > Additive (`+`, `-`)
- Unary > Binary
- Assignment Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±ÛŒÙ† ØªÙ‚Ø¯Ù…

### Associativity
- **Left:** Ø§Ú©Ø«Ø± operators (Ú†Ù¾ Ø¨Ù‡ Ø±Ø§Ø³Øª)
- **Right:** Assignment, Conditional, `??` (Ø±Ø§Ø³Øª Ø¨Ù‡ Ú†Ù¾)

### Best Practice
- Ø§Ø² parentheses Ø¨Ø±Ø§ÛŒ ÙˆØ¶ÙˆØ­ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯
- Associativity Ø±Ø§ Ø¨Ù‡ Ø®Ø§Ø·Ø± Ù†Ø³Ù¾Ø§Ø±ÛŒØ¯ØŒ explicit Ø¨Ø§Ø´ÛŒØ¯

---

## Ù…Ø«Ø§Ù„ Ø¬Ø§Ù…Ø¹

```csharp
int x = 5;
int y = 10;
int z;
```
// Expression Ù¾ÛŒÚ†ÛŒØ¯Ù‡:
z = x += y *= 2;

// ØªØ­Ù„ÛŒÙ„ (Ø±Ø§Ø³Øª Ø¨Ù‡ Ú†Ù¾):
// 1. y *= 2  â†’ y = y * 2 = 20
// 2. x += 20 â†’ x = x + 20 = 25
// 3. z = 25  â†’ z = 25

Console.WriteLine($"x={x}, y={y}, z={z}");
// Ø®Ø±ÙˆØ¬ÛŒ: x=25, y=20, z=25

**Ù†Ú©ØªÙ‡:** Ø¯Ø± Ú©Ø¯ ÙˆØ§Ù‚Ø¹ÛŒ Ø§Ø² Ú†Ù†ÛŒÙ† expressions Ù¾ÛŒÚ†ÛŒØ¯Ù‡â€ŒØ§ÛŒ Ø®ÙˆØ¯Ø¯Ø§Ø±ÛŒ Ú©Ù†ÛŒØ¯!




# Ù†Ú©Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ - Right-Associativity Ùˆ Operator Table

## Right-Associative Operators

### Ø¹Ù…Ù„Ú¯Ø±Ù‡Ø§ÛŒ Ø±Ø§Ø³Øª-Ø¨Ù‡-Ú†Ù¾

**4 Ø¯Ø³ØªÙ‡ Ø§ØµÙ„ÛŒ:**
1. **Assignment** (`=`, `+=`, `-=`, ...)
2. **Lambda** (`=>`)
3. **Null-coalescing** (`??`)
4. **Conditional** (`? :`)

---

### Ù…Ø«Ø§Ù„ Ú©Ù„Ø§Ø³ÛŒÚ©: Multiple Assignment
```csharp
x = y = 3;
```
**Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ (Ø±Ø§Ø³Øª â†’ Ú†Ù¾):**
```csharp
// Ú¯Ø§Ù… 1: y = 3 (Ø¨Ø±Ù…ÛŒâ€ŒÚ¯Ø±Ø¯Ø§Ù†Ø¯ 3)
// Ú¯Ø§Ù… 2: x = 3

**Ø¯Ù„ÛŒÙ„:** Ø¨Ø¯ÙˆÙ† right-associativity Ø§ÛŒÙ† Ú©Ø¯ compile Ù†Ù…ÛŒâ€ŒØ´Ø¯

---

## Operator Precedence Table (Ø®Ù„Ø§ØµÙ‡)

### Primary (Ø¨Ø§Ù„Ø§ØªØ±ÛŒÙ† ØªÙ‚Ø¯Ù…)

| Operator | Ù†Ø§Ù… | Ù…Ø«Ø§Ù„ | Overloadable |
|----------|-----|------|--------------|
| `.` | Member access | `x.y` | âŒ |
| `?.` `?[]` | Null-conditional | `x?.y` | âŒ |
| `!` (postfix) | Null-forgiving | `x!.y` | âŒ |
| `->` (unsafe) | Pointer access | `x->y` | âŒ |
| `()` | Function call | `f()` | âŒ |
| `[]` | Array/indexer | `a[0]` | âœ… (via indexer) |
| `++` `--` (postfix) | Post-inc/dec | `x++` | âœ… |
| `new` | Instance creation | `new Foo()` | âŒ |
| `stackalloc` | Stack allocation | `stackalloc(10)` | âŒ |
| `typeof` | Get type | `typeof(int)` | âŒ |
| `nameof` | Get name | `nameof(x)` | âŒ |
| `checked` | Overflow check ON | `checked(x)` | âŒ |
| `unchecked` | Overflow check OFF | `unchecked(x)` | âŒ |
| `default` | Default value | `default(int)` | âŒ |

---

## Ù†Ú©Ø§Øª Ù…Ù‡Ù…

### Null-Conditional Operators
```csharp
x?.Property      // Ø§Ú¯Ø± x null Ø¨Ø§Ø´Ø¯ØŒ null Ø¨Ø±Ù…ÛŒâ€ŒÚ¯Ø±Ø¯Ø§Ù†Ø¯
x?[0]           // safe array/indexer access
```
### Null-Forgiving Operator (C# 8+)
```csharp
string s = null!;  // Ø¨Ù‡ compiler Ù…ÛŒâ€ŒÚ¯ÙˆÛŒØ¯: Ø§Ø¹ØªÙ…Ø§Ø¯ Ú©Ù† null Ù†ÛŒØ³Øª
```
### Checked/Unchecked
```csharp
checked(int.MaxValue + 1)    // OverflowException Ù…ÛŒâ€ŒØ¯Ù‡Ø¯
unchecked(int.MaxValue + 1)  // Overflow Ø±Ø§ ignore Ù…ÛŒâ€ŒÚ©Ù†Ø¯
```
---

## Ù†Ú©ØªÙ‡ Ú©Ù„ÛŒØ¯ÛŒ: User-Overloadable

**ÙÙ‚Ø· Ø§ÛŒÙ† operators Ù‚Ø§Ø¨Ù„ overload Ù‡Ø³ØªÙ†Ø¯:**
- `++`, `--` (postfix/prefix)
- `[]` (Ø§Ø² Ø·Ø±ÛŒÙ‚ indexer)
- Ø¨Ù‚ÛŒÙ‡ Primary operators: **ØºÛŒØ±Ù‚Ø§Ø¨Ù„ overload**

*(Ø¬Ø²Ø¦ÛŒØ§Øª overloading Ø¯Ø± ØµÙØ­Ù‡ 256)*



# Ù†Ú©Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ - Null Operators

## 1. Null-Coalescing Operator (`??`)

### ØªØ¹Ø±ÛŒÙ

**`??` = "Ø§Ú¯Ø± Ú†Ù¾ null Ù†ÛŒØ³ØªØŒ Ø¢Ù† Ø±Ø§ Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø› ÙˆÚ¯Ø±Ù†Ù‡ Ù…Ù‚Ø¯Ø§Ø± Ø±Ø§Ø³Øª Ø±Ø§ Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†"**

---

### Syntax
```csharp
result = leftOperand ?? rightOperand
```
**Ù‚Ø§Ù†ÙˆÙ†:**
- Ø§Ú¯Ø± `leftOperand != null` â†’ Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯ `leftOperand`
- Ø§Ú¯Ø± `leftOperand == null` â†’ Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯ `rightOperand`

---

### Ù…Ø«Ø§Ù„ Ù¾Ø§ÛŒÙ‡

```csharp
string s1 = null;
string s2 = s1 ?? "nothing";
// s2 = "nothing" (Ú†ÙˆÙ† s1 = null)
```
```csharp
string s1 = "hello";
string s2 = s1 ?? "nothing";
// s2 = "hello" (Ú†ÙˆÙ† s1 != null)
```
---

### ÙˆÛŒÚ˜Ú¯ÛŒ Ù…Ù‡Ù…: Short-Circuiting

**Ø§Ú¯Ø± operand Ú†Ù¾ non-null Ø¨Ø§Ø´Ø¯ØŒ operand Ø±Ø§Ø³Øª Ø§ØµÙ„Ø§Ù‹ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯**

```csharp
string result = GetValue() ?? ExpensiveOperation();
// Ø§Ú¯Ø± GetValue() != nullØŒ ExpensiveOperation() Ø§Ø¬Ø±Ø§ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯
```
---

### Ú©Ø§Ø±Ø¨Ø±Ø¯ Ø¨Ø§ Nullable Value Types

```csharp
int? x = null;
int y = x ?? 0;  // y = 0

int? z = 5;
int w = z ?? 0;  // w = 5
```
---

## 2. Null-Coalescing Assignment Operator (`??=`)

### ØªØ¹Ø±ÛŒÙ (C# 8+)

**`??=` = "Ø§Ú¯Ø± Ú†Ù¾ null Ø§Ø³ØªØŒ Ù…Ù‚Ø¯Ø§Ø± Ø±Ø§Ø³Øª Ø±Ø§ Ø¨Ù‡ Ø¢Ù† assign Ú©Ù†"**

---

### Syntax

```csharp
variable ??= value;
```
**Ù…Ø¹Ø§Ø¯Ù„:**
```csharp
if (variable == null)
variable = value;
```
---

### Ù…Ø«Ø§Ù„ Ù¾Ø§ÛŒÙ‡

```csharp
string myVariable = null;
myVariable ??= "someDefault";
// myVariable Ø­Ø§Ù„Ø§ "someDefault" Ø§Ø³Øª
```
```csharp
string myVariable = "existing";
myVariable ??= "someDefault";
// myVariable Ù‡Ù…Ú†Ù†Ø§Ù† "existing" Ø§Ø³Øª (ØªØºÛŒÛŒØ± Ù†Ú©Ø±Ø¯)
```
---

### Ú©Ø§Ø±Ø¨Ø±Ø¯: Lazy Initialization

**Ù…ÙÛŒØ¯ Ø¨Ø±Ø§ÛŒ Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ ØªÙ†Ø¨Ù„ (lazy calculated properties):**

```csharp
private string _cachedData;

public string CachedData
{
get
{
_cachedData ??= LoadExpensiveData();
return _cachedData;
}
}
```
**Ù…Ø²ÛŒØª:** `LoadExpensiveData()` ÙÙ‚Ø· ÛŒÚ© Ø¨Ø§Ø± Ùˆ ÙÙ‚Ø· Ø²Ù…Ø§Ù†ÛŒ Ú©Ù‡ Ù„Ø§Ø²Ù… Ø§Ø³Øª Ø§Ø¬Ø±Ø§ Ù…ÛŒâ€ŒØ´ÙˆØ¯

---

## Ù…Ù‚Ø§ÛŒØ³Ù‡ `??` Ùˆ `??=`

| Operator | Ø¹Ù…Ù„Ú©Ø±Ø¯ | Ù…Ø«Ø§Ù„ | Ø§Ø³ØªÙØ§Ø¯Ù‡ |
|----------|--------|------|---------|
| `??` | **Ø®ÙˆØ§Ù†Ø¯Ù†** Ø¨Ø§ fallback | `x = a ?? b` | Ø¯Ø±ÛŒØ§ÙØª Ù…Ù‚Ø¯Ø§Ø± Ø¨Ø§ default |
| `??=` | **Ù†ÙˆØ´ØªÙ†** Ø´Ø±Ø·ÛŒ | `a ??= b` | Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ø§Ú¯Ø± null Ø§Ø³Øª |

---

## Ù…Ø«Ø§Ù„ Ø¬Ø§Ù…Ø¹

```csharp
// ?? : Ø®ÙˆØ§Ù†Ø¯Ù†
string name = GetUserName() ?? "Guest";

// ??= : Ù†ÙˆØ´ØªÙ†
string _cache = null;

string GetData()
{
// Ø§Ú¯Ø± _cache null Ø§Ø³ØªØŒ Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ú©Ù†
_cache ??= FetchDataFromDB();
return _cache;
}
```
---

## Ø®Ù„Ø§ØµÙ‡ Ù†Ú©Ø§Øª

### `??` (Null-Coalescing)
- **Short-circuiting** Ø¯Ø§Ø±Ø¯
- ÙÙ‚Ø· Ù…ÛŒâ€ŒØ®ÙˆØ§Ù†Ø¯ØŒ ØªØºÛŒÛŒØ± Ù†Ù…ÛŒâ€ŒØ¯Ù‡Ø¯
- Ø¨Ø§ Nullable Value Types Ú©Ø§Ø± Ù…ÛŒâ€ŒÚ©Ù†Ø¯
- Right-associative: `a ?? b ?? c`

### `??=` (Null-Coalescing Assignment)
- C# 8+
- ÙÙ‚Ø· Ø²Ù…Ø§Ù†ÛŒ assign Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ú©Ù‡ `null` Ø§Ø³Øª
- Ù…ÙÛŒØ¯ Ø¨Ø±Ø§ÛŒ **lazy initialization**
- Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ† pattern: `if (x == null) x = value;`

---

## Ù†Ú©ØªÙ‡ Ù¾ÛŒØ´Ø±ÙØªÙ‡: Chaining

```csharp
// Ø²Ù†Ø¬ÛŒØ±Ù‡ ??
string result = a ?? b ?? c ?? "default";
// Ø§ÙˆÙ„ÛŒÙ† non-null Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯

// ØªØ±Ú©ÛŒØ¨ Ø¨Ø§ ??=
_cache ??= _fallback ??= GetDefault();
```
*(Ø¬Ø²Ø¦ÛŒØ§Øª lazy evaluation Ø¯Ø± ØµÙØ­Ù‡ 233)*



# Ù†Ú©Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ - Null-Conditional Operator (`?.`)

## 1. ØªØ¹Ø±ÛŒÙ Ø§ØµÙ„ÛŒ

**`?.` = "Elvis Operator" ÛŒØ§ "Null-Conditional Operator"**

**Ø¹Ù…Ù„Ú©Ø±Ø¯:** "Ø§Ú¯Ø± operand Ú†Ù¾ null Ø§Ø³ØªØŒ Ú©Ù„ expression Ø±Ø§ null Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø› ÙˆÚ¯Ø±Ù†Ù‡ Ø¹Ù…Ù„ÛŒØ§Øª Ø±Ø§ Ø§Ù†Ø¬Ø§Ù… Ø¨Ø¯Ù‡"

---

## 2. Syntax Ù¾Ø§ÛŒÙ‡

### Ø¨Ø§ Method Call
```csharp
System.Text.StringBuilder sb = null;
string s = sb?.ToString();
// s = null (Ø¨Ø¯ÙˆÙ† Ø®Ø·Ø§!)
```
**Ù…Ø¹Ø§Ø¯Ù„:**
```csharp
string s = (sb == null ? null : sb.ToString());
```
**Ø¨Ø¯ÙˆÙ† `?.`:**
```csharp
string s = sb.ToString(); // âŒ NullReferenceException
```
---

### Ø¨Ø§ Indexer

```csharp
string[] words = null;
string word = words?[1];
// word = null (Ø¨Ø¯ÙˆÙ† Ø®Ø·Ø§!)
```
**Syntax:** `?[...]` Ø¨Ø±Ø§ÛŒ array/indexer access

---

## 3. Short-Circuiting

**Ø§Ú¯Ø± null Ø¨ÙˆØ¯ØŒ Ø¨Ù‚ÛŒÙ‡ expression Ø§Ø¬Ø±Ø§ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯**

```csharp
System.Text.StringBuilder sb = null;
string s = sb?.ToString().ToUpper();
// s = null (ToUpper() Ø§ØµÙ„Ø§Ù‹ ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯)
```
**Ù†Ú©ØªÙ‡ Ù…Ù‡Ù…:** ÙÙ‚Ø· `ToString()` conditional Ø§Ø³ØªØŒ `ToUpper()` Ø¹Ø§Ø¯ÛŒ Ø§Ø³Øª (Ø§Ù…Ø§ Ø§Ø¬Ø±Ø§ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ú†ÙˆÙ† expression Ù‚Ø¨Ù„ÛŒ null Ø´Ø¯)

---

## 4. Chaining (Ø²Ù†Ø¬ÛŒØ±Ù‡â€ŒØ§ÛŒ)

### Ú†Ù†Ø¯ Elvis Ù¾Ø´Øª Ø³Ø± Ù‡Ù…

```csharp
x?.y?.z
```
**Ù…Ø¹Ø§Ø¯Ù„:**
```csharp
x == null ? null 
: (x.y == null ? null : x.y.z)
```
**Ù‚Ø§Ù†ÙˆÙ†:** ÙÙ‚Ø· Ø¬Ø§ÛŒÛŒ Ú©Ù‡ Ø§Ø­ØªÙ…Ø§Ù„ null Ø¨ÙˆØ¯Ù† Ù‡Ø³Øª Ø§Ø² `?.` Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†

---

### Ù…Ø«Ø§Ù„ Ø¹Ù…Ù„ÛŒ

```csharp
// Ø§Ú¯Ø± x ÛŒØ§ x.y Ù…Ù…Ú©Ù† Ø§Ø³Øª null Ø¨Ø§Ø´Ø¯:
x?.y?.z

// Ø§Ú¯Ø± ÙÙ‚Ø· x Ù…Ù…Ú©Ù† Ø§Ø³Øª null Ø¨Ø§Ø´Ø¯:
x?.y.z

// Ø§Ú¯Ø± x Ùˆ y.z Ù…Ù…Ú©Ù† Ø§Ø³Øª null Ø¨Ø§Ø´Ù†Ø¯:
x?.y.z?.w
```
---

## 5. Ù…Ø´Ú©Ù„ Type Mismatch

### Ù…Ø´Ú©Ù„: Ù†ØªÛŒØ¬Ù‡ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ null Ø¨Ù¾Ø°ÛŒØ±Ø¯

```csharp
System.Text.StringBuilder sb = null;
int length = sb?.ToString().Length;
// âŒ Ø®Ø·Ø§ÛŒ Compile: int Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ null Ø¨Ø§Ø´Ø¯
```
### Ø±Ø§Ù‡â€ŒØ­Ù„: Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Nullable Value Type

```csharp
int? length = sb?.ToString().Length;
// âœ… OK: int? Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ null Ø¨Ø§Ø´Ø¯
```
---

## 6. Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø¨Ø§ Void Methods

```csharp
someObject?.SomeVoidMethod();
```
**Ø±ÙØªØ§Ø±:**
- Ø§Ú¯Ø± `someObject == null` â†’ "no-operation" (Ù‡ÛŒÚ† Ø§ØªÙØ§Ù‚ÛŒ Ù†Ù…ÛŒâ€ŒØ§ÙØªØ¯)
- Ø§Ú¯Ø± `someObject != null` â†’ Ù…ØªØ¯ Ø§Ø¬Ø±Ø§ Ù…ÛŒâ€ŒØ´ÙˆØ¯

**Ù…Ø²ÛŒØª:** Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² `NullReferenceException`

---

## 7. ØªØ±Ú©ÛŒØ¨ Ø¨Ø§ Ø³Ø§ÛŒØ± Operators

### Ø¨Ø§ Null-Coalescing (`??`)

```csharp
System.Text.StringBuilder sb = null;
string s = sb?.ToString() ?? "nothing";
// s = "nothing"
```
**Ù…Ø±Ø§Ø­Ù„:**
1. `sb?.ToString()` â†’ `null` (Ú†ÙˆÙ† sb = null)
2. `null ?? "nothing"` â†’ `"nothing"`

---

### Ù…Ø«Ø§Ù„ Ù¾ÛŒÚ†ÛŒØ¯Ù‡â€ŒØªØ±

```csharp
int length = obj?.Property?.Items?[0]?.Name?.Length ?? 0;
```
**Ù…Ø±Ø§Ø­Ù„:**
- Ø§Ú¯Ø± Ù‡Ø± Ú©Ø¯Ø§Ù… null Ø¨ÙˆØ¯ â†’ Ù†ØªÛŒØ¬Ù‡ `null`
- Ø§Ú¯Ø± Ù‡Ù…Ù‡ non-null Ø¨ÙˆØ¯Ù†Ø¯ â†’ `Length` Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯
- Ø¯Ø± Ù†Ù‡Ø§ÛŒØª Ø§Ú¯Ø± `null` Ø´Ø¯ â†’ `??` Ù…Ù‚Ø¯Ø§Ø± `0` Ø±Ø§ Ù…ÛŒâ€ŒØ¯Ù‡Ø¯

---

## 8. Type Members Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ø´Ø¯Ù‡

**`?.` Ø¨Ø§ Ø§ÛŒÙ† Ù…ÙˆØ§Ø±Ø¯ Ú©Ø§Ø± Ù…ÛŒâ€ŒÚ©Ù†Ø¯:**

| Type Member | Syntax | Ù…Ø«Ø§Ù„ |
|-------------|--------|------|
| **Method** | `?.Method()` | `obj?.ToString()` |
| **Property** | `?.Property` | `obj?.Name` |
| **Field** | `?.field` | `obj?.data` |
| **Indexer** | `?[index]` | `array?[0]` |

---

## 9. Ø¬Ø¯ÙˆÙ„ Ù…Ù‚Ø§ÛŒØ³Ù‡

| Operator | Ù†Ø§Ù… | Ø§Ø³ØªÙØ§Ø¯Ù‡ | Ù†ØªÛŒØ¬Ù‡ Ø§Ú¯Ø± null |
|----------|-----|---------|---------------|
| `.` | Standard | `obj.Method()` | âŒ Exception |
| `?.` | Null-Conditional | `obj?.Method()` | âœ… `null` |
| `??` | Null-Coalescing | `a ?? b` | Ù…Ù‚Ø¯Ø§Ø± `b` |
| `??=` | Null-Coalescing Assignment | `a ??= b` | `a = b` |

---

## 10. Ø®Ù„Ø§ØµÙ‡ Ù†Ú©Ø§Øª

### âœ… Ù…Ø²Ø§ÛŒØ§
- **Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² `NullReferenceException`**
- **Ú©Ø¯ ØªÙ…ÛŒØ²ØªØ±** (Ø¨Ø¯ÙˆÙ† `if (x != null)`)
- **Short-circuiting** Ø¯Ø§Ø±Ø¯
- Ø¨Ø§ **`??`** ØªØ±Ú©ÛŒØ¨ Ø¹Ø§Ù„ÛŒ Ù…ÛŒâ€ŒØ´ÙˆØ¯

### âš ï¸ Ù†Ú©Ø§Øª
- Ù†ØªÛŒØ¬Ù‡ Ø¨Ø§ÛŒØ¯ **nullable** Ø¨Ø§Ø´Ø¯ (Ø¨Ø±Ø§ÛŒ value types Ø§Ø² `int?` Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†)
- ÙÙ‚Ø· Ø¬Ø§ÛŒÛŒ Ú©Ù‡ Ø§Ø­ØªÙ…Ø§Ù„ null Ù‡Ø³Øª Ø§Ø² `?.` Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†
- Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ **Ø²Ù†Ø¬ÛŒØ±Ù‡â€ŒØ§ÛŒ** (`?.?.?`) Ø¨Ø§Ø´Ø¯

### ğŸ”— ØªØ±Ú©ÛŒØ¨â€ŒÙ‡Ø§ÛŒ Ù…Ø¹Ù…ÙˆÙ„

```csharp
// Pattern 1: Safe access + fallback
string name = user?.Profile?.Name ?? "Anonymous";

// Pattern 2: Safe method call
user?.UpdateLastLogin();

// Pattern 3: Safe indexer
var item = collection?[index]?.Property;

// Pattern 4: Safe length check
int? count = list?.Count;
```
---

## Ù…Ø«Ø§Ù„ Ø¬Ø§Ù…Ø¹

```csharp
public class Example
{
public string GetUserEmail(User user)
{
// Ø¨Ø¯ÙˆÙ† null-conditional (Ø®Ø·Ø±Ù†Ø§Ú©):
// return user.Profile.ContactInfo.Email; // Ù…Ù…Ú©Ù† Ø§Ø³Øª NullReferenceException Ø¨Ø¯Ù‡Ø¯

// Ø¨Ø§ null-conditional (Ø§Ù…Ù†):
return user?.Profile?.ContactInfo?.Email ?? "no-email@example.com";
}

public void LogAction(Logger logger)
{
// void method Ø¨Ø§ null-conditional:
logger?.Log("Action performed");
// Ø§Ú¯Ø± logger = nullØŒ Ù‡ÛŒÚ† Ø§ØªÙØ§Ù‚ÛŒ Ù†Ù…ÛŒâ€ŒØ§ÙØªØ¯
}
}
```
*(Ø§Ø¯Ø§Ù…Ù‡ Nullable Value Types Ø¯Ø± ØµÙØ­Ù‡ 210)*



# Ù†Ú©Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ - Statements Ùˆ Declaration Statements

## 1. ØªØ¹Ø±ÛŒÙ Statement

**Statement = Ø¯Ø³ØªÙˆØ± Ù‚Ø§Ø¨Ù„ Ø§Ø¬Ø±Ø§**

**ÙˆÛŒÚ˜Ú¯ÛŒ:** Statements Ø¨Ù‡ ØªØ±ØªÛŒØ¨ Ù…ØªÙ†ÛŒ (textual order) Ú©Ù‡ Ù†ÙˆØ´ØªÙ‡ Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯ Ø§Ø¬Ø±Ø§ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯

---

## 2. Statement Block

### ØªØ¹Ø±ÛŒÙ

**Statement Block = Ù…Ø¬Ù…ÙˆØ¹Ù‡â€ŒØ§ÛŒ Ø§Ø² statements Ø¨ÛŒÙ† `{}`**
```csharp
{
statement1;
statement2;
statement3;
}
```
**Ú©Ø§Ø±Ø¨Ø±Ø¯:** ØªØ¹Ø±ÛŒÙ Ù…Ø­Ø¯ÙˆØ¯Ù‡ (scope) Ø¨Ø±Ø§ÛŒ:
- Methods
- Loops
- Conditional statements
- Try-catch blocks

---

## 3. Declaration Statements

### 3.1 Variable Declaration

**ØªØ¹Ø±ÛŒÙ Ù…ØªØºÛŒØ± Ø¬Ø¯ÛŒØ¯ (Ø¨Ø§ ÛŒØ§ Ø¨Ø¯ÙˆÙ† Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ø§ÙˆÙ„ÛŒÙ‡)**

#### Syntax Ù¾Ø§ÛŒÙ‡

```csharp
type variableName = initialValue;
```
#### Ù…Ø«Ø§Ù„â€ŒÙ‡Ø§

```csharp
string someWord = "rosebud";
int someNumber = 42;
bool rich = true;
```
---

### 3.2 Multiple Variable Declaration

**ØªØ¹Ø±ÛŒÙ Ú†Ù†Ø¯ Ù…ØªØºÛŒØ± Ø§Ø² ÛŒÚ© Ù†ÙˆØ¹ Ø¯Ø± ÛŒÚ© Ø®Ø·**

#### Syntax

```csharp
type var1 = value1, var2 = value2, var3;
```
#### Ù…Ø«Ø§Ù„

```csharp
bool rich = true, famous = false;
```
```csharp
int x = 5, y = 10, z;  // z Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ù†Ø´Ø¯Ù‡ (default = 0)
```
**Ù†Ú©ØªÙ‡:** Ù‡Ù…Ù‡ Ù…ØªØºÛŒØ±Ù‡Ø§ Ø¨Ø§ÛŒØ¯ Ø§Ø² ÛŒÚ© Ù†ÙˆØ¹ Ø¨Ø§Ø´Ù†Ø¯

---

### 3.3 Constant Declaration

**ØªØ¹Ø±ÛŒÙ Ø«Ø§Ø¨Øª (ØºÛŒØ±Ù‚Ø§Ø¨Ù„ ØªØºÛŒÛŒØ± Ù¾Ø³ Ø§Ø² Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ)**

#### Syntax

```csharp
const type constantName = value;
```
#### ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ `const`

| ÙˆÛŒÚ˜Ú¯ÛŒ | ØªÙˆØ¶ÛŒØ­ |
|-------|-------|
| **Immutable** | Ø¨Ø¹Ø¯ Ø§Ø² ØªØ¹Ø±ÛŒÙ ØªØºÛŒÛŒØ± Ù†Ù…ÛŒâ€ŒÚ©Ù†Ø¯ |
| **Compile-time** | Ù…Ù‚Ø¯Ø§Ø± Ø¨Ø§ÛŒØ¯ Ø¯Ø± Ø²Ù…Ø§Ù† compile Ù…Ø¹Ù„ÙˆÙ… Ø¨Ø§Ø´Ø¯ |
| **Initialization required** | **Ø¨Ø§ÛŒØ¯** Ù‡Ù†Ú¯Ø§Ù… ØªØ¹Ø±ÛŒÙ Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ø´ÙˆØ¯ |

---

#### Ù…Ø«Ø§Ù„ ØµØ­ÛŒØ­

```csharp
const double c = 2.99792458E08;  // Ø³Ø±Ø¹Øª Ù†ÙˆØ±
const int MaxValue = 100;
const string AppName = "MyApp";
```
#### Ù…Ø«Ø§Ù„ Ø®Ø·Ø§

```csharp
const double c = 2.99792458E08;
c += 10;  // âŒ Compile-time Error: Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù† const Ø±Ø§ ØªØºÛŒÛŒØ± Ø¯Ø§Ø¯
```
```csharp
const int x;  // âŒ Error: Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª
x = 10;
```
```csharp
const DateTime now = DateTime.Now;  // âŒ Error: Ù…Ù‚Ø¯Ø§Ø± Ø¨Ø§ÛŒØ¯ compile-time Ø¨Ø§Ø´Ø¯
```
---

## 4. Ù…Ù‚Ø§ÛŒØ³Ù‡ Variable vs Constant

| ÙˆÛŒÚ˜Ú¯ÛŒ | Variable | Constant |
|-------|----------|----------|
| **Ù‚Ø§Ø¨Ù„ÛŒØª ØªØºÛŒÛŒØ±** | âœ… Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ ØªØºÛŒÛŒØ± Ú©Ù†Ø¯ | âŒ ØºÛŒØ±Ù‚Ø§Ø¨Ù„ ØªØºÛŒÛŒØ± |
| **Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ø§ÙˆÙ„ÛŒÙ‡** | Ø§Ø®ØªÛŒØ§Ø±ÛŒ | **Ø§Ù„Ø²Ø§Ù…ÛŒ** |
| **Ø²Ù…Ø§Ù† Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ** | Runtime | **Compile-time** |
| **Keyword** | - | `const` |
| **Performance** | Runtime access | Inline Ø´Ø¯Ù‡ (Ø³Ø±ÛŒØ¹â€ŒØªØ±) |

---

## 5. Ø®Ù„Ø§ØµÙ‡ Syntax

### Variable Declaration Patterns

```csharp
// 1. ØªØ¹Ø±ÛŒÙ Ø³Ø§Ø¯Ù‡
int x = 5;

// 2. Ø¨Ø¯ÙˆÙ† Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ (default value Ù…ÛŒâ€ŒÚ¯ÛŒØ±Ø¯)
int y;

// 3. Ú†Ù†Ø¯ Ù…ØªØºÛŒØ± Ù‡Ù…Ø²Ù…Ø§Ù†
int a = 1, b = 2, c;

// 4. Ø¨Ø§ type inference
var name = "John";  // string

// 5. Ø¨Ø§ target-typed new (C# 9+)
StringBuilder sb = new();
```
### Constant Declaration Patterns

```csharp
// 1. Ø¹Ø¯Ø¯
const int MaxRetries = 3;

// 2. Ø±Ø´ØªÙ‡
const string ConnectionString = "Server=...";

// 3. Ù…Ø­Ø§Ø³Ø¨Ù‡ compile-time
const double Pi = 3.14159;
const double TwoPi = Pi * 2;

// 4. Ø¨Ø§ expression
const int HoursInDay = 24;
const int MinutesInDay = HoursInDay * 60;
```
---

## 6. Ù†Ú©Ø§Øª Ù…Ù‡Ù…

### âœ… Best Practices

1. **Ø§Ø² `const` Ø¨Ø±Ø§ÛŒ Ù…Ù‚Ø§Ø¯ÛŒØ± Ø«Ø§Ø¨Øª ÙˆØ§Ù‚Ø¹ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†:**
```csharp
   const int DaysInWeek = 7;
```




# Ù†Ú©Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ - Local Variables Ùˆ Expression Statements

## 1. Local Variables - Scope

### ØªØ¹Ø±ÛŒÙ Scope

**Scope = Ù…Ø­Ø¯ÙˆØ¯Ù‡â€ŒØ§ÛŒ Ú©Ù‡ Ù…ØªØºÛŒØ± Ø¯Ø± Ø¢Ù† Ù‚Ø§Ø¨Ù„ Ø¯Ø³ØªØ±Ø³ÛŒ Ø§Ø³Øª**

**Ù‚Ø§Ù†ÙˆÙ† Ø§ØµÙ„ÛŒ:** Scope ÛŒÚ© local variable ÛŒØ§ local constant Ø¯Ø± Ú©Ù„ block Ø¬Ø§Ø±ÛŒ Ú¯Ø³ØªØ±Ø´ Ù…ÛŒâ€ŒÛŒØ§Ø¨Ø¯

---

### 1.1 Ù‚ÙˆØ§Ù†ÛŒÙ† Scope

#### Ù‚Ø§Ù†ÙˆÙ† 1: Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù† Ù…ØªØºÛŒØ± Ù‡Ù…Ù†Ø§Ù… Ø¯Ø± Ù‡Ù…Ø§Ù† block ØªØ¹Ø±ÛŒÙ Ú©Ø±Ø¯
```csharp
int x;
{
int y;
int x;  // âŒ Error: x Ù‚Ø¨Ù„Ø§Ù‹ ØªØ¹Ø±ÛŒÙ Ø´Ø¯Ù‡
}
```
---

#### Ù‚Ø§Ù†ÙˆÙ† 2: Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù† Ù…ØªØºÛŒØ± Ù‡Ù…Ù†Ø§Ù… Ø¯Ø± nested block ØªØ¹Ø±ÛŒÙ Ú©Ø±Ø¯

```csharp
int x;
{
int x;  // âŒ Error: x Ø¯Ø± block Ø¨ÛŒØ±ÙˆÙ†ÛŒ ØªØ¹Ø±ÛŒÙ Ø´Ø¯Ù‡
}
```
**ØªÙØ§ÙˆØª Ø¨Ø§ C++:** Ø¯Ø± C++ Ø§ÛŒÙ† Ù…Ø¬Ø§Ø² Ø§Ø³Øª (shadowing)

---

#### Ù‚Ø§Ù†ÙˆÙ† 3: Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ blocks Ù…Ø®ØªÙ„Ù Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ù†Ø¯ Ù‡Ù…Ù†Ø§Ù… Ø¨Ø§Ø´Ù†Ø¯

```csharp
{
int y;
}
{
int y;  // âœ… OK: y Ø¯Ø± scope Ù†ÛŒØ³Øª
}
```
**Ø¯Ù„ÛŒÙ„:** blockÙ‡Ø§ÛŒ Ø¨Ø±Ø§Ø¯Ø± (sibling) scope Ù…Ø´ØªØ±Ú© Ù†Ø¯Ø§Ø±Ù†Ø¯

---

### 1.2 Ø®Ø·Ø§ÛŒ Out of Scope

```csharp
{
int y;
}
Console.Write(y);  // âŒ Error: y is out of scope
```
**Ø¯Ù„ÛŒÙ„:** `y` ÙÙ‚Ø· Ø¯Ø§Ø®Ù„ block Ø®ÙˆØ¯Ø´ Ù‚Ø§Ø¨Ù„ Ø¯Ø³ØªØ±Ø³ÛŒ Ø§Ø³Øª

---

## 2. Bidirectional Scope (ÙˆÛŒÚ˜Ú¯ÛŒ Ø®Ø§Øµ C#)

### Ø±ÙØªØ§Ø± ØºÛŒØ±Ù…Ø¹Ù…ÙˆÙ„

**Scope Ù…ØªØºÛŒØ± Ø¯Ø± Ù‡Ø± Ø¯Ùˆ Ø¬Ù‡Øª Ø¯Ø± block Ú¯Ø³ØªØ±Ø´ Ù…ÛŒâ€ŒÛŒØ§Ø¨Ø¯**

#### Ù…Ø«Ø§Ù„

```csharp
void Method()
{
{
int y;
int x;  // âŒ Error: x Ù‚Ø¨Ù„Ø§Ù‹ ØªØ¹Ø±ÛŒÙ Ø´Ø¯Ù‡!
}

int x;  // ØªØ¹Ø±ÛŒÙ Ø¯Ø± Ø§Ù†ØªÙ‡Ø§ÛŒ Ù…ØªØ¯
}
```
**ØªÙˆØ¶ÛŒØ­:**
- Ø§Ú¯Ø±Ú†Ù‡ `int x` Ø¯Ø± Ø§Ù†ØªÙ‡Ø§Ø³ØªØŒ Ø§Ù…Ø§ scope Ø¢Ù† Ú©Ù„ Ù…ØªØ¯ Ø§Ø³Øª
- Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù† Ø¯Ø± nested block Ù…ØªØºÛŒØ± Ù‡Ù…Ù†Ø§Ù… ØªØ¹Ø±ÛŒÙ Ú©Ø±Ø¯

---

### ØªÙ†Ø§Ù‚Ø¶ Ø¸Ø§Ù‡Ø±ÛŒ

```csharp
int x;
Console.WriteLine(x);  // âœ… Legal: x ØªØ¹Ø±ÛŒÙ Ø´Ø¯Ù‡

// Ø§Ù…Ø§:
Console.WriteLine(y);  // âŒ Error: Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù‚Ø¨Ù„ Ø§Ø² ØªØ¹Ø±ÛŒÙ
int y;
```
**Ù†Ú©ØªÙ‡:** Ø§Ú¯Ø±Ú†Ù‡ scope Ø¯ÙˆØ·Ø±ÙÙ‡ Ø§Ø³ØªØŒ Ø§Ù…Ø§ **Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù† Ù‚Ø¨Ù„ Ø§Ø² declaration Ø¨Ù‡ Ù…ØªØºÛŒØ± Ø§Ø±Ø¬Ø§Ø¹ Ø¯Ø§Ø¯**

---

## 3. Expression Statements

### ØªØ¹Ø±ÛŒÙ

**Expression Statement = expression Ú©Ù‡ statement Ù…Ø¹ØªØ¨Ø± Ù‡Ù… Ù‡Ø³Øª**

**Ø´Ø±Ø· Ø§ØµÙ„ÛŒ:** Ø¨Ø§ÛŒØ¯:
1. **State Ø±Ø§ ØªØºÛŒÛŒØ± Ø¯Ù‡Ø¯**ØŒ ÛŒØ§
2. **Ú†ÛŒØ²ÛŒ Ø±Ø§ ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ Ú©Ù†Ø¯ Ú©Ù‡ Ù…Ù…Ú©Ù† Ø§Ø³Øª state Ø±Ø§ ØªØºÛŒÛŒØ± Ø¯Ù‡Ø¯**

**State = Ù…Ù‚Ø¯Ø§Ø± Ù…ØªØºÛŒØ± ÛŒØ§ ÙˆØ¶Ø¹ÛŒØª Ø³ÛŒØ³ØªÙ…**

---

## 4. Ø§Ù†ÙˆØ§Ø¹ Expression Statements

### 4.1 Assignment Expressions

**Ø§Ù†ØªØ³Ø§Ø¨ Ù…Ù‚Ø¯Ø§Ø± Ø¨Ù‡ Ù…ØªØºÛŒØ±**

```csharp
x = 1 + 2;           // Assignment
x += 5;              // Compound assignment
```
---

### 4.2 Increment/Decrement Expressions

```csharp
x++;                 // Post-increment
++x;                 // Pre-increment
y--;                 // Post-decrement
--y;                 // Pre-decrement
```
**Ù†Ú©ØªÙ‡:** Ø§ÛŒÙ†Ù‡Ø§ Ù†ÙˆØ¹ Ø®Ø§ØµÛŒ Ø§Ø² assignment expressions Ù‡Ø³ØªÙ†Ø¯

---

### 4.3 Method Call Expressions

**Ù‡Ø± method call (void ÛŒØ§ non-void)**

```csharp
Console.WriteLine(y);        // void method
y = Math.Max(x, 5);         // non-void method (Ø¨Ø§ assignment)
Console.WriteLine("Hello"); // void method
```
**Ù†Ú©ØªÙ‡:** Ø­ØªÛŒ Ø§Ú¯Ø± method Ù…Ù‚Ø¯Ø§Ø± Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯ØŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù†ØªÛŒØ¬Ù‡ Ø§Ø®ØªÛŒØ§Ø±ÛŒ Ø§Ø³Øª

---

### 4.4 Object Instantiation Expressions

**Ø§ÛŒØ¬Ø§Ø¯ Ù†Ù…ÙˆÙ†Ù‡ (instance) Ø¬Ø¯ÛŒØ¯**

```csharp
sb = new StringBuilder();    // Ø¨Ø§ assignment
new StringBuilder();         // Ø¨Ø¯ÙˆÙ† assignment
```
---

## 5. Ù…Ø«Ø§Ù„ Ø¬Ø§Ù…Ø¹

```csharp
// Declaration statements (Ù†Ù‡ expression statement)
string s;
int x, y;
System.Text.StringBuilder sb;

// Expression statements:

// 1. Assignment expressions
x = 1 + 2;              // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ùˆ Ø§Ù†ØªØ³Ø§Ø¨

// 2. Increment
x++;                    // ØªØºÛŒÛŒØ± state (x)

// 3. Method call + Assignment
y = Math.Max(x, 5);     // ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ Ùˆ Ø§Ù†ØªØ³Ø§Ø¨

// 4. Method call (void)
Console.WriteLine(y);   // ØªØºÛŒÛŒØ± state (console output)

// 5. Object instantiation + Assignment
sb = new StringBuilder();

// 6. Object instantiation alone
new StringBuilder();    // Ø§ÛŒØ¬Ø§Ø¯ Ø´ÛŒØ¡ (Ø­ØªÛŒ Ø¨Ø¯ÙˆÙ† Ø§Ø³ØªÙØ§Ø¯Ù‡)
```
---

## 6. Useless but Legal Statements

### Ø±ÙØªØ§Ø± Ø¹Ø¬ÛŒØ¨: Legal Ø§Ù…Ø§ Ø¨ÛŒâ€ŒÙØ§ÛŒØ¯Ù‡

```csharp
new StringBuilder();        // âœ… Legal, âŒ Useless
new string('c', 3);        // âœ… Legal, âŒ Useless
x.Equals(y);               // âœ… Legal, âŒ Useless

**Ú†Ø±Ø§ legal Ø§Ø³ØªØŸ**
- Constructor Ù…Ù…Ú©Ù† Ø§Ø³Øª side-effect Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯
- Method Ù…Ù…Ú©Ù† Ø§Ø³Øª state Ø±Ø§ ØªØºÛŒÛŒØ± Ø¯Ù‡Ø¯
- Compiler Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ù…Ø·Ù…Ø¦Ù† Ø´ÙˆØ¯ Ú©Ù‡ Ø¨ÛŒâ€ŒÙØ§ÛŒØ¯Ù‡ Ø§Ø³Øª
```
**Ú†Ø±Ø§ useless Ø§Ø³ØªØŸ**
- Ø´ÛŒØ¡ Ø³Ø§Ø®ØªÙ‡ Ø´Ø¯Ù‡ Ø°Ø®ÛŒØ±Ù‡ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯ â†’ GC ÙÙˆØ±Ø§Ù‹ Ø­Ø°Ù Ù…ÛŒâ€ŒÚ©Ù†Ø¯
- Ù†ØªÛŒØ¬Ù‡ `Equals` Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯

---

### Ù…Ø«Ø§Ù„â€ŒÙ‡Ø§ÛŒ Ø¨Ù‡ØªØ± (Ø§Ø³ØªÙØ§Ø¯Ù‡ ØµØ­ÛŒØ­)

```csharp
// Ø¨Ø¬Ø§ÛŒ:
new StringBuilder();

// Ø¨Ù†ÙˆÛŒØ³:
sb = new StringBuilder();

// Ø¨Ø¬Ø§ÛŒ:
x.Equals(y);

// Ø¨Ù†ÙˆÛŒØ³:
if (x.Equals(y)) { /* ... */ }
// ÛŒØ§:
bool areEqual = x.Equals(y);
```
---

## 7. Ø¬Ø¯ÙˆÙ„ Ø®Ù„Ø§ØµÙ‡ Expression Statements

| Ù†ÙˆØ¹ | Syntax | Ù…Ø«Ø§Ù„ | ØªØºÛŒÛŒØ± stateØŸ |
|-----|--------|------|-------------|
| **Assignment** | `x = expr` | `x = 5;` | âœ… Ù…ØªØºÛŒØ± |
| **Increment** | `x++` / `++x` | `count++;` | âœ… Ù…ØªØºÛŒØ± |
| **Method Call** | `method()` | `Console.WriteLine()` | âœ… Ù…Ù…Ú©Ù† Ø§Ø³Øª |
| **Instantiation** | `new Type()` | `new StringBuilder()` | âœ… Ø­Ø§ÙØ¸Ù‡ |

---

## 8. Ù†Ú©Ø§Øª Ù…Ù‡Ù…

### âœ… Valid Expression Statements

```csharp
x = 10;                     // Assignment
x++;                        // Increment
Console.WriteLine("Hi");    // Method call
obj.DoSomething();         // Method call
list.Add(5);               // Method call Ø¨Ø§ side-effect
sb = new StringBuilder();   // Instantiation + assignment
```
### âŒ Invalid Expression Statements

```csharp
x + 5;          // âŒ ÙÙ‚Ø· Ù…Ø­Ø§Ø³Ø¨Ù‡ (Ø¨Ø¯ÙˆÙ† assignment ÛŒØ§ call)
x == y;         // âŒ ÙÙ‚Ø· Ù…Ù‚Ø§ÛŒØ³Ù‡ (Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ± state)
x < 10;         // âŒ ÙÙ‚Ø· Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ boolean
"Hello";        // âŒ ÙÙ‚Ø· literal
```
**Ø¯Ù„ÛŒÙ„:** Ù‡ÛŒÚ†â€ŒÚ©Ø¯Ø§Ù… state Ø±Ø§ ØªØºÛŒÛŒØ± Ù†Ù…ÛŒâ€ŒØ¯Ù‡Ù†Ø¯

---

## 9. Ù…Ù‚Ø§ÛŒØ³Ù‡ Declaration vs Expression Statement

| | Declaration Statement | Expression Statement |
|---|----------------------|---------------------|
| **Ù‡Ø¯Ù** | ØªØ¹Ø±ÛŒÙ Ù…ØªØºÛŒØ±/Ø«Ø§Ø¨Øª | Ø§Ø¬Ø±Ø§ÛŒ Ø¹Ù…Ù„ÛŒØ§Øª |
| **Ù…Ø«Ø§Ù„** | `int x;` | `x = 5;` |
| **State** | Ø§ÛŒØ¬Ø§Ø¯ Ù…ØªØºÛŒØ± | ØªØºÛŒÛŒØ± Ù…Ù‚Ø¯Ø§Ø± |
| **ExpressionØŸ** | âŒ Ø®ÛŒØ± | âœ… Ø¨Ù„Ù‡ |

---

## 10. Ø®Ù„Ø§ØµÙ‡ Scope Rules

### Ù‚ÙˆØ§Ù†ÛŒÙ† Ú©Ù„ÛŒØ¯ÛŒ:

1. **Scope = Ú©Ù„ block Ø¬Ø§Ø±ÛŒ**
2. **Bidirectional** (Ø¯ÙˆØ·Ø±ÙÙ‡ Ø¯Ø± block)
3. **Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù† Ù‡Ù…Ù†Ø§Ù… ØªØ¹Ø±ÛŒÙ Ú©Ø±Ø¯:**
   - Ø¯Ø± Ù‡Ù…Ø§Ù† block
   - Ø¯Ø± nested blocks
4. **Ù…ÛŒâ€ŒØªÙˆØ§Ù† Ù‡Ù…Ù†Ø§Ù… ØªØ¹Ø±ÛŒÙ Ú©Ø±Ø¯:**
   - Ø¯Ø± sibling blocks
5. **Ø¨Ø§ÛŒØ¯ Ù‚Ø¨Ù„ Ø§Ø² Ø§Ø³ØªÙØ§Ø¯Ù‡ declare Ø´ÙˆØ¯** (Ø¨Ø§ ÙˆØ¬ÙˆØ¯ bidirectional scope)

### Ù…Ø«Ø§Ù„ Ø¬Ø§Ù…Ø¹ Scope

```csharp
void Method()
{
int x = 1;

{
// int x = 2;     // âŒ Error: Ù‡Ù…Ù†Ø§Ù… Ø¨Ø§ Ø¨ÛŒØ±ÙˆÙ†
int y = 3;
Console.WriteLine(x);  // âœ… x Ù‚Ø§Ø¨Ù„ Ø¯Ø³ØªØ±Ø³ÛŒ
}

// Console.WriteLine(y);  // âŒ Error: y out of scope

{
int y = 4;      // âœ… OK: y Ù‚Ø¨Ù„ÛŒ out of scope
}
}
```
---

## Ù…Ø«Ø§Ù„ Ú©Ø§Ù…Ù„

```csharp
public class ScopeDemo
{
public void Demo()
{
// Declaration statements
int count;
string name;

// Expression statements
count = 0;                      // Assignment
count++;                        // Increment
name = "Alice";                 // Assignment
Console.WriteLine(name);        // Method call

// Block scope
{
int temp = 100;             // Local Ø¨Ù‡ Ø§ÛŒÙ† block
count += temp;              // count Ø§Ø² Ø¨ÛŒØ±ÙˆÙ† Ù‚Ø§Ø¨Ù„ Ø¯Ø³ØªØ±Ø³ÛŒ
}
// temp Ø§ÛŒÙ†Ø¬Ø§ out of scope Ø§Ø³Øª

// Useless but legal
new object();                   // Ù‡ÛŒÚ† Ú©Ø§Ø±Ø¨Ø±Ø¯ÛŒ Ù†Ø¯Ø§Ø±Ø¯
"Hello".ToUpper();             // Ù†ØªÛŒØ¬Ù‡ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯

// Ø§ÛŒÙ†â€ŒÙ‡Ø§ expression statement Ù†ÛŒØ³ØªÙ†Ø¯:
// count + 5;                   // âŒ Error
// count < 10;                  // âŒ Error
}
}

```
# Selection Statements - Ù†Ú©Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ

## 1. Ù…Ú©Ø§Ù†ÛŒØ²Ù…â€ŒÙ‡Ø§ÛŒ Ú©Ù†ØªØ±Ù„ Ø¬Ø±ÛŒØ§Ù†

C# Ú†Ù‡Ø§Ø± Ù…Ú©Ø§Ù†ÛŒØ²Ù… Ø¨Ø±Ø§ÛŒ Ú©Ù†ØªØ±Ù„ Ø´Ø±Ø·ÛŒ Ø¯Ø§Ø±Ø¯:
- **Selection:** `if`, `switch`
- **Conditional Operator:** `?:`
- **Loop:** `while`, `do-while`, `for`, `foreach`

---

## 2. `if` Statement

### Syntax Ù¾Ø§ÛŒÙ‡
```csharp
if (condition)
statement;
```
**Ø´Ø±Ø·:** `condition` Ø¨Ø§ÛŒØ¯ `bool` Ø¨Ø§Ø´Ø¯

### Ù…Ø«Ø§Ù„

```csharp
if (5 < 2 * 3)
Console.WriteLine("true");  // Ø§Ø¬Ø±Ø§ Ù…ÛŒâ€ŒØ´ÙˆØ¯
```
---

### Ø¨Ø§ Code Block

```csharp
if (5 < 2 * 3)
{
Console.WriteLine("true");
Console.WriteLine("Let's move on!");
}
```
**ØªÙˆØµÛŒÙ‡:** Ù‡Ù…ÛŒØ´Ù‡ Ø§Ø² `{}` Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù† (Ø­ØªÛŒ Ø¨Ø±Ø§ÛŒ ÛŒÚ© Ø®Ø·)

---

## 3. `else` Clause

### Syntax

```csharp
if (condition)
statement1;
else
statement2;
```
### Ù…Ø«Ø§Ù„

```csharp
if (2 + 2 == 5)
Console.WriteLine("Does not compute");
else
Console.WriteLine("False");  // Ø§Ø¬Ø±Ø§ Ù…ÛŒâ€ŒØ´ÙˆØ¯
```
---

## 4. `else if` (Nested)

### Syntax

```csharp
if (condition1)
statement1;
else if (condition2)
statement2;
else
statement3;
```
### Ù…Ø«Ø§Ù„

```csharp
if (2 + 2 == 5)
Console.WriteLine("Does not compute");
else if (2 + 2 == 4)
Console.WriteLine("Computes");  // Ø§Ø¬Ø±Ø§ Ù…ÛŒâ€ŒØ´ÙˆØ¯
```
---

## Ø®Ù„Ø§ØµÙ‡

| ÙˆÛŒÚ˜Ú¯ÛŒ | ØªÙˆØ¶ÛŒØ­ |
|-------|-------|
| **Ø´Ø±Ø·** | Ø¨Ø§ÛŒØ¯ `bool` Ø¨Ø§Ø´Ø¯ |
| **`else`** | Ø§Ø®ØªÛŒØ§Ø±ÛŒ |
| **Nesting** | `else if` Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ· Ù…ØªØ¹Ø¯Ø¯ |
| **Block** | Ø§Ø² `{}` Ø¨Ø±Ø§ÛŒ Ú†Ù†Ø¯ statement |




# Braces Ùˆ Flow Control Ø¯Ø± if Statements - Ù†Ú©Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ

## 1. Ù‚Ø§Ù†ÙˆÙ† Ù¾ÛŒØ´â€ŒÙØ±Ø¶ `else`

**`else` Ù‡Ù…ÛŒØ´Ù‡ Ø¨Ù‡ Ù†Ø²Ø¯ÛŒÚ©â€ŒØªØ±ÛŒÙ† `if` Ù‚Ø¨Ù„ÛŒ ØªØ¹Ù„Ù‚ Ø¯Ø§Ø±Ø¯**

### Ù…Ø«Ø§Ù„ - Ø¨Ø¯ÙˆÙ† Braces
```csharp
if (true)
if (false)
Console.WriteLine();
else
Console.WriteLine("executes");  // âœ… Ø§Ø¬Ø±Ø§ Ù…ÛŒâ€ŒØ´ÙˆØ¯
```
**ØªØ¹Ù„Ù‚ `else`:** Ø¨Ù‡ `if (false)` ØªØ¹Ù„Ù‚ Ø¯Ø§Ø±Ø¯ØŒ Ù†Ù‡ `if (true)`

---

### Ù…Ø¹Ø§Ø¯Ù„ ØµØ±ÛŒØ­

```csharp
if (true)
{
if (false)
Console.WriteLine();
else
Console.WriteLine("executes");  // âœ… Ø§Ø¬Ø±Ø§ Ù…ÛŒâ€ŒØ´ÙˆØ¯
}
```
---

## 2. ØªØºÛŒÛŒØ± Flow Ø¨Ø§ Braces

### Ø¬Ø§Ø¨Ø¬Ø§ÛŒÛŒ Braces

```csharp
if (true)
{
if (false)
Console.WriteLine();
}
else
Console.WriteLine("does not execute");  // âŒ Ø§Ø¬Ø±Ø§ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯
```
**ØªØºÛŒÛŒØ±:** Ø­Ø§Ù„Ø§ `else` Ø¨Ù‡ `if (true)` Ø¨ÛŒØ±ÙˆÙ†ÛŒ ØªØ¹Ù„Ù‚ Ø¯Ø§Ø±Ø¯

---

## 3. Ù…Ø²ÛŒØª Braces

### âœ… Ø®ÙˆØ§Ù†Ø§ÛŒÛŒ Ø¨Ù‡ØªØ±

```csharp
// Ø¨Ø¯ÙˆÙ† braces - Ù…Ø¨Ù‡Ù…
if (x > 0)
if (y > 0)
Console.WriteLine("Both positive");
else
Console.WriteLine("???");  // else Ú©Ø¯Ø§Ù… if Ø§Ø³ØªØŸ

// Ø¨Ø§ braces - ÙˆØ§Ø¶Ø­
if (x > 0)
{
if (y > 0)
Console.WriteLine("Both positive");
}
else
{
Console.WriteLine("x is not positive");  // âœ… Ø±ÙˆØ´Ù†
}
```
**ØªÙˆØµÛŒÙ‡:** Ù‡Ù…ÛŒØ´Ù‡ Ø§Ø² braces Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù† (Ø­ØªÛŒ ÙˆÙ‚Øª Ù„Ø§Ø²Ù… Ù†ÛŒØ³Øª)

---

## 4. Ø§Ù„Ú¯ÙˆÛŒ `else if` Chain

### Ø§Ø³ØªØ«Ù†Ø§: Pattern Ù…Ø¹Ù…ÙˆÙ„

```csharp
void TellMeWhatICanDo(int age)
{
if (age >= 35)
Console.WriteLine("You can be president!");
else if (age >= 21)
Console.WriteLine("You can drink!");
else if (age >= 18)
Console.WriteLine("You can vote!");
else
Console.WriteLine("You can wait!");
}
```
**ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§:**
- Ø´Ø¨ÛŒÙ‡ `elseif` Ø²Ø¨Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ø¯ÛŒÚ¯Ø±
- Visual Studio indentation Ø±Ø§ Ø­ÙØ¸ Ù…ÛŒâ€ŒÚ©Ù†Ø¯
- **ÙˆØ§Ù‚Ø¹ÛŒØª:** Ù‡Ø± `if` Ø¯Ø§Ø®Ù„ `else` Ù‚Ø¨Ù„ÛŒ nest Ø´Ø¯Ù‡ Ø§Ø³Øª

---

### Ø³Ø§Ø®ØªØ§Ø± ÙˆØ§Ù‚Ø¹ÛŒ (Ø¨Ø§ Braces)

```csharp
if (age >= 35)
Console.WriteLine("You can be president!");
else
{
if (age >= 21)
Console.WriteLine("You can drink!");
else
{
if (age >= 18)
Console.WriteLine("You can vote!");
else
Console.WriteLine("You can wait!");
}
}
```
**Ù†Ú©ØªÙ‡:** Ù‡Ù…Ù‡ `else if` Ù‡Ø§ Ø¯Ø§Ø±Ø§ÛŒ nesting Ù‡Ø³ØªÙ†Ø¯ØŒ Ø§Ù…Ø§ formatting Ø®ÙˆØ§Ù†Ø§ÛŒÛŒ Ø±Ø§ Ø¨Ù‡Ø¨ÙˆØ¯ Ù…ÛŒâ€ŒØ¯Ù‡Ø¯

---

## Ø®Ù„Ø§ØµÙ‡

| Ù…ÙˆØ¶ÙˆØ¹ | Ù†Ú©ØªÙ‡ Ú©Ù„ÛŒØ¯ÛŒ |
|-------|-------------|
| **`else` Binding** | Ø¨Ù‡ Ù†Ø²Ø¯ÛŒÚ©â€ŒØªØ±ÛŒÙ† `if` ØªØ¹Ù„Ù‚ Ø¯Ø§Ø±Ø¯ |
| **Braces** | flow Ø±Ø§ ØªØºÛŒÛŒØ± Ù…ÛŒâ€ŒØ¯Ù‡Ù†Ø¯ |
| **Ø®ÙˆØ§Ù†Ø§ÛŒÛŒ** | Ù‡Ù…ÛŒØ´Ù‡ Ø§Ø² braces Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù† |
| **`else if` Pattern** | Ø§Ø³ØªØ«Ù†Ø§ - Ø¨Ø¯ÙˆÙ† braces Ù…Ø¬Ø§Ø² |
| **VS Formatting** | `else if` chain Ø±Ø§ ØªØ´Ø®ÛŒØµ Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ |

---

## Best Practice

```csharp
// âŒ Ø¨Ø¯ - Ù…Ø¨Ù‡Ù…
if (condition1)
if (condition2)
DoSomething();
else
DoSomethingElse();

// âœ… Ø®ÙˆØ¨ - ÙˆØ§Ø¶Ø­
if (condition1)
{
if (condition2)
{
DoSomething();
}
else
{
DoSomethingElse();
}
}

// âœ… Ø§Ø³ØªØ«Ù†Ø§ - Ø§Ù„Ú¯ÙˆÛŒ else if
if (condition1)
DoA();
else if (condition2)
DoB();
else
DoC();
```


# Switch Statement - Ù†Ú©Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ

## 1. Ú©Ø§Ø±Ø¨Ø±Ø¯ Ø§ØµÙ„ÛŒ

**Ø§Ù†Ø´Ø¹Ø§Ø¨ Ø¨Ø± Ø§Ø³Ø§Ø³ Ù…Ù‚Ø§Ø¯ÛŒØ± Ù…Ø®ØªÙ„Ù ÛŒÚ© Ù…ØªØºÛŒØ±**

### Ù…Ø²ÛŒØª Ù†Ø³Ø¨Øª Ø¨Ù‡ `if`
```csharp
// âœ… switch - ØªÙ†Ù‡Ø§ ÛŒÚ© Ø¨Ø§Ø± Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÛŒâ€ŒØ´ÙˆØ¯
switch (cardNumber)
{
case 13: /* ... */ break;
case 12: /* ... */ break;
}

// âŒ if - Ú†Ù†Ø¯ÛŒÙ† Ø¨Ø§Ø± Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÛŒâ€ŒØ´ÙˆØ¯
if (cardNumber == 13) { }
else if (cardNumber == 12) { }
```
**Ù†ØªÛŒØ¬Ù‡:** Ú©Ø¯ ØªÙ…ÛŒØ²ØªØ± Ùˆ Ú©Ø§Ø±Ø¢Ù…Ø¯ØªØ±

---

## 2. Syntax Ù¾Ø§ÛŒÙ‡

```csharp
void ShowCard(int cardNumber)
{
switch (cardNumber)
{
case 13:
Console.WriteLine("King");
break;
case 12:
Console.WriteLine("Queen");
break;
case 11:
Console.WriteLine("Jack");
break;
default:
Console.WriteLine(cardNumber);
break;
}
}
```
---

## 3. Ø§Ù†ÙˆØ§Ø¹ Ù…Ø¬Ø§Ø² Ø¨Ø±Ø§ÛŒ Constants

| Ù†ÙˆØ¹ | Ù…Ø«Ø§Ù„ |
|-----|------|
| **Ø§Ø¹Ø¯Ø§Ø¯ (Built-in)** | `int`, `long`, `byte`, ... |
| **`bool`** | `true`, `false` |
| **`char`** | `'a'`, `'Z'` |
| **`string`** | `"hello"` |
| **`enum`** | `Color.Red` |

---

## 4. Jump Statements (Ø§Ù„Ø²Ø§Ù…ÛŒ)

**Ø¯Ø± Ù¾Ø§ÛŒØ§Ù† Ù‡Ø± `case` Ø¨Ø§ÛŒØ¯ ÛŒÚ©ÛŒ Ø§Ø² Ø§ÛŒÙ†â€ŒÙ‡Ø§ Ø¨Ø§Ø´Ø¯:**

| Statement | Ø¹Ù…Ù„Ú©Ø±Ø¯ |
|-----------|--------|
| **`break`** | Ø®Ø±ÙˆØ¬ Ø§Ø² `switch` |
| **`goto case x`** | Ù¾Ø±Ø´ Ø¨Ù‡ `case` Ø¯ÛŒÚ¯Ø± |
| **`goto default`** | Ù¾Ø±Ø´ Ø¨Ù‡ `default` |
| **`return`** | Ø®Ø±ÙˆØ¬ Ø§Ø² Ù…ØªØ¯ |
| **`throw`** | Ù¾Ø±ØªØ§Ø¨ Exception |
| **`continue`** | (Ø¯Ø± loop) |
| **`goto label`** | Ù¾Ø±Ø´ Ø¨Ù‡ label |

---

## 5. `goto case` - Ù…Ø«Ø§Ù„

```csharp
case -1:  // Joker
goto case 12;  // âœ… Ù¾Ø±Ø´ Ø¨Ù‡ Queen
```
**Ú©Ø§Ø±Ø¨Ø±Ø¯:** ÛŒÚ© Ù…Ù‚Ø¯Ø§Ø± Ø±ÙØªØ§Ø± Ù…Ù‚Ø¯Ø§Ø± Ø¯ÛŒÚ¯Ø±ÛŒ Ø±Ø§ Ø¯Ø§Ø±Ø¯

---

## 6. Multiple Cases - ÛŒÚ© Ú©Ø¯

### Ú©Ø¯Ù‡Ø§ÛŒ Ù…Ø´ØªØ±Ú©

```csharp
switch (cardNumber)
{
case 13:  // King
case 12:  // Queen
case 11:  // Jack
Console.WriteLine("Face card");
break;
default:
Console.WriteLine("Plain card");
break;
}
```
**Ù…Ø²ÛŒØª:** Ú©Ø¯ ØªÙ…ÛŒØ²ØªØ± Ø§Ø² `if-else` Ù‡Ø§ÛŒ Ù…ØªØ¹Ø¯Ø¯

---

## 7. `default` Clause

**Ø§Ø¬Ø±Ø§ Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ø§Ú¯Ø± Ù‡ÛŒÚ† `case` Ø¯ÛŒÚ¯Ø±ÛŒ match Ù†Ú©Ù†Ø¯**

```csharp
default:
Console.WriteLine("Unknown card");
break;
```
**Ù†Ú©ØªÙ‡:** Ø§Ø®ØªÛŒØ§Ø±ÛŒ Ø§Ø³ØªØŒ Ø§Ù…Ø§ ØªÙˆØµÛŒÙ‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯

---

## Ø®Ù„Ø§ØµÙ‡ Ù…Ù‚Ø§ÛŒØ³Ù‡

| ÙˆÛŒÚ˜Ú¯ÛŒ | `switch` | `if-else` |
|-------|----------|-----------|
| **Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ** | ÛŒÚ© Ø¨Ø§Ø± | Ú†Ù†Ø¯ Ø¨Ø§Ø± |
| **Ø®ÙˆØ§Ù†Ø§ÛŒÛŒ** | Ø¨Ù‡ØªØ± (Ø¨Ø±Ø§ÛŒ Ù…Ù‚Ø§Ø¯ÛŒØ± Ø²ÛŒØ§Ø¯) | Ø¨Ø¯ØªØ± |
| **Ù…Ø­Ø¯ÙˆØ¯ÛŒØª** | ÙÙ‚Ø· constants | Ù‡Ø± Ø´Ø±Ø· `bool` |
| **Fall-through** | Ù†ÛŒØ§Ø² Ø¨Ù‡ `goto case` | Ù†Ø¯Ø§Ø±Ø¯ |

---

## Best Practice

```csharp
// âœ… Ø®ÙˆØ¨ - Ù‡Ù…ÛŒØ´Ù‡ default Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´
switch (value)
{
case 1:
DoSomething();
break;
default:
HandleUnexpected();
break;
}

// âœ… Ø®ÙˆØ¨ - Ú¯Ø±ÙˆÙ‡â€ŒØ¨Ù†Ø¯ÛŒ cases Ù…Ø´Ø§Ø¨Ù‡
switch (grade)
{
case 'A':
case 'B':
Console.WriteLine("Pass");
break;
case 'F':
Console.WriteLine("Fail");
break;
}
```
---

## Ù†Ú©ØªÙ‡ Ú©Ù„ÛŒØ¯ÛŒ

**`switch` Ø¨Ø±Ø§ÛŒ Ø§Ù†Ø´Ø¹Ø§Ø¨ Ø¨Ø± Ø§Ø³Ø§Ø³ Ù…Ù‚Ø§Ø¯ÛŒØ± Ø«Ø§Ø¨Øª (constants) Ø§ÛŒØ¯Ù‡â€ŒØ¢Ù„ Ø§Ø³Øª Ùˆ Ú©Ø¯ Ø±Ø§ Ø§Ø² `if-else` Ù‡Ø§ÛŒ Ø²Ù†Ø¬ÛŒØ±Ù‡â€ŒØ§ÛŒ ØªÙ…ÛŒØ²ØªØ± Ù…ÛŒâ€ŒÚ©Ù†Ø¯**




# Switching on Types - Ù†Ú©Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ

## 1. Ù…ÙÙ‡ÙˆÙ… Ø§ØµÙ„ÛŒ

**Ø§Ø² C# 7 Ù…ÛŒâ€ŒØªÙˆØ§Ù† Ø±ÙˆÛŒ Types (Ø§Ù†ÙˆØ§Ø¹) switch Ú©Ø±Ø¯**
```csharp
void TellMeTheType(object x)
{
switch (x)
{
case int i:
Console.WriteLine("It's an int!");
Console.WriteLine($"The square of {i} is {i * i}");
break;
case string s:
Console.WriteLine("It's a string");
Console.WriteLine($"The length of {s} is {s.Length}");
break;
case DateTime:
Console.WriteLine("It's a DateTime");
break;
default:
Console.WriteLine("I don't know what x is");
break;
}
}
```
---

## 2. Ø³Ø§Ø®ØªØ§Ø± Case Ø¨Ø§ Type

**Syntax:** `case Type variableName:`

- **Type:** Ù†ÙˆØ¹ Ø¨Ø±Ø§ÛŒ ØªØ·Ø¨ÛŒÙ‚
- **variableName:** Ù…ØªØºÛŒØ± Pattern (Ù…Ù‚Ø¯Ø§Ø± cast Ø´Ø¯Ù‡ Ø±Ø§ Ù†Ú¯Ù‡ Ù…ÛŒâ€ŒØ¯Ø§Ø±Ø¯)

```csharp
case int i:      // i Ø­Ø§Ù„Ø§ int Ø§Ø³Øª
case string s:   // s Ø­Ø§Ù„Ø§ string Ø§Ø³Øª
```
---

## 3. ØªÙØ§ÙˆØª Ø¨Ø§ Constant Switching

**Ø¨Ø¯ÙˆÙ† Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ù†ÙˆØ¹:**
- Constants: ÙÙ‚Ø· `int`, `string`, `bool`, `char`, `enum`
- Types: **Ù‡Ø± Ù†ÙˆØ¹ÛŒ** Ù…Ø¬Ø§Ø² Ø§Ø³Øª

---

## 4. Ù†ÛŒØ§Ø² Ø¨Ù‡ `object` Parameter

```csharp
void TellMeTheType(object x)  // âœ… object Ù‡Ø± Ù†ÙˆØ¹ÛŒ Ø±Ø§ Ù…ÛŒâ€ŒÙ¾Ø°ÛŒØ±Ø¯
```
**Ø¯Ù„ÛŒÙ„:** Ø¨Ø±Ø§ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ø§Ù†ÙˆØ§Ø¹ Ù…Ø®ØªÙ„Ù Ø¯Ø± ÛŒÚ© Ù¾Ø§Ø±Ø§Ù…ØªØ±

---

## 5. Pattern Variable (Ù…ØªØºÛŒØ± Ø§Ù„Ú¯Ùˆ)

**Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ù…Ù‚Ø¯Ø§Ø± cast Ø´Ø¯Ù‡:**

```csharp
case int i:
Console.WriteLine(i * i);  // âœ… i Ù‚Ø§Ø¨Ù„ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø³Øª
break;

case string s:
Console.WriteLine(s.Length);  // âœ… s Ù‚Ø§Ø¨Ù„ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø³Øª
break;
```
---

## 6. `when` Guard - Ø´Ø±Ø· Ø§Ø¶Ø§ÙÛŒ

**Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø´Ø±Ø· Ø¨Ù‡ case:**

```csharp
switch (x)
{
case bool b when b == true:
Console.WriteLine("True!");
break;
case bool b:
Console.WriteLine("False!");
break;
}
```
**Ú©Ø§Ø±Ø¨Ø±Ø¯:** ÙÛŒÙ„ØªØ± Ú©Ø±Ø¯Ù† Ø¨ÛŒØ´ØªØ± Ø¯Ø± Ù‡Ù…Ø§Ù† Ù†ÙˆØ¹

---

## 7. Ù…Ø«Ø§Ù„ Ú©Ø§Ù…Ù„

```csharp
TellMeTheType(12);       // It's an int! The square of 12 is 144
TellMeTheType("hello");  // It's a string. The length of hello is 5
TellMeTheType(true);     // I don't know what x is
```
---

## Ù†Ú©Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ

**Û±. Type Switching:** Ø¨Ø®Ø´ÛŒ Ø§Ø² Pattern Matching Ø§Ø³Øª  
**Û². Pattern Variable:** Ù…Ù‚Ø¯Ø§Ø± cast Ø´Ø¯Ù‡ Ø¯Ø± Ù…ØªØºÛŒØ± Ø°Ø®ÛŒØ±Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯  
**Û³. Ø¨Ø¯ÙˆÙ† Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Type:** Ù‡Ø± Ù†ÙˆØ¹ÛŒ Ù…Ø¬Ø§Ø² Ø§Ø³Øª  
**Û´. `when` Guard:** Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ· Ø§Ø¶Ø§ÙÛŒ Ø±ÙˆÛŒ Ù‡Ù…Ø§Ù† Ù†ÙˆØ¹  
**Ûµ. Ù¾Ø§Ø±Ø§Ù…ØªØ± `object`:** Ø¨Ø±Ø§ÛŒ Ù¾Ø°ÛŒØ±Ø´ Ø§Ù†ÙˆØ§Ø¹ Ù…Ø®ØªÙ„Ù

---

## Ø§Ù„Ú¯ÙˆÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡

```csharp
// âœ… Ø§Ù„Ú¯ÙˆÛŒ Ù…Ø¹Ù…ÙˆÙ„
case int i:           // ØªØ·Ø¨ÛŒÙ‚ + Ù…ØªØºÛŒØ±
case string s:        // ØªØ·Ø¨ÛŒÙ‚ + Ù…ØªØºÛŒØ±
case DateTime:        // ÙÙ‚Ø· ØªØ·Ø¨ÛŒÙ‚ (Ø¨Ø¯ÙˆÙ† Ù…ØªØºÛŒØ±)

// âœ… Ø¨Ø§ Ø´Ø±Ø·
case int i when i > 0:
```
**ØªÙˆØ¬Ù‡:** Ø¨Ø±Ø§ÛŒ Ø¬Ø²Ø¦ÛŒØ§Øª Ø¨ÛŒØ´ØªØ± Pattern Matching Ø¨Ù‡ Ø¨Ø®Ø´ "Patterns" Ù…Ø±Ø§Ø¬Ø¹Ù‡ Ú©Ù†ÛŒØ¯



# Switch Statement - Ù†Ú©Ø§Øª ØªÚ©Ù…ÛŒÙ„ÛŒ

## 1. Ø§Ù‡Ù…ÛŒØª ØªØ±ØªÛŒØ¨ Cases Ø¯Ø± Type Switching

**Ø¨Ø±Ø®Ù„Ø§Ù ConstantsØŒ Ø¯Ø± Type Switching ØªØ±ØªÛŒØ¨ Ù…Ù‡Ù… Ø§Ø³Øª:**
```csharp
// âœ… ØµØ­ÛŒØ­
case int i:
// ...
break;
case object o:  // Ø¹Ù…ÙˆÙ…ÛŒâ€ŒØªØ±
// ...
break;

// âŒ ØºÙ„Ø· - Compile Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯
case object o:  // Ø¹Ù…ÙˆÙ…ÛŒâ€ŒØªØ± Ø§ÙˆÙ„
// ...
break;
case int i:     // Unreachable! (Ù‡Ø±Ú¯Ø² Ø§Ø¬Ø±Ø§ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯)
// ...
break;
```
**Ø¯Ù„ÛŒÙ„:** Ú©Ø§Ù…Ù¾Ø§ÛŒÙ„Ø± Ù…ÛŒâ€ŒÙÙ‡Ù…Ø¯ case Ø¯ÙˆÙ… Ù‡Ø±Ú¯Ø² Ø§Ø¬Ø±Ø§ Ù†Ø®ÙˆØ§Ù‡Ø¯ Ø´Ø¯

**Ø§Ø³ØªØ«Ù†Ø§:** `default` Ù‡Ù…ÛŒØ´Ù‡ Ø¢Ø®Ø± Ø§Ø¬Ø±Ø§ Ù…ÛŒâ€ŒØ´ÙˆØ¯ØŒ Ù…Ù‡Ù… Ù†ÛŒØ³Øª Ú©Ø¬Ø§ Ø¨Ø§Ø´Ø¯

---

## 2. Stacking Multiple Cases Ø¨Ø§ Pattern

**ÛŒÚ© Ú©Ø¯ Ø¨Ø±Ø§ÛŒ Ú†Ù†Ø¯ type:**

```csharp
switch (x)
{
case float f when f > 1000:
case double d when d > 1000:
case decimal m when m > 1000:
Console.WriteLine("We can refer to x here but not f or d or m");
break;
}
```
**Ù†Ú©ØªÙ‡ Ú©Ù„ÛŒØ¯ÛŒ:** Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ Pattern (`f`, `d`, `m`) ÙÙ‚Ø· Ø¯Ø± `when` Ù‚Ø§Ø¨Ù„ Ø§Ø³ØªÙØ§Ø¯Ù‡â€ŒØ§Ù†Ø¯ØŒ Ø¯Ø± Ø¨Ø¯Ù†Ù‡ case Ø®Ø§Ø±Ø¬ Ø§Ø² scope Ù‡Ø³ØªÙ†Ø¯ (Ú†ÙˆÙ† Ú©Ø§Ù…Ù¾Ø§ÛŒÙ„Ø± Ù†Ù…ÛŒâ€ŒØ¯Ø§Ù†Ø¯ Ú©Ø¯Ø§Ù… assign Ø´Ø¯Ù‡)

---

## 3. ØªØ±Ú©ÛŒØ¨ Constants Ùˆ Patterns

**Ù…Ø¬Ø§Ø² Ø§Ø³Øª:**

```csharp
switch (x)
{
case 0:           // constant
// ...
break;
case int i:       // pattern
// ...
break;
case null:        // null value
Console.WriteLine("Nothing here");
break;
}
```
---

## 4. Switch Expressions (C# 8+)

**ÙØ±Ù… ÙØ´Ø±Ø¯Ù‡â€ŒØªØ± Ø¨Ø±Ø§ÛŒ Ø¨Ø§Ø²Ú¯Ø´Øª Ù…Ù‚Ø¯Ø§Ø±:**

```csharp
string cardName = cardNumber switch
{
13 => "King",
12 => "Queen",
11 => "Jack",
_ => "Pip card"  // Ù…Ø¹Ø§Ø¯Ù„ default
};
```
**ØªÙØ§ÙˆØªâ€ŒÙ‡Ø§:**
- `switch` Ø¨Ø¹Ø¯ Ø§Ø² Ù…ØªØºÛŒØ± Ù…ÛŒâ€ŒØ¢ÛŒØ¯
- Cases Ø¨Ù‡ Ø¬Ø§ÛŒ statementØŒ expression Ù‡Ø³ØªÙ†Ø¯ (Ø¨Ø§ `,` Ø®Ø§ØªÙ…Ù‡ Ù…ÛŒâ€ŒÛŒØ§Ø¨Ù†Ø¯)
- `_` Ø¨Ù‡ Ø¬Ø§ÛŒ `default`
- ÙØ´Ø±Ø¯Ù‡â€ŒØªØ± Ùˆ Ù‚Ø§Ø¨Ù„ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø¯Ø± LINQ

**Ù‡Ø´Ø¯Ø§Ø±:** Ø§Ú¯Ø± `_` Ø±Ø§ Ø­Ø°Ù Ú©Ù†ÛŒØ¯ Ùˆ Ù‡ÛŒÚ† case match Ù†Ú©Ù†Ø¯ØŒ **Exception** Ù¾Ø±ØªØ§Ø¨ Ù…ÛŒâ€ŒØ´ÙˆØ¯

---

## 5. Tuple Pattern - Switch Ø±ÙˆÛŒ Ú†Ù†Ø¯ Ù…Ù‚Ø¯Ø§Ø±

**Ø¨Ø±Ø±Ø³ÛŒ ØªØ±Ú©ÛŒØ¨ Ú†Ù†Ø¯ Ù…ØªØºÛŒØ±:**

```csharp
int cardNumber = 12;
string suite = "spades";

string cardName = (cardNumber, suite) switch
{
(13, "spades") => "King of spades",
(13, "clubs") => "King of clubs",
// ...
_ => "Unknown card"
};
```
**Ú©Ø§Ø±Ø¨Ø±Ø¯:** Ø¨Ø±Ø±Ø³ÛŒ Ù‡Ù…Ø²Ù…Ø§Ù† Ú†Ù†Ø¯ Ø´Ø±Ø·

---

## Ù†Ú©Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ

**Û±. ØªØ±ØªÛŒØ¨ Ù…Ù‡Ù… Ø§Ø³Øª:** Ø¯Ø± Type SwitchingØŒ case Ù‡Ø§ÛŒ Ø®Ø§Øµâ€ŒØªØ± Ø¨Ø§ÛŒØ¯ Ù‚Ø¨Ù„ Ø§Ø² Ø¹Ù…ÙˆÙ…ÛŒâ€ŒØªØ± Ø¨ÛŒØ§ÛŒÙ†Ø¯  
**Û². Stacking:** Ú†Ù†Ø¯ case pattern Ø¨Ø§ `when` Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ù†Ø¯ ÛŒÚ© Ú©Ø¯ Ù…Ø´ØªØ±Ú© Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ù†Ø¯  
**Û³. Pattern Variables Scope:** ÙÙ‚Ø· Ø¯Ø± `when` Ù‚Ø§Ø¨Ù„ Ø¯Ø³ØªØ±Ø³â€ŒØ§Ù†Ø¯  
**Û´. Switch Expression:** ÙØ±Ù… ÙØ´Ø±Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ return Ù…Ù‚Ø¯Ø§Ø± (Ø¨Ø§ `=>` Ùˆ `,`)  
**Ûµ. Tuple Pattern:** switch Ø±ÙˆÛŒ Ú†Ù†Ø¯ Ù…ØªØºÛŒØ± Ù‡Ù…Ø²Ù…Ø§Ù†  
**Û¶. `null` matching:** Ù…ÛŒâ€ŒØªÙˆØ§Ù† Ø±ÙˆÛŒ `null` switch Ú©Ø±Ø¯

---

## Ù…Ù‚Ø§ÛŒØ³Ù‡ Ø³Ø±ÛŒØ¹

```csharp
// Statement (Ø³Ù†ØªÛŒ)
string result;
switch (x)
{
case 1:
result = "One";
break;
default:
result = "Other";
break;
}

// Expression (ÙØ´Ø±Ø¯Ù‡)
string result = x switch
{
1 => "One",
_ => "Other"
};
```
**ØªÙˆØ¬Ù‡:** Ø¨Ø±Ø§ÛŒ Pattern Ù‡Ø§ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡â€ŒØªØ± Ø¨Ù‡ Ø¨Ø®Ø´ "Patterns" Ù…Ø±Ø§Ø¬Ø¹Ù‡ Ú©Ù†ÛŒØ¯


