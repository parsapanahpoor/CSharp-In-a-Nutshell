# نکات فنی - double در مقابل decimal و خطاهای گرد کردن

## 1. جدول مقایسه `double` و `decimal`

| ویژگی | `double` | `decimal` |
|-------|----------|-----------|
| **نمایش داخلی** | Base 2 | Base 10 |
| **دقت اعشاری** | 15-16 رقم | 28-29 رقم |
| **محدوده** | ±(~10⁻³²⁴ تا ~10³⁰⁸) | ±(~10⁻²⁸ تا ~10²⁸) |
| **مقادیر ویژه** | `+0`, `-0`, `+∞`, `-∞`, `NaN` | ندارد |
| **سرعت** | Native (~10x سریع‌تر) | Non-native |
| **کاربرد** | محاسبات علمی | محاسبات مالی |

---

## 2. خطای گرد کردن در `float`/`double`

### مشکل اصلی: نمایش Base 2
```csharp
// ❌ double نمی‌تواند 0.1 را دقیق نمایش دهد
float x = 0.1f; // داخلاً: 0.100000001490116119384765625
Console.WriteLine(x + x + x + x + x + x + x + x + x + x); 
// خروجی: 1.0000001 (انتظار: 1.0)

**دلیل:** `0.1` در Base 10 قابل بیان است، اما در Base 2 یک عدد اعشاری **تکرارشونده** است:
$$0.1_{10} = 0.00011001100110011..._{2}$$

---

## 3. `decimal` و Base 10

### مزیت:

csharp
// ✅ decimal می‌تواند 0.1 را دقیق نمایش دهد
decimal d = 0.1m;
Console.WriteLine(d + d + d + d + d + d + d + d + d + d);
// خروجی: 1.0 (دقیق!)

**چرا؟** زیرا `decimal` در Base 10 کار می‌کند و `0.1` در Base 10 دقیق است.

---

## 4. محدودیت `decimal`: اعداد کسری تکرارشونده

### مشکل:

csharp
decimal m = 1M / 6M; // 0.1666666666666666666666666667M
double d = 1.0 / 6.0; // 0.16666666666666666

// هیچ‌کدام نمی‌توانند 1/6 را دقیق نمایش دهند
// چون 1/6 = 0.16666... (تکرارشونده در هر دو Base)

### انباشت خطا:

csharp
// ❌ decimal هم خطا دارد (اما کمتر از double)
decimal notQuiteWholeM = m+m+m+m+m+m; // 1.0000000000000000000000000002M
double notQuiteWholeD = d+d+d+d+d+d;  // 0.99999999999999989

Console.WriteLine(notQuiteWholeM == 1M); // False
Console.WriteLine(notQuiteWholeD < 1.0); // True (اشتباه منطقی!)

---

## 5. قوانین طلایی

### کدام نوع را انتخاب کنیم؟

| نوع | استفاده |
|-----|---------|
| **`double`** | محاسبات علمی، فیزیک، گرافیک، مختصات فضایی |
| **`decimal`** | محاسبات مالی، پول، قیمت، مالیات، حسابداری |

### قانون کلیدی:

csharp
// ❌ هرگز از double برای پول استفاده نکنید!
double price = 0.1;
double total = price * 10; // 1.0000001 (اشتباه!)

// ✅ همیشه از decimal برای پول استفاده کنید
decimal price = 0.1m;
decimal total = price * 10; // 1.0 (صحیح!)

---

## 6. خلاصه نهایی

### نکات کلیدی:

1. **Base 2 vs Base 10:**
   - `double`: Base 2 → نمی‌تواند اعداد اعشاری Base 10 را دقیق نمایش دهد
   - `decimal`: Base 10 → می‌تواند اعداد اعشاری Base 10 را دقیق نمایش دهد

2. **خطای گرد کردن:**
   - `0.1 + 0.1 + ... (10 بار)` در `double` = `1.0000001`
   - هیچ‌کدام نمی‌توانند کسرهای تکرارشونده (مثل `1/6`) را دقیق نمایش دهند

3. **استفاده:**
   - پول/مالی → `decimal`
   - علمی/فیزیکی → `double`

4. **مقایسه:**
   - هرگز از `==` برای `double` استفاده نکنید (باید از epsilon استفاده کنید)
   - حتی `decimal` هم برای کسرهای تکرارشونده مشکل دارد

### کد خلاصه:

csharp
// ❌ double برای پول
double bad = 0.1 + 0.2; // 0.30000000000000004

// ✅ decimal برای پول
decimal good = 0.1m + 0.2m; // 0.3

// ⚠️ هر دو برای 1/6 مشکل دارند
decimal m = 1M / 6M * 6M; // 1.0000000000000000000000000002M


# نکات فنی صفحه - نوع Boolean و عملگرهای مقایسه

## 1. نوع `bool` در C#

### تعریف و ذخیره‌سازی
```csharp
bool isActive = true;
bool isComplete = false;

| ویژگی | مقدار |
|-------|-------|
| **نوع پایه** | `System.Boolean` |
| **مقادیر ممکن** | `true` یا `false` |
| **ذخیره منطقی** | 1 بیت |
| **ذخیره فیزیکی** | 1 بایت (8 بیت) |

### دلیل استفاده از 1 بایت

- Runtime و پردازنده به‌صورت کارآمد با حداقل 1 بایت کار می‌کنند
- 1 بیت قابل مدیریت مستقیم نیست

### راه‌حل برای آرایه‌های بزرگ

csharp
// ❌ استفاده معمولی: هدر رفت فضا
bool[] flags = new bool[1000]; // 1000 بایت مصرف می‌کند

// ✅ استفاده بهینه: صرفه‌جویی فضا
using System.Collections;
BitArray bits = new BitArray(1000); // فقط 125 بایت مصرف می‌کند

**نکته:** `BitArray` در namespace `System.Collections` قرار دارد و فقط 1 بیت به ازای هر مقدار Boolean استفاده می‌کند.

---

## 2. تبدیل‌های `bool`

### قانون اصلی: عدم تبدیل مستقیم

csharp
// ❌ این کدها کامپایل نمی‌شوند
bool b = 1;           // خطا
int x = true;         // خطا
bool y = (bool)0;     // خطا

// ✅ راه‌حل‌های صحیح
bool b1 = (x != 0);   // تبدیل با مقایسه
int num = b1 ? 1 : 0; // استفاده از عملگر سه‌تایی

**تفاوت با C/C++:** در C#، نمی‌توان `bool` را به عدد یا بالعکس تبدیل کرد (حتی با Cast).

---

## 3. عملگرهای تساوی و مقایسه

### 3.1. عملگرهای تساوی: `==` و `!=`

csharp
// همیشه bool برمی‌گردانند
int result = (5 == 5);  // true
bool notEqual = (3 != 3); // false

**نکته:** امکان Overload کردن این عملگرها وجود دارد (Chapter 4)، اما معمولاً همیشه `bool` برمی‌گردانند.

---

## 4. مقایسه در Value Types

### رفتار ساده: مقایسه بر اساس مقدار

csharp
int x = 1;
int y = 2;
int z = 1;

Console.WriteLine(x == y); // False
Console.WriteLine(x == z); // True

**قانون:** برای Value Types، تساوی بر اساس **مقدار** ذخیره شده است.

---

## 5. مقایسه در Reference Types

### رفتار پیش‌فرض: مقایسه بر اساس مرجع

csharp
Dude d1 = new Dude("John");
Dude d2 = new Dude("John");
Console.WriteLine(d1 == d2); // False ❌ (دو مرجع متفاوت)

Dude d3 = d1;
Console.WriteLine(d1 == d3); // True ✅ (همان مرجع)

public class Dude
{
public string Name;
public Dude(string n) { Name = n; }
}

### تفسیر:

| مقایسه | نتیجه | دلیل |
|--------|-------|------|
| `d1 == d2` | `False` | دو شیء مجزا در حافظه (حتی با محتوای یکسان) |
| `d1 == d3` | `True` | هر دو به **همان آدرس حافظه** اشاره می‌کنند |

**نکته مهم:** برای مقایسه محتوا (نه مرجع)، باید عملگر `==` را Overload کنید یا از متدهای `Equals` استفاده کنید (Chapter 6).

---

## 6. عملگرهای مقایسه: `<`, `>`, `<=`, `>=`

### 6.1. استفاده با انواع عددی

csharp
int a = 10, b = 20;
Console.WriteLine(a < b);  // True
Console.WriteLine(a >= b); // False

### 6.2. هشدار برای اعداد اعشاری

csharp
// ⚠️ خطر: خطای گرد کردن
double sum = 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1;
Console.WriteLine(sum == 1.0); // False (به دلیل 1.0000001)

**یادآوری:** از مقایسه مستقیم اعداد `double` با `==` خودداری کنید (صفحه 54).

### 6.3. استفاده با `enum`

csharp
enum Priority { Low = 1, Medium = 2, High = 3 }

Priority p1 = Priority.Low;
Priority p2 = Priority.High;

Console.WriteLine(p1 < p2); // True (مقایسه بر اساس مقدار زیرین: 1 < 3)

**قانون:** عملگرهای مقایسه روی `enum` بر اساس **مقدار Integral زیرین** کار می‌کنند (جزئیات در صفحه 154).

---

## 7. خلاصه نهایی

### نکات کلیدی:

1. **ذخیره‌سازی:**
   - `bool`: 1 بیت منطقی، 1 بایت فیزیکی
   - برای آرایه‌های بزرگ: `BitArray` (1 بیت/مقدار)

2. **تبدیل:**
   - هیچ تبدیل مستقیمی بین `bool` و اعداد وجود ندارد
   - باید از مقایسه یا عملگر سه‌تایی استفاده شود

3. **عملگرهای تساوی (`==`, `!=`):**
   - Value Types: مقایسه بر اساس **مقدار**
   - Reference Types: مقایسه بر اساس **مرجع** (پیش‌فرض)

4. **عملگرهای مقایسه (`<`, `>`, `<=`, `>=`):**
   - کار می‌کنند برای: اعداد، `enum`
   - احتیاط با `double`/`float` (خطای گرد کردن)

### کد خلاصه:

csharp
// ✅ Bool
bool flag = true;

// ❌ تبدیل غیرممکن
// int x = flag; // خطا

// ✅ Value Type Equality
int a = 5, b = 5;
Console.WriteLine(a == b); // True (مقایسه مقدار)

// ✅ Reference Type Equality
string s1 = new string("Hi");
string s2 = new string("Hi");
Console.WriteLine(s1 == s2); // True (string عملگر == را Overload کرده)

object o1 = new object();
object o2 = new object();
Console.WriteLine(o1 == o2); // False (مقایسه مرجع)

---

## 8. ارجاعات به مباحث بعدی

- **Operator Overloading:** صفحه 256 (Chapter 4)
- **Equality Comparison:** صفحه 344 (Chapter 6)
- **Order Comparison:** صفحه 355 (Chapter 6)
- **Enums:** صفحه 154

# نکات فنی - Boolean Type و عملگرهای مقایسه

## 1. نوع `bool`

- **نوع پایه:** `System.Boolean`
- **مقادیر:** `true` / `false`
- **ذخیره:** 1 بیت منطقی، 1 بایت فیزیکی
- **بهینه‌سازی آرایه:** `BitArray` در `System.Collections` (1 بیت/مقدار)
```csharp
bool flag = true;
BitArray bits = new BitArray(1000); // صرفه‌جویی فضا

---

## 2. تبدیل `bool`

**قانون:** هیچ تبدیلی بین `bool` و اعداد وجود ندارد.

csharp
// ❌ خطا
bool b = 1;
int x = true;

// ✅ صحیح
bool b = (x != 0);
int num = b ? 1 : 0;

---

## 3. عملگرهای `==` و `!=`

**خروجی همیشه `bool` است.**

### Value Types: مقایسه مقدار

csharp
int x = 1, y = 2, z = 1;
Console.WriteLine(x == y); // False
Console.WriteLine(x == z); // True

### Reference Types: مقایسه مرجع

csharp
Dude d1 = new Dude("John");
Dude d2 = new Dude("John");
Console.WriteLine(d1 == d2); // False (دو شیء متفاوت)

Dude d3 = d1;
Console.WriteLine(d1 == d3); // True (همان مرجع)

public class Dude
{
public string Name;
public Dude(string n) { Name = n; }
}

---

## 4. عملگرهای مقایسه (`<`, `>`, `<=`, `>=`)

- **کار می‌کنند روی:** انواع عددی، `enum`
- **احتیاط:** استفاده با `double`/`float` (خطای گرد کردن)
- **`enum`:** مقایسه بر اساس مقدار Integral زیرین

csharp
// ⚠️ خطر
double sum = 0.1 * 10;
Console.WriteLine(sum == 1.0); // False!

---

## 5. خلاصه

| مورد | Value Types | Reference Types |
|------|-------------|-----------------|
| `==` | مقدار | مرجع |
| تبدیل به عدد | ❌ | - |
| `BitArray` | بهینه آرایه | - |

**ارجاعات:** Operator Overloading، Equality/Order Comparison، Enums




# نکات فنی - عملگرهای شرطی (Conditional Operators)

## 1. عملگرهای `&&` و `||`

**کاربرد:** بررسی شرایط `AND` و `OR`
```csharp
static bool UseUmbrella(bool rainy, bool sunny, bool windy)
{
return !windy && (rainy || sunny);
}

**منطق:** چتر استفاده شود اگر باران یا آفتاب باشد **و** باد نباشد.

---

## 2. Short-Circuit Evaluation

**تعریف:** اگر نتیجه از ابتدا مشخص باشد، بقیه عبارت ارزیابی نمی‌شود.

### مثال کاربردی

csharp
if (sb != null && sb.Length > 0) // ✅ از NullReferenceException جلوگیری می‌کند

**توضیح:** اگر `sb` برابر `null` باشد، `sb.Length` اصلاً اجرا نمی‌شود.

---

## 3. عملگرهای `&` و `|`

**تفاوت اصلی:** Short-circuit **نمی‌کنند**.

csharp
return !windy & (rainy | sunny); // همه عبارات ارزیابی می‌شوند

**نکته:** به ندرت به‌جای `&&` / `||` استفاده می‌شوند.

### هشدار C/C++

در C#:
- `&` / `|` روی `bool`: عملیات Boolean (بدون short-circuit)
- `&` / `|` روی اعداد: عملیات Bitwise

---

## 4. عملگر سه‌تایی (Ternary Operator)

**فرمت:** `شرط ? مقدار_درست : مقدار_نادرست`

csharp
static int Max(int a, int b)
{
return (a > b) ? a : b;
}

**مزایا:**
- کد فشرده‌تر
- مفید در LINQ queries (Chapter 8)

---

## 5. خلاصه

| عملگر | Short-Circuit | کاربرد |
|-------|---------------|--------|
| `&&` / `||` | ✅ | پیشنهادی |
| `&` / `|` | ❌ | نادر |
| `? :` | - | جایگزین `if-else` |

**نکته کلیدی:** همیشه از `&&` / `||` استفاده کنید (به‌جز موارد خاص).




# نکات فنی - Strings و Characters

## 1. نوع `char`

- **نوع پایه:** `System.Char`
- **اندازه:** 2 بایت (UTF-16)
- **نمایش:** یک کاراکتر Unicode
- **سینتکس:** بین علامت‌های نقل قول تکی (`'`)
```csharp
char c = 'A';
char persianChar = 'س';

---

## 2. Escape Sequences

**تعریف:** کاراکترهای خاص که با `\` (backslash) شروع می‌شوند.

**مهم‌ترین موارد:**

- `\n` → خط جدید (New line)
- `\t` → Tab
- `\\` → Backslash
- `\'` → Single quote
- `\"` → Double quote
- `\0` → Null

csharp
char newLine = '\n';
char backSlash = '\\';
char tab = '\t';

---

## 3. Unicode Escape Sequences

**فرمت:** `\u` + کد هگزادسیمال 4 رقمی

csharp
char copyrightSymbol = '\u00A9';  // ©
char omegaSymbol = '\u03A9';      // Ω
char newLine = '\u000A';          // معادل \n

**نکته:** می‌توان از `\x` به‌جای `\u` نیز استفاده کرد.

---

## 4. تبدیل `char`

### Implicit Conversion
`char` به صورت Implicit به انواعی که **unsigned short** (2 بایت بدون علامت) را پشتیبانی می‌کنند، تبدیل می‌شود.

csharp
char c = 'A';
int num = c;        // ✅ Implicit (مقدار: 65)
ushort us = c;      // ✅ Implicit

### Explicit Conversion
برای سایر انواع عددی نیاز به Cast صریح است.

csharp
char c = 'A';
byte b = (byte)c;   // ⚠️ Explicit (ریسک از دست دادن داده)
short s = (short)c; // ✅ Explicit

---

## 5. نکات کلیدی

- `char` یک **Value Type** عددی است (unsigned 16-bit)
- هر `char` یک کد Unicode دارد (مثلاً `'A'` = 65)
- استفاده از Escape sequences برای کاراکترهای غیرقابل نمایش ضروری است
- تبدیل به انواع بزرگ‌تر Implicit، به انواع کوچک‌تر Explicit است



# نکات فنی - String Type

## 1. ویژگی‌های `string`

- **نوع پایه:** `System.String`
- **نوع:** Reference Type (اما رفتار مقایسه‌اش Value Type است)
- **ویژگی کلیدی:** **Immutable** (غیرقابل تغییر)
- **سینتکس:** بین علامت‌های نقل قول دوتایی (`"`)
```csharp
string a = "Heat";

---

## 2. رفتار خاص Equality

با وجود اینکه `string` یک Reference Type است، عملگر `==` بر اساس **محتوا** (مانند Value Types) عمل می‌کند.

csharp
string a = "test";
string b = "test";
Console.Write(a == b); // True (محتوا یکسان است)

---

## 3. Escape Sequences در String

همان قوانین `char` برای `string` نیز اعمال می‌شود:

csharp
string a = "Here's a tab:\t";

**مشکل:** برای نمایش backslash باید دوبار نوشت:

csharp
string a1 = "\\\\server\\fileshare\\helloworld.cs";

---

## 4. Verbatim String Literals

**تعریف:** با `@` شروع می‌شود و Escape sequences را پردازش نمی‌کند.

csharp
string a2 = @"\\server\fileshare\helloworld.cs";

**مزیت اول:** نیازی به دوبار نوشتن backslash نیست.

**مزیت دوم:** پشتیبانی از چند خط:

csharp
string verbatim = @"First Line
Second Line";

**نمایش Double Quote:** با نوشتن دوبار:

csharp
string xml = @"<customer id=""123""></customer>";

---

## 5. String Concatenation

استفاده از عملگر `+`:

csharp
string s = "a" + "b";  // "ab"
string s = "a" + 5;    // "a5" (ToString خودکار فراخوانی می‌شود)

**هشدار عملکرد:** استفاده مکرر از `+` **ناکارآمد** است (به دلیل Immutability).

**راه‌حل بهینه:** استفاده از `System.Text.StringBuilder` (Chapter 6)

csharp
// ❌ ناکارآمد
string result = "";
for (int i = 0; i < 1000; i++)
result += i.ToString();

// ✅ کارآمد
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 1000; i++)
sb.Append(i);
string result = sb.ToString();

---

## 6. نکات کلیدی

- `string` Immutable است → هر تغییر یک شیء جدید می‌سازد
- عملگر `==` بر اساس محتوا مقایسه می‌کند (نه مرجع)
- Verbatim strings (`@`) برای مسیرها و متن‌های چند خطی ایده‌آل هستند
- برای الحاق زیاد از `StringBuilder` استفاده کنید




# نکات فنی - String Interpolation و String Comparisons

## 1. String Interpolation (رشته‌های درون‌یابی شده)

**تعریف:** رشته‌ای که با `$` شروع می‌شود و می‌تواند عبارات C# را درون `{}` داشته باشد.
```csharp
int x = 4;
Console.Write($"A square has {x} sides"); 
// خروجی: A square has 4 sides

---

## 2. عبارات درون Braces

- هر عبارت معتبر C# از هر نوعی قابل استفاده است
- C# به صورت خودکار `ToString()` را فراخوانی می‌کند

csharp
int number = 42;
string name = "Ali";
Console.WriteLine($"Name: {name}, Number: {number}");

---

## 3. Format Strings

با استفاده از `:` می‌توان قالب‌بندی سفارشی اعمال کرد:

csharp
string s = $"255 in hex is {byte.MaxValue:X2}";
// خروجی: "255 in hex is FF"
// X2 = هگزادسیمال 2 رقمی

**فرمت‌های رایج:**
- `X` یا `X2` → Hexadecimal
- `F2` → عدد اعشاری با 2 رقم
- `C` → قالب پولی

---

## 4. استفاده از Colon برای اهداف دیگر

اگر بخواهید از `:` برای موارد دیگر (مثل Ternary Operator) استفاده کنید، باید کل عبارت را داخل پرانتز بگذارید:

csharp
bool b = true;
Console.WriteLine($"The answer in binary is {(b ? 1 : 0)}");

---

## 5. String Interpolation چند خطی

برای استفاده چند خطی باید از **Verbatim String** (`@`) نیز استفاده کنید:

csharp
int x = 2;
// توجه: $ باید قبل از @ باشد (قبل از C# 8)
string s = $@"this interpolation spans {
x} lines";

---

## 6. Brace Literals

برای نمایش `{` یا `}` به صورت متن، باید دوبار نوشته شود:

csharp
string s = $"{{این یک brace است}}";
// خروجی: "{این یک brace است}"

---

## 7. String Comparisons

**محدودیت:** `string` از عملگرهای `<` و `>` پشتیبانی نمی‌کند.

**راه‌حل:** استفاده از متد `CompareTo` (Chapter 6)

csharp
string a = "apple";
string b = "banana";

// ❌ غیرمجاز
// if (a < b) { }

// ✅ صحیح
if (a.CompareTo(b) < 0) {
Console.WriteLine("a کوچکتر از b است");
}

**نکته:** `CompareTo` یک عدد برمی‌گرداند:
- منفی: اولی کوچکتر است
- صفر: برابر هستند
- مثبت: اولی بزرگتر است

---

## 8. Constant Interpolated Strings (C# 10+)

از C# 10 به بعد، رشته‌های درون‌یابی شده می‌توانند **ثابت** (`const`) باشند، به شرطی که مقادیر درون‌یابی شده نیز ثابت باشند:

csharp
const string greeting = "Hello";
const string message = $"{greeting}, world";
// message = "Hello, world"

**محدودیت:** فقط با مقادیر `const` کار می‌کند، نه متغیرهای معمولی.

---

## 9. نکات کلیدی

- String Interpolation خوانایی کد را افزایش می‌دهد
- قالب‌بندی با `:` امکان کنترل دقیق خروجی را فراهم می‌کند
- برای مقایسه رشته‌ها از `CompareTo` استفاده کنید
- از C# 10، رشته‌های interpolated می‌توانند constant باشند



# نکات فنی - Arrays (آرایه‌ها)

## 1. تعریف و ویژگی‌های Array

**تعریف:** نمایش تعداد ثابتی از متغیرها (عناصر) از یک نوع مشخص.

**ویژگی کلیدی:** عناصر در یک **بلوک پیوسته حافظه** ذخیره می‌شوند → دسترسی بسیار کارآمد
```csharp
char[] vowels = new char[5]; // آرایه‌ای از 5 کاراکتر

---

## 2. سینتکس و اعلان

**فرمت:** `نوع[] نام_متغیر`

csharp
int[] numbers = new int[10];
string[] names = new string[3];

---

## 3. دسترسی به عناصر (Indexing)

- از **کروشه** (`[]`) برای دسترسی استفاده می‌شود
- **Index از صفر شروع می‌شود** (Zero-based)

csharp
vowels[0] = 'a';
vowels[1] = 'e';
vowels[2] = 'i';
vowels[3] = 'o';
vowels[4] = 'u';
Console.WriteLine(vowels[1]); // خروجی: e

---

## 4. پیمایش روی Array با حلقه `for`

csharp
for (int i = 0; i < vowels.Length; i++)
Console.Write(vowels[i]); // خروجی: aeiou

---

## 5. ویژگی `Length`

- تعداد عناصر آرایه را برمی‌گرداند
- **نکته مهم:** پس از ایجاد آرایه، **طول آن قابل تغییر نیست** (Fixed-size)

csharp
int[] numbers = new int[5];
Console.WriteLine(numbers.Length); // 5

---

## 6. Array Initialization Expression

**روش اول (کامل):**
csharp
char[] vowels = new char[] {'a', 'e', 'i', 'o', 'u'};

**روش دوم (مختصر):**
csharp
char[] vowels = {'a', 'e', 'i', 'o', 'u'};

---

## 7. کلاس `System.Array`

- همه آرایه‌ها از کلاس `System.Array` ارث‌بری می‌کنند
- متدهای مشترک برای کار با انواع مختلف آرایه فراهم می‌کند
- جزئیات بیشتر در بخش "The Array Class"

---

## 8. جایگزین‌های Dynamic

برای ساختارهای داده با اندازه متغیر:
- `System.Collection` namespace
- مثال‌ها:
  - **Dynamic arrays:** `List<T>`
  - **Dictionaries:** `Dictionary<TKey, TValue>`

csharp
// ❌ Array: اندازه ثابت
int[] fixedArray = new int[5];

// ✅ List: اندازه متغیر
List<int> dynamicList = new List<int>();
dynamicList.Add(1);
dynamicList.Add(2);

---

## 9. نکات کلیدی

- آرایه‌ها **Fixed-size** هستند (طول ثابت)
- Index از **صفر** شروع می‌شود
- ذخیره‌سازی **پیوسته در حافظه** → عملکرد بالا
- برای اندازه متغیر از `List<T>` استفاده کنید
- همه آرایه‌ها از `System.Array` ارث می‌برند





# نکات فنی - Default Element Initialization و Value/Reference Types در Arrays

## 1. مقداردهی اولیه پیش‌فرض (Default Element Initialization)

**قانون:** هنگام ایجاد آرایه، همه عناصر به طور خودکار با **مقدار پیش‌فرض** مقداردهی می‌شوند.

**مقدار پیش‌فرض:** نتیجه **صفر شدن بیتی حافظه** (bitwise zeroing)
```csharp
int[] a = new int[1000];
Console.Write(a[123]); // خروجی: 0

---

## 2. Value Types در Array

هنگامی که نوع عنصر **Value Type** است، هر مقدار **به صورت مستقیم** در آرایه ذخیره می‌شود:

csharp
Point[] a = new Point[1000];
int x = a[500].X; // 0 (بدون خطا)

public struct Point { public int X, Y; }

**توضیح:**
- 1000 عدد `Point` به طور کامل در حافظه تخصیص داده می‌شود
- هر `Point` دارای مقادیر پیش‌فرض است (`X=0`, `Y=0`)

---

## 3. Reference Types در Array

هنگامی که نوع عنصر **Reference Type** است، فقط **1000 مرجع null** ایجاد می‌شود:

csharp
Point[] a = new Point[1000];
int x = a[500].X; // ❌ Runtime Error: NullReferenceException

public class Point { public int X, Y; }

**دلیل خطا:** `a[500]` برابر `null` است و نمی‌توان به `X` دسترسی داشت.

---

## 4. راه‌حل: Instantiation صریح

برای استفاده از Reference Types باید **هر عنصر را جداگانه** ایجاد کنید:

csharp
Point[] a = new Point[1000];
for (int i = 0; i < a.Length; i++) 
{
a[i] = new Point(); // ایجاد شیء جدید برای هر عنصر
}

// حالا می‌توان استفاده کرد:
int x = a[500].X; // ✅ بدون خطا

---

## 5. تفاوت عملکردی (Performance Implications)

| جنبه | Value Type (struct) | Reference Type (class) |
|------|---------------------|------------------------|
| **ذخیره‌سازی** | مستقیم در آرایه | فقط مرجع در آرایه |
| **تخصیص حافظه** | یکجا و پیوسته | نیاز به new برای هر عنصر |
| **عملکرد** | سریع‌تر (locality) | کندتر (indirection) |
| **مقدار اولیه** | مقدار پیش‌فرض | `null` |

---

## 6. خود Array همیشه Reference Type است

**نکته مهم:** خود آرایه **همیشه** یک شیء Reference Type است، **صرف نظر از نوع عنصر**:

csharp
int[] a = null; // ✅ مجاز است
// حتی اگر int یک Value Type باشد، آرایه خودش Reference است

---

## 7. مثال مقایسه‌ای

**Struct (Value Type):**
csharp
public struct Point { public int X, Y; }
Point[] points = new Point[3]; 
// حافظه: [Point(0,0), Point(0,0), Point(0,0)]
// بلافاصله قابل استفاده

**Class (Reference Type):**
csharp
public class Point { public int X, Y; }
Point[] points = new Point[3]; 
// حافظه: [null, null, null]
// نیاز به initialization:
for (int i = 0; i < 3; i++)
points[i] = new Point();

---

## 8. نکات کلیدی

- **Default Values:** همه عناصر با صفر (یا null برای reference types) شروع می‌شوند
- **Value Types:** ذخیره مستقیم → عملکرد بهتر
- **Reference Types:** نیاز به `new` برای هر عنصر
- **خود Array:** همیشه reference type است
- **توصیه:** برای آرایه‌های بزرگ از structs، عملکرد بهتری دارید



# نکات فنی - Indices and Ranges (C# 8+)

## 1. مروری کلی

**معرفی شده در:** C# 8

**هدف:** ساده‌سازی کار با عناصر یا بخش‌هایی از آرایه

**کاربرد:**
- آرایه‌های معمولی
- `Span<T>` و `ReadOnlySpan<T>` (Chapter 23)
- انواع سفارشی (با تعریف Indexer از نوع `Index` یا `Range`)

---

## 2. Indices - شاخص‌های نسبی

**عملگر `^` (Hat):** برای ارجاع به عناصر از انتهای آرایه
```csharp
char[] vowels = {'a', 'e', 'i', 'o', 'u'};

char lastElement = vowels[^1];      // 'u' (آخرین عنصر)
char secondToLast = vowels[^2];     // 'o' (یکی مانده به آخر)

**نکته حیاتی:** `^0` برابر با طول آرایه است و **خطا می‌دهد**

csharp
char error = vowels[^0]; // ❌ IndexOutOfRangeException

**نوع `Index`:** می‌توان شاخص را در متغیر ذخیره کرد

csharp
Index first = 0;
Index last = ^1;

char firstElement = vowels[first];  // 'a'
char lastElement = vowels[last];    // 'u'

---

## 3. Ranges - برش آرایه

**عملگر `..` (Range):** برای دریافت بخشی از آرایه

csharp
char[] vowels = {'a', 'e', 'i', 'o', 'u'};

char[] firstTwo = vowels[..2];      // 'a', 'e'
char[] lastThree = vowels[2..];     // 'i', 'o', 'u'
char[] middleOne = vowels[2..3];    // 'i'

**قانون مهم:** عدد دوم در Range **Exclusive** است (شامل نمی‌شود)

csharp
vowels[..2]   // عناصر قبل از index 2 → فقط 0 و 1
vowels[2..]   // از index 2 تا انتها
vowels[2..3]  // فقط index 2 (3 شامل نمی‌شود)

---

## 4. ترکیب `^` با Ranges

می‌توان در Range نیز از `^` استفاده کرد:

csharp
char[] lastTwo = vowels[^2..];      // 'o', 'u'
char[] allButLast = vowels[..^1];   // 'a', 'e', 'i', 'o'
char[] middle = vowels[1..^1];      // 'e', 'i', 'o'

**نوع `Range`:** ذخیره Range در متغیر

csharp
Range firstTwoRange = 0..2;
char[] firstTwo = vowels[firstTwoRange];  // 'a', 'e'

---

## 5. مثال جامع

csharp
int[] numbers = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

// Indices
int last = numbers[^1];           // 9
int thirdLast = numbers[^3];      // 7

// Ranges
int[] first3 = numbers[..3];      // {0, 1, 2}
int[] last3 = numbers[^3..];      // {7, 8, 9}
int[] middle = numbers[3..7];     // {3, 4, 5, 6}
int[] skipEnds = numbers[1..^1];  // {1, 2, ..., 8}

// استفاده از متغیرها
Index idx = ^2;
Range rng = 2..5;
int value = numbers[idx];         // 8
int[] slice = numbers[rng];       // {2, 3, 4}

---

## 6. نکات کلیدی برای ارائه

**Indices:**
- `^1` آخرین عنصر، `^2` یکی مانده به آخر
- `^0` خطا می‌دهد
- نوع `Index` برای ذخیره‌سازی

**Ranges:**
- `..` برای برش آرایه
- عدد دوم **Exclusive**
- `[..n]` از ابتدا، `[n..]` تا انتها
- `^` در Range قابل استفاده

**مزایا:**
- کد خواناتر و مختصرتر
- کمتر مستعد خطا
- جایگزین محاسبات `Length - 1`


# نکات فنی - Multidimensional Arrays

## 1. دو نوع آرایه چندبعدی

**Rectangular Arrays:** بلوک حافظه n-بعدی منظم

**Jagged Arrays:** آرایه‌ای از آرایه‌ها (طول‌های متفاوت)

---

## 2. Rectangular Arrays - آرایه‌های مستطیلی

**تعریف:** از کاما برای جداسازی ابعاد استفاده می‌شود
```csharp
int[,] matrix = new int[3, 3];  // آرایه 3×3

**دسترسی به طول هر بعد:** متد `GetLength(dimension)`

csharp
for (int i = 0; i < matrix.GetLength(0); i++)      // بعد اول (سطرها)
for (int j = 0; j < matrix.GetLength(1); j++)  // بعد دوم (ستون‌ها)
matrix[i, j] = i * 3 + j;

**مقداردهی اولیه صریح:**

csharp
int[,] matrix = new int[,]
{
{0, 1, 2},
{3, 4, 5},
{6, 7, 8}
};

---

## 3. Jagged Arrays - آرایه‌های ناهموار

**تعریف:** براکت‌های متوالی برای هر بعد

csharp
int[][] matrix = new int[3][];  // بعد بیرونی = 3

**نکته مهم:** سینتکس `new int[3][]` است نه `new int[][3]`

**ویژگی کلیدی:** ابعاد داخلی در تعریف مشخص نمی‌شوند

- هر آرایه داخلی می‌تواند طول دلخواه داشته باشد
- آرایه‌های داخلی به صورت پیش‌فرض `null` هستند
- باید دستی ساخته شوند

csharp
for (int i = 0; i < matrix.Length; i++)
{
matrix[i] = new int[3];  // ساخت آرایه داخلی
for (int j = 0; j < matrix[i].Length; j++)
matrix[i][j] = i * 3 + j;
}

**مقداردهی اولیه صریح:**

csharp
int[][] matrix = new int[][]
{
new int[] {0, 1, 2},
new int[] {3, 4, 5},
new int[] {6, 7, 8, 9}  // طول متفاوت
};

---

## 4. مقایسه Rectangular vs Jagged

**Rectangular Arrays:**
- همه ابعاد یکسان
- حافظه پیوسته
- سینتکس: `int[,]` یا `int[,,]`
- دسترسی: `array[i, j]`

**Jagged Arrays:**
- ابعاد داخلی می‌توانند متفاوت باشند
- انعطاف‌پذیرتر
- سینتکس: `int[][]` یا `int[][][]`
- دسترسی: `array[i][j]`

---

## 5. مثال کاربردی

csharp
// Rectangular - جدول ضرب 3×3
int[,] multiTable = new int[3, 3];
for (int i = 0; i < 3; i++)
for (int j = 0; j < 3; j++)
multiTable[i, j] = (i + 1) * (j + 1);

// Jagged - مثلث اعداد
int[][] triangle = new int[4][];
for (int i = 0; i < triangle.Length; i++)
{
triangle[i] = new int[i + 1];  // هر سطر یک عنصر بیشتر
for (int j = 0; j <= i; j++)
triangle[i][j] = j + 1;
}
// triangle[0]: {1}
// triangle[1]: {1, 2}
// triangle[2]: {1, 2, 3}
// triangle[3]: {1, 2, 3, 4}

---

## 6. نکات کلیدی برای ارائه

**Rectangular:**
- ساختار ثابت و منظم
- `GetLength(dimension)` برای طول هر بعد
- کاما در تعریف: `[,]` یا `[,,]`

**Jagged:**
- انعطاف در طول آرایه‌های داخلی
- نیاز به مقداردهی دستی آرایه‌های داخلی
- براکت‌های متوالی: `[][]` یا `[][][]`

**انتخاب:**
- Rectangular → داده‌های ماتریسی منظم
- Jagged → ساختارهای نامنظم یا صرفه‌جویی حافظه


# نکات فنی - Simplified Array Initialization

## 1. دو روش کوتاه‌سازی مقداردهی آرایه

**روش اول:** حذف `new` و مشخصات نوع

**روش دوم:** استفاده از `var` برای تعیین نوع خودکار

---

## 2. حذف new و مشخصات نوع

**آرایه تک‌بعدی:**
```csharp
char[] vowels = {'a', 'e', 'i', 'o', 'u'};

**آرایه Rectangular:**

csharp
int[,] rectangularMatrix =
{
{0, 1, 2},
{3, 4, 5},
{6, 7, 8}
};

**آرایه Jagged:**

csharp
int[][] jaggedMatrix =
{
new int[] {0, 1, 2},
new int[] {3, 4, 5},
new int[] {6, 7, 8, 9}
};

**نکته:** در Jagged باید `new int[]` برای آرایه‌های داخلی نوشته شود

---

## 3. استفاده از var

**مفهوم:** کامپایلر نوع متغیر را خودکار تشخیص می‌دهد

csharp
var i = 3;           // int
var s = "sausage";   // string

**با آرایه‌های Rectangular:**

csharp
var rectMatrix = new int[,]
{
{0, 1, 2},
{3, 4, 5},
{6, 7, 8}
};
// نوع: int[,]

**با آرایه‌های Jagged:**

csharp
var jaggedMat = new int[][]
{
new int[] {0, 1, 2},
new int[] {3, 4, 5},
new int[] {6, 7, 8, 9}
};
// نوع: int[][]

---

## 4. حذف نوع بعد از new (Array Type Inference)

کامپایلر نوع آرایه را از روی عناصر تشخیص می‌دهد:

csharp
var vowels = new[] {'a', 'e', 'i', 'o', 'u'};  // char[]

**شرایط لازم برای Type Inference:**

- همه عناصر باید به یک نوع واحد قابل تبدیل باشند
- حداقل یک عنصر از آن نوع باشد
- دقیقاً یک بهترین نوع مشترک وجود داشته باشد

**مثال:**

csharp
var x = new[] {1, 10000000000};  // long[]
// چون 10000000000 از int بیرون است

---

## 5. مثال‌های ترکیبی

**سینتکس کامل:**

csharp
int[] numbers = new int[] {1, 2, 3};

**حذف new:**

csharp
int[] numbers = {1, 2, 3};

**استفاده از var:**

csharp
var numbers = new int[] {1, 2, 3};

**حذف نوع + var:**

csharp
var numbers = new[] {1, 2, 3};  // کوتاه‌ترین حالت

---

## 6. نکات کلیدی برای ارائه

**سه سطح ساده‌سازی:**

1. **حذف `new` و نوع:** فقط زمانی که نوع متغیر مشخص است
```csharp
   int[] arr = {1, 2, 3};




# نکات فنی - Bounds Checking & Memory Management

## 1. Bounds Checking - بررسی محدوده آرایه

**مفهوم:** Runtime تمام دسترسی‌های آرایه را بررسی می‌کند
```csharp
int[] arr = new int[3];
arr[3] = 1;  // IndexOutOfRangeException

**دلایل اهمیت:**

- **Type Safety:** امنیت نوع داده
- **Debugging:** ساده‌سازی رفع اشکال

**بهینه‌سازی‌های JIT:**

- JIT می‌تواند قبل از ورود به حلقه ایمنی را تشخیص دهد
- در این صورت بررسی در هر iteration حذف می‌شود
- هزینه performance معمولاً ناچیز است

**گزینه Unsafe:**

- C# امکان bypass کردن bounds checking را دارد
- از طریق Unsafe Code (صفحه 263)

---

## 2. Variables and Parameters - متغیرها و پارامترها

**انواع متغیرها:**

- **Local variable:** متغیر محلی
- **Parameter:** پارامتر (value, ref, out, in)
- **Field:** فیلد (instance یا static)
- **Array element:** عنصر آرایه

---

## 3. Stack - پشته

**تعریف:** بلوک حافظه برای متغیرهای محلی و پارامترها

**رفتار:** منطقی رشد و کاهش با ورود/خروج متد

**مثال - متد بازگشتی:**

csharp
static int Factorial(int x)
{
if (x == 0) return 1;
return x * Factorial(x - 1);
}

**چرخه عمر:**

- هر بار ورود به متد → یک `int` جدید در Stack
- هر بار خروج از متد → `int` deallocate می‌شود

---

## 4. Heap - هیپ

**تعریف:** حافظه‌ای که اشیاء (reference types) در آن ذخیره می‌شوند

**چرخه عمر:**

1. شیء جدید → Allocation در Heap
2. Reference به شیء برگردانده می‌شود
3. Garbage Collector → Deallocation اشیاء بلااستفاده

**شرط Deallocation:**

شیء زمانی قابل حذف است که هیچ reference زنده‌ای به آن نداشته باشد

**مثال:**

csharp
using System.Text;

StringBuilder ref1 = new StringBuilder("object1");
Console.WriteLine(ref1);
// ref1 فوراً قابل GC است (استفاده نشده)

StringBuilder ref2 = new StringBuilder("object2");
StringBuilder ref3 = ref2;
// ref2 استفاده نشده اما شیء زنده است
// چون ref3 به آن اشاره دارد

Console.WriteLine(ref3);  // object2

---

## 5. Value Types vs Reference Types در حافظه

**Value-type instances:**

محل ذخیره بستگی به محل تعریف متغیر دارد:

- اگر field یک class → Heap
- اگر array element → Heap
- اگر local variable → Stack

**Reference-type instances:**

- خود شیء → همیشه Heap
- Reference به شیء → بستگی به محل تعریف

---

## 6. ویژگی‌های کلیدی Heap

**Garbage Collection:**

- حذف صریح شیء (مثل C++) وجود ندارد
- GC به صورت خودکار اشیاء بلااستفاده را حذف می‌کند

**Static Fields:**

- در Heap ذخیره می‌شوند
- برخلاف اشیاء عادی، GC نمی‌شوند
- تا پایان Process زنده می‌مانند

---

## 7. نکات کلیدی برای ارائه

**Stack:**
- متغیرهای محلی و پارامترها
- رشد/کاهش خودکار با ورود/خروج متد
- سریع و موقت

**Heap:**
- اشیاء (reference types)
- Garbage Collector
- Static fields (تا پایان process)

**Bounds Checking:**
- امنیت + سادگی debugging
- JIT optimization
- هزینه performance ناچیز

**قانون طلایی:**

Reference به شیء → محل تعریف متغیر
خود شیء → همیشه Heap


# نکات فنی - Definite Assignment & Parameters

## 1. Definite Assignment - تخصیص قطعی

**تعریف:** C# اجبار می‌کند که متغیرها قبل از استفاده مقداردهی شوند

**هدف:** جلوگیری از دسترسی به حافظه مقداردهی نشده

---

## 2. سه قانون Definite Assignment

**1. متغیرهای محلی:**

باید قبل از خواندن مقداردهی شوند
```csharp
int x;
Console.WriteLine(x);  // Compile-time error

**2. آرگومان‌های تابع:**

باید هنگام فراخوانی ارائه شوند (مگر optional باشند)

**3. سایر متغیرها:**

خودکار توسط runtime مقداردهی می‌شوند:
- Fields
- Array elements

---

## 3. مقداردهی خودکار

**آرایه‌ها:**

csharp
int[] ints = new int[2];
Console.WriteLine(ints[0]);  // 0

**Fields:**

csharp
Console.WriteLine(Test.X);  // 0

class Test
{
public static int X;  // خودکار = 0
}

---

## 4. Default Values - مقادیر پیش‌فرض

**جدول مقادیر پیش‌فرض:**

| نوع | مقدار پیش‌فرض |
|-----|---------------|
| Reference types (و nullable value types) | `null` |
| Numeric و enum types | `0` |
| `char` | `'\0'` |
| `bool` | `false` |

**نکته:** مقدار پیش‌فرض = صفر کردن bitwise حافظه

---

## 5. کلمه کلیدی default

**دریافت مقدار پیش‌فرض:**

csharp
Console.WriteLine(default(decimal));  // 0

**حذف نوع (Type Inference):**

csharp
decimal d = default;  // کامپایلر نوع را تشخیص می‌دهد

**Custom Value Types (struct):**

مقدار پیش‌فرض = مقدار پیش‌فرض هر field

---

## 6. Parameters - پارامترها

**تعریف:**

متد می‌تواند دنباله‌ای از پارامترها داشته باشد

csharp
Foo(8);  // 8 = argument

static void Foo(int p)  // p = parameter
{
// ...
}

---

## 7. Parameter Modifiers - تغییردهنده‌های پارامتر

**جدول مقایسه:**

| Modifier | نحوه انتقال | باید مقداردهی شده باشد؟ |
|----------|-------------|-------------------------|
| `(None)` | **Value** | ✓ ورودی |
| `ref` | **Reference** | ✓ ورودی |
| `in` | **Reference (read-only)** | ✓ ورودی |
| `out` | **Reference** | ✓ خروجی |

**توضیحات:**

- **Value (بدون modifier):** کپی مقدار ارسال می‌شود
- **ref:** ارجاع ارسال می‌شود، متغیر باید قبل از فراخوانی مقداردهی شده باشد
- **in:** ارجاع فقط‌خواندنی، متغیر باید قبل از فراخوانی مقداردهی شده باشد
- **out:** ارجاع ارسال می‌شود، متد باید قبل از بازگشت مقداردهی کند

---

## 8. مثال‌های کاربردی

**بدون modifier (Value):**

csharp
void Increment(int x)
{
x++;  // فقط کپی محلی تغییر می‌کند
}

int num = 5;
Increment(num);
Console.WriteLine(num);  // 5 (بدون تغییر)

**با ref:**

csharp
void Increment(ref int x)
{
x++;  // متغیر اصلی تغییر می‌کند
}

int num = 5;
Increment(ref num);
Console.WriteLine(num);  // 6

**با out:**

csharp
bool TryParse(string s, out int result)
{
// باید result را مقداردهی کنیم
result = 0;
return true;
}

---

## 9. نکات کلیدی برای ارائه

**Definite Assignment:**
- جلوگیری از باگ‌های حافظه
- متغیرهای محلی → مقداردهی اجباری
- Fields/Arrays → مقداردهی خودکار

**Default Values:**
- `default(T)` یا `default`
- Reference types → `null`
- Value types → `0` یا معادل

**Parameter Modifiers:**
- بدون modifier → انتقال مقدار
- `ref` → انتقال ارجاع (خواندن/نوشتن)
- `in` → انتقال ارجاع (فقط خواندن)
- `out` → انتقال ارجاع (مقداردهی در متد)



# نکات فنی - Passing Arguments (Value, ref, out)

## 1. Passing by Value (پیش‌فرض) - انتقال به صورت مقدار

**رفتار:** یک کپی از مقدار ساخته و به متد ارسال می‌شود

### مثال - Value Types:
```csharp
int x = 8;
Foo(x);  // کپی از x ارسال می‌شود
Console.WriteLine(x);  // x هنوز 8 است

static void Foo(int p)
{
p = p + 1;  // فقط p تغییر می‌کند
Console.WriteLine(p);  // 9
}

**نتیجه:** تغییر `p` روی `x` تأثیری ندارد (دو متغیر در آدرس‌های جداگانه)

---

## 2. Reference Types با Passing by Value

**رفتار:** ارجاع کپی می‌شود، اما خود شیء کپی نمی‌شود

csharp
StringBuilder sb = new StringBuilder();
Foo(sb);
Console.WriteLine(sb.ToString());  // test

static void Foo(StringBuilder fooSB)
{
fooSB.Append("test");  // شیء اصلی تغییر می‌کند
fooSB = null;          // فقط کپی محلی null می‌شود
}

**توضیح:**
- `sb` و `fooSB` → دو متغیر جداگانه
- هر دو به **یک شیء** اشاره دارند
- `fooSB.Append()` → شیء اصلی را تغییر می‌دهد
- `fooSB = null` → فقط کپی محلی را null می‌کند، `sb` همچنان معتبر است

**نکته:** اگر `fooSB` با `ref` تعریف شود، `sb` هم `null` می‌شود

---

## 3. ref Modifier - انتقال به صورت ارجاع

**تعریف:** `p` و `x` به یک آدرس حافظه اشاره می‌کنند

csharp
int x = 8;
Foo(ref x);  // x مستقیماً به Foo داده می‌شود
Console.WriteLine(x);  // x اکنون 9 است

static void Foo(ref int p)
{
p = p + 1;  // x مستقیماً تغییر می‌کند
Console.WriteLine(p);  // 9
}

**الزامات:**
- `ref` هم در تعریف متد و هم در فراخوانی لازم است
- متغیر باید قبل از فراخوانی مقداردهی شده باشد

**وضوح کد:** الزام `ref` در فراخوانی، رفتار را شفاف می‌کند

---

## 4. کاربرد کلاسیک ref - متد Swap

csharp
string x = "Penn";
string y = "Teller";
Swap(ref x, ref y);
Console.WriteLine(x);  // Teller
Console.WriteLine(y);  // Penn

static void Swap(ref string a, ref string b)
{
string temp = a;
a = b;
b = temp;
}

**نکته:** بدون `ref`، Swap کار نمی‌کند (فقط کپی‌ها جابجا می‌شوند)

---

## 5. out Modifier - خروجی اجباری

**قانون کلی:**
> پارامتر می‌تواند به صورت reference یا value ارسال شود، **صرف‌نظر** از اینکه نوع داده reference type یا value type باشد.

**ویژگی `out`:**
- مانند `ref` عمل می‌کند
- **تفاوت:** متغیر نیازی به مقداردهی قبل از فراخوانی ندارد
- **الزام:** متد باید قبل از بازگشت، متغیر را مقداردهی کند

---

## 6. مقایسه کامل ref و out

| ویژگی | `ref` | `out` |
|-------|-------|-------|
| نحوه انتقال | Reference | Reference |
| مقداردهی قبل از فراخوانی | ✓ الزامی | ✗ اختیاری |
| خواندن در متد | ✓ مجاز | ✗ قبل از نوشتن ممنوع |
| مقداردهی در متد | اختیاری | ✓ الزامی |
| کاربرد | تغییر دوطرفه | خروجی‌های اضافی |

---

## 7. مثال out - TryParse

csharp
string input = "123";
if (int.TryParse(input, out int result))
{
Console.WriteLine(result);  // 123
}
else
{
Console.WriteLine("Invalid");
}

**مزیت:** متد می‌تواند هم `bool` و هم مقدار تجزیه شده را برگرداند

---

## 8. نکات کلیدی برای ارائه

### Passing by Value (پیش‌فرض):
- **Value types:** کپی مقدار
- **Reference types:** کپی ارجاع (شیء مشترک است)
- تغییرات محلی روی متغیر اصلی تأثیری ندارد

### ref Modifier:
- انتقال آدرس واقعی
- الزام مقداردهی قبلی
- تغییرات مستقیم روی متغیر اصلی
- کاربرد: Swap، تغییر دوطرفه

### out Modifier:
- مانند `ref` اما بدون الزام مقداردهی قبلی
- متد باید مقداردهی کند
- کاربرد: برگرداندن چند مقدار (مثل `TryParse`)

### قانون طلایی:

نوع پارامتر (value/reference type) ≠ نحوه انتقال (by value/by reference)
می‌توان هر نوعی را با هر روشی ارسال کرد

---

## 9. دیاگرام حافظه

**Passing by Value (int):**

Stack:
  x: 8
  p: 8 (کپی)

**Passing by ref (int):**

Stack:
  x: 8
  p: → همان آدرس x

**Passing by Value (StringBuilder):**

Stack:          Heap:
  sb: ━━━━━━━━━━→ StringBuilder object
  fooSB: ━━━━━━━→ همان object

**Passing by ref (StringBuilder):**

Stack:          Heap:
  sb: ━━━━━━━━━━→ StringBuilder object
  fooSB: → همان آدرس sb

